{"version":3,"file":"crossbus.core.min.js","sources":["../src/core/message-types.js","../src/common/types.js","../src/common/utils.js","../src/core/event-emitter.js","../src/common/errors.js","../src/router/message-router.js","../src/router/pending-requests.js","../src/security/handshake.js","../src/security/origin-validator.js","../src/core/cross-bus.js"],"sourcesContent":["/**\n * @fileoverview Protocol message schemas for CrossBus.\n * All message types are frozen for immutability.\n * @module core/message-types\n */\n\n// Import MessageType from common/types to ensure consistent type codes\nimport { MessageType, PROTOCOL_MARKER as PROTOCOL_PREFIX, PROTOCOL_VERSION } from '../common/types.js';\n\n// Re-export for convenience\nexport { MessageType };\n\n/**\n * Delivery status constants.\n * @readonly\n * @enum {string}\n */\nexport const DeliveryStatus = Object.freeze({\n  /** Delivered to local listeners only */\n  LOCAL: 'local',\n  /** Sent to remote peer */\n  REMOTE: 'remote',\n  /** Queued for offline peer */\n  QUEUED: 'queued',\n  /** Delivery failed */\n  FAILED: 'failed'\n});\n\n/**\n * Peer connection status constants.\n * @readonly\n * @enum {string}\n */\nexport const PeerStatus = Object.freeze({\n  /** Connection in progress */\n  CONNECTING: 'connecting',\n  /** Successfully connected */\n  CONNECTED: 'connected',\n  /** Disconnected */\n  DISCONNECTED: 'disconnected',\n  /** Connection failed */\n  FAILED: 'failed'\n});\n\n/**\n * Peer type constants.\n * @readonly\n * @enum {string}\n */\nexport const PeerType = Object.freeze({\n  /** iframe element */\n  IFRAME: 'iframe',\n  /** Web Worker */\n  WORKER: 'worker',\n  /** Service Worker */\n  SERVICE_WORKER: 'service-worker',\n  /** Window (popup, tab) */\n  WINDOW: 'window',\n  /** MessagePort direct connection */\n  PORT: 'port',\n  /** Local (self) */\n  LOCAL: 'local'\n});\n\n// PROTOCOL_PREFIX and PROTOCOL_VERSION are imported from common/types.js\n\n/**\n * Creates a protocol message envelope.\n * \n * @param {MessageType} type - Message type.\n * @param {Object} payload - Message payload.\n * @param {Object} [meta={}] - Additional metadata.\n * @param {string|null} [id=null] - Optional custom message ID.\n * @returns {ProtocolMessage} Frozen message object.\n * \n * @typedef {Object} ProtocolMessage\n * @property {number} _cb - Protocol marker version (compact wire format).\n * @property {number} version - Protocol version.\n * @property {string} id - Unique message ID (UUID v4).\n * @property {MessageType} type - Message type.\n * @property {number} timestamp - Unix timestamp (ms).\n * @property {Object} payload - Message payload.\n * @property {Object} meta - Additional metadata.\n */\nexport function createMessage(type, payload, meta = {}, id = null) {\n  return Object.freeze({\n    [PROTOCOL_PREFIX]: PROTOCOL_VERSION,\n    version: PROTOCOL_VERSION,\n    id: id || crypto.randomUUID(),\n    type,\n    timestamp: Date.now(),\n    payload: Object.freeze({ ...payload }),\n    meta: Object.freeze({ ...meta })\n  });\n}\n\n/**\n * Creates a signal message.\n * \n * @param {string} name - Signal name.\n * @param {*} data - Signal data.\n * @param {string} sourcePeerId - Source peer ID.\n * @param {string|null} [destPeerId] - Destination peer ID.\n * @returns {ProtocolMessage} Signal message.\n */\nexport function createSignalMessage(name, data, sourcePeerId, destPeerId = null) {\n  return createMessage(MessageType.SIGNAL, {\n    name,\n    data,\n    source: sourcePeerId,\n    dest: destPeerId\n  });\n}\n\n/**\n * Creates a broadcast message.\n * \n * @param {string} name - Signal name.\n * @param {*} data - Signal data.\n * @param {string} sourcePeerId - Source peer ID.\n * @param {Object} [options={}] - Broadcast options.\n * @returns {ProtocolMessage} Broadcast message.\n */\nexport function createBroadcastMessage(name, data, sourcePeerId, options = {}) {\n  return createMessage(MessageType.BROADCAST, {\n    name,\n    data,\n    source: sourcePeerId,\n    options\n  });\n}\n\n/**\n * Creates a handshake init message.\n * \n * @param {string} peerId - Initiating peer ID.\n * @param {string} origin - Initiating peer origin.\n * @param {string} challenge - Random challenge string.\n * @returns {ProtocolMessage} Handshake init message.\n */\nexport function createHandshakeInit(peerId, origin, challenge) {\n  return createMessage(MessageType.HANDSHAKE_INIT, {\n    peerId,\n    origin,\n    challenge\n  });\n}\n\n/**\n * Creates a handshake acknowledgment message.\n * \n * @param {string} peerId - Responding peer ID.\n * @param {string} origin - Responding peer origin.\n * @param {string} challenge - Original challenge.\n * @param {string} response - Challenge response.\n * @returns {ProtocolMessage} Handshake ack message.\n */\nexport function createHandshakeAck(peerId, origin, challenge, response) {\n  return createMessage(MessageType.HANDSHAKE_ACK, {\n    peerId,\n    origin,\n    challenge,\n    response\n  });\n}\n\n/**\n * Creates a handshake complete message.\n * \n * @param {string} peerId - Confirming peer ID.\n * @param {boolean} success - Whether handshake succeeded.\n * @returns {ProtocolMessage} Handshake complete message.\n */\nexport function createHandshakeComplete(peerId, success) {\n  return createMessage(MessageType.HANDSHAKE_COMPLETE, {\n    peerId,\n    success\n  });\n}\n\n/**\n * Creates a request message (expecting response).\n * \n * @param {string} name - Request name.\n * @param {*} data - Request data.\n * @param {string} sourcePeerId - Source peer ID.\n * @param {string} destPeerId - Destination peer ID.\n * @param {string|null} [id=null] - Optional custom request ID.\n * @returns {ProtocolMessage} Request message.\n */\nexport function createRequestMessage(name, data, sourcePeerId, destPeerId, id = null) {\n  return createMessage(MessageType.REQUEST, {\n    name,\n    data,\n    source: sourcePeerId,\n    dest: destPeerId\n  }, {}, id);\n}\n\n/**\n * Creates a response message.\n * \n * @param {string} requestId - Original request message ID.\n * @param {*} data - Response data.\n * @param {string} sourcePeerId - Source peer ID.\n * @param {boolean} [success=true] - Whether request succeeded.\n * @param {Object|null} [error] - Error object if failed.\n * @returns {ProtocolMessage} Response message.\n */\nexport function createResponseMessage(requestId, data, sourcePeerId, success = true, error = null) {\n  return createMessage(MessageType.RESPONSE, {\n    requestId,\n    data,\n    source: sourcePeerId,\n    success,\n    error\n  });\n}\n\n/**\n * Validates if an object is a valid CrossBus protocol message.\n * \n * @param {*} obj - Object to validate.\n * @returns {boolean} True if valid protocol message.\n */\nexport function isProtocolMessage(obj) {\n  return (\n    obj !== null &&\n    typeof obj === 'object' &&\n    obj[PROTOCOL_PREFIX] === PROTOCOL_VERSION &&\n    typeof obj.version === 'number' &&\n    typeof obj.id === 'string' &&\n    (typeof obj.type === 'string' || typeof obj.t === 'string') &&\n    typeof obj.timestamp === 'number' &&\n    obj.payload !== undefined\n  );\n}\n\n/**\n * Validates protocol version compatibility.\n * \n * @param {ProtocolMessage} message - Message to check.\n * @returns {boolean} True if version is compatible.\n */\nexport function isCompatibleVersion(message) {\n  return message.version === PROTOCOL_VERSION;\n}\n","/**\n * @fileoverview Common types and constants shared across all modules.\n * This module is included in the common bundle to avoid duplication.\n * @module common/types\n */\n\n/**\n * Protocol marker for CrossBus messages.\n * @constant {string}\n */\nexport const PROTOCOL_MARKER = '_cb';\n\n/**\n * Current protocol version.\n * @constant {number}\n */\nexport const PROTOCOL_VERSION = 1;\n\n/**\n * Message type codes (compact for wire efficiency).\n * @readonly\n * @enum {string}\n */\nexport const MessageType = Object.freeze({\n    /** Signal - one-way message */\n    SIGNAL: 'sig',\n    /** Request - expects response */\n    REQUEST: 'req',\n    /** Response - reply to request */\n    RESPONSE: 'res',\n    /** Acknowledge - delivery confirmation */\n    ACK: 'ack',\n    /** Handshake - connection negotiation */\n    HANDSHAKE: 'hsk',\n    HANDSHAKE_INIT: 'hsk_init',\n    HANDSHAKE_ACK: 'hsk_ack',\n    HANDSHAKE_COMPLETE: 'hsk_done',\n    /** Ping - heartbeat */\n    PING: 'png',\n    /** Pong - heartbeat response */\n    PONG: 'pog',\n    /** Goodbye - graceful disconnect */\n    BYE: 'bye',\n    /** Broadcast - message for all peers */\n    BROADCAST: 'bc'\n});\n\n/**\n * Handshake phase codes.\n * @readonly\n * @enum {string}\n */\nexport const HandshakePhase = Object.freeze({\n    INIT: 'init',\n    INIT_SENT: 'init_sent',\n    ACK: 'ack',\n    ACK_SENT: 'ack_sent',\n    DONE: 'done'\n});\n\n/**\n * Peer connection status.\n * @readonly\n * @enum {string}\n */\nexport const PeerStatus = Object.freeze({\n    CONNECTING: 'connecting',\n    CONNECTED: 'connected',\n    DISCONNECTED: 'disconnected',\n    RECONNECTING: 'reconnecting',\n    FAILED: 'failed'\n});\n\n/**\n * Peer type (transport mechanism).\n * @readonly\n * @enum {string}\n */\nexport const PeerType = Object.freeze({\n    IFRAME: 'iframe',\n    WORKER: 'worker',\n    SERVICE_WORKER: 'sw',\n    WINDOW: 'window',\n    PORT: 'port'\n});\n\n/**\n * Delivery status for emit results.\n * @readonly\n * @enum {string}\n */\nexport const DeliveryStatus = Object.freeze({\n    /** Delivered to local listeners only */\n    LOCAL: 'local',\n    /** Sent to peer (no ACK requested) */\n    SENT: 'sent',\n    /** Sent and ACK received */\n    ACKED: 'acked',\n    /** Queued for offline peer */\n    QUEUED: 'queued',\n    /** ACK timeout */\n    TIMEOUT: 'timeout',\n    /** Delivery failed */\n    FAILED: 'failed'\n});\n\n/**\n * Default configuration values.\n * @readonly\n * @type {Object}\n */\nexport const Defaults = Object.freeze({\n    ACK_TIMEOUT: 5000,\n    REQUEST_TIMEOUT: 30000,\n    HANDSHAKE_TIMEOUT: 10000,\n    HEARTBEAT_INTERVAL: 15000,\n    HEARTBEAT_TIMEOUT: 5000,\n    RECONNECT_INTERVAL: 3000,\n    MAX_RECONNECT_ATTEMPTS: 5,\n    MAX_PEERS: 100,\n    MAX_PENDING_REQUESTS: 1000,\n    MAX_QUEUE_SIZE: 100,\n    MAX_MESSAGE_SIZE: 1048576, // 1MB\n    TTL: 5\n});\n\n/**\n * Checks if an object is a valid CrossBus message.\n * \n * @param {*} obj - Object to check.\n * @returns {boolean} True if valid protocol message.\n */\nexport function isProtocolMessage(obj) {\n    return (\n        obj !== null &&\n        typeof obj === 'object' &&\n        obj[PROTOCOL_MARKER] === PROTOCOL_VERSION &&\n        typeof obj.id === 'string' &&\n        (typeof obj.type === 'string' || typeof obj.t === 'string')\n    );\n}\n\n/**\n * List of transferable types for auto-detection.\n * @constant {Function[]}\n */\nexport const TransferableTypes = [\n    ArrayBuffer,\n    MessagePort,\n    // ImageBitmap and OffscreenCanvas are checked dynamically\n    // as they may not exist in all contexts\n];\n\n/**\n * Checks if a value is transferable.\n * \n * @param {*} value - Value to check.\n * @returns {boolean} True if transferable.\n */\nexport function isTransferable(value) {\n    if (value instanceof ArrayBuffer) return true;\n    if (value instanceof MessagePort) return true;\n    if (typeof ImageBitmap !== 'undefined' && value instanceof ImageBitmap) return true;\n    if (typeof OffscreenCanvas !== 'undefined' && value instanceof OffscreenCanvas) return true;\n    if (typeof ReadableStream !== 'undefined' && value instanceof ReadableStream) return true;\n    if (typeof WritableStream !== 'undefined' && value instanceof WritableStream) return true;\n    if (typeof TransformStream !== 'undefined' && value instanceof TransformStream) return true;\n    return false;\n}\n\n/**\n * Recursively finds all transferable objects in a value.\n * \n * @param {*} value - Value to search.\n * @param {Set<Transferable>} [found] - Set to collect transferables.\n * @returns {Transferable[]} Array of transferables found.\n */\nexport function findTransferables(value, found = new Set()) {\n    if (value === null || value === undefined) return Array.from(found);\n\n    if (isTransferable(value)) {\n        found.add(value);\n        return Array.from(found);\n    }\n\n    if (Array.isArray(value)) {\n        for (const item of value) {\n            findTransferables(item, found);\n        }\n    } else if (typeof value === 'object') {\n        for (const key of Object.keys(value)) {\n            findTransferables(value[key], found);\n        }\n    }\n\n    return Array.from(found);\n}\n","/**\n * @fileoverview Utility functions shared across modules.\n * @module common/utils\n */\n\n/**\n * Generates a UUID v4.\n * Uses crypto.randomUUID() when available, falls back to manual generation.\n * \n * @returns {string} UUID v4 string.\n */\nexport function uuid() {\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback for older browsers\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n\n/**\n * Checks if data can be structured cloned.\n * \n * @param {*} data - Data to check.\n * @returns {boolean} True if cloneable.\n */\nexport function isCloneable(data) {\n    if (data === null || data === undefined) return true;\n\n    const type = typeof data;\n\n    // Primitives are always cloneable\n    if (type === 'boolean' || type === 'number' || type === 'string') {\n        return true;\n    }\n\n    // Functions and symbols are not cloneable\n    if (type === 'function' || type === 'symbol') {\n        return false;\n    }\n\n    // Check for DOM nodes\n    if (typeof Node !== 'undefined' && data instanceof Node) {\n        return false;\n    }\n\n    // Check for WeakMap/WeakSet\n    if (data instanceof WeakMap || data instanceof WeakSet) {\n        return false;\n    }\n\n    // For objects/arrays, we'd need to recursively check\n    // For performance, we assume they're cloneable and let postMessage fail\n    return true;\n}\n\n/**\n * Creates a deferred promise (Promise.withResolvers polyfill).\n * Uses native Promise.withResolvers() when available (ES2024+).\n * \n * @template T\n * @returns {{promise: Promise<T>, resolve: (value: T) => void, reject: (reason: any) => void}}\n */\nexport function deferred() {\n    // Use native Promise.withResolvers if available (ES2024+, ~10x faster)\n    // @ts-ignore\n    if (typeof Promise.withResolvers === 'function') {\n        // @ts-ignore\n        return Promise.withResolvers();\n    }\n    // Fallback for older engines\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    // @ts-ignore\n    return { promise, resolve, reject };\n}\n\n/**\n * Creates a promise that resolves after a timeout.\n * \n * @param {number} ms - Timeout in milliseconds.\n * @param {AbortSignal} [signal] - Optional abort signal.\n * @returns {Promise<void>}\n */\nexport function sleep(ms, signal) {\n    return new Promise((resolve, reject) => {\n        if (signal?.aborted) {\n            reject(signal.reason ?? new Error('Aborted'));\n            return;\n        }\n\n        const timeoutId = setTimeout(resolve, ms);\n\n        if (signal) {\n            signal.addEventListener('abort', () => {\n                clearTimeout(timeoutId);\n                reject(signal.reason ?? new Error('Aborted'));\n            }, { once: true });\n        }\n    });\n}\n\n/**\n * Creates a promise that rejects after a timeout.\n * \n * @template T\n * @param {Promise<T>} promise - Promise to race against.\n * @param {number} ms - Timeout in milliseconds.\n * @param {string} [message='Operation timed out'] - Timeout error message.\n * @returns {Promise<T>}\n */\nexport function withTimeout(promise, ms, message = 'Operation timed out') {\n    return Promise.race([\n        promise,\n        new Promise((_, reject) => {\n            setTimeout(() => reject(new Error(message)), ms);\n        })\n    ]);\n}\n\n\n\n/**\n * Detects the type of a peer target.\n * \n * @param {*} target - Target to check.\n * @returns {'iframe'|'worker'|'sw'|'window'|'port'|'unknown'}\n */\nexport function detectPeerType(target) {\n    // MessagePort\n    if (target instanceof MessagePort) {\n        return 'port';\n    }\n\n    // Worker\n    if (typeof Worker !== 'undefined' && target instanceof Worker) {\n        return 'worker';\n    }\n\n    // ServiceWorker\n    if (typeof ServiceWorker !== 'undefined' && target instanceof ServiceWorker) {\n        return 'sw';\n    }\n\n    // Window (iframe or popup)\n    if (typeof Window !== 'undefined' && target instanceof Window) {\n        return 'window';\n    }\n\n    // HTMLIFrameElement\n    if (typeof HTMLIFrameElement !== 'undefined' && target instanceof HTMLIFrameElement) {\n        return 'iframe';\n    }\n\n    // DedicatedWorkerGlobalScope (inside worker)\n    if (typeof DedicatedWorkerGlobalScope !== 'undefined' &&\n        target instanceof DedicatedWorkerGlobalScope) {\n        return 'worker';\n    }\n\n    return 'unknown';\n}\n\n\n\n/**\n * Creates a frozen timestamp object.\n * \n * @returns {{timestamp: number, iso: string}}\n */\nexport function timestamp() {\n    const ts = Date.now();\n    return Object.freeze({\n        timestamp: ts,\n        iso: new Date(ts).toISOString()\n    });\n}\n\n\n","/**\n * @fileoverview Local event emitter with wildcard support and AbortSignal integration.\n * Uses Symbol-based private storage for encapsulation.\n * @module core/event-emitter\n */\n\n/** @type {symbol} Private storage key for listeners map */\nconst LISTENERS = Symbol('listeners');\n\n/** @type {symbol} Private storage key for subscription counter */\nconst SUB_COUNTER = Symbol('subCounter');\n\n/** @type {symbol} Private storage key for max listeners setting */\nconst MAX_LISTENERS = Symbol('maxListeners');\n\n/** @type {symbol} Private storage key for fast callback cache (Object-based) */\nconst FAST_CACHE = Symbol('fastCache');\n\n/** @type {number} Default max listeners before warning */\nconst DEFAULT_MAX_LISTENERS = 10;\n\n/** @type {Object} Default source for local emissions */\nconst DEFAULT_SOURCE = Object.freeze({\n    peerId: 'self',\n    origin: typeof globalThis.location !== 'undefined' ? globalThis.location.origin : 'unknown',\n    type: 'local'\n});\n\n/**\n * @typedef {Object} ListenerOptions\n * @property {boolean} [once=false] - Auto-remove after first invocation.\n * @property {AbortSignal} [signal] - AbortController signal for cleanup.\n * @property {'sync'|'async'} [mode='async'] - Execution mode.\n * @property {number} [priority=0] - Execution order (higher = first).\n */\n\n/**\n * @typedef {Object} Subscription\n * @property {string} id - Unique subscription ID.\n * @property {string} signalName - The signal name subscribed to.\n * @property {Function} unsubscribe - Call to remove this listener.\n * @property {boolean} active - Whether subscription is active.\n */\n\n/**\n * @typedef {Object} SignalEvent\n * @property {string} name - Signal name that was emitted.\n * @property {*} data - The payload data.\n * @property {string} messageId - Unique message ID.\n * @property {number} timestamp - When the signal was emitted.\n * @property {SignalSource} source - Origin of the signal.\n */\n\n/**\n * @typedef {Object} SignalSource\n * @property {string} peerId - ID of the emitting peer ('self' if local).\n * @property {string} origin - Origin URL.\n * @property {'local'|'iframe'|'worker'|'service-worker'|'window'} type - Source type.\n */\n\n/**\n * @callback SignalHandler\n * @param {SignalEvent} event - The signal event object.\n * @returns {void|Promise<void>}\n */\n\n/**\n * @typedef {Object} ListenerEntry\n * @property {string} id - Subscription ID.\n * @property {SignalHandler} handler - The callback function.\n * @property {number} priority - Execution priority.\n * @property {'sync'|'async'} mode - Execution mode.\n * @property {boolean} once - Auto-remove after first invocation.\n * @property {AbortSignal|null} signal - Abort signal.\n */\n\n/**\n * @typedef {Object} RemoveResult\n * @property {boolean} success - True if at least one listener was removed.\n * @property {number} removedCount - Number of listeners removed.\n * @property {number} remainingCount - Listeners still registered for this signal.\n */\n\n/**\n * Local event emitter with wildcard support.\n * \n * Supports:\n * - Exact match: `on('user:login', handler)`\n * - Namespace wildcard: `on('user:*', handler)` matches `user:login`, `user:logout`\n * - Global wildcard: `on('*', handler)` matches all signals\n * \n * @example\n * const emitter = new EventEmitter();\n * \n * // Basic listener\n * emitter.on('message', (event) => console.log(event.data));\n * \n * // Wildcard listener\n * emitter.on('user:*', (event) => console.log('User event:', event.name));\n * \n * // Emit signal\n * emitter.emit('message', { text: 'Hello' });\n */\nexport class EventEmitter {\n    constructor() {\n        /** @type {Map<string, ListenerEntry[]>} */\n        this[LISTENERS] = new Map();\n\n        /** @type {number} */\n        this[SUB_COUNTER] = 0;\n\n        /** @type {number} Max listeners before memory leak warning */\n        this[MAX_LISTENERS] = DEFAULT_MAX_LISTENERS;\n\n        /** @type {Object<string, Function[]>} Fast Object-based cache for callbacks only */\n        this[FAST_CACHE] = Object.create(null);\n    }\n\n    /**\n     * Sets the max listeners threshold for memory leak warnings.\n     * @param {number} n - Max listeners (0 = unlimited)\n     */\n    setMaxListeners(n) {\n        this[MAX_LISTENERS] = n;\n        return this;\n    }\n\n    /**\n     * Gets the current max listeners setting.\n     * @returns {number}\n     */\n    getMaxListeners() {\n        return this[MAX_LISTENERS];\n    }\n\n    /**\n     * Registers a listener for a signal.\n     * \n     * @param {string} name - Signal name. Supports wildcards: '*', 'namespace:*'.\n     * @param {SignalHandler} handler - Callback function.\n     * @param {ListenerOptions} [options={}] - Configuration options.\n     * @returns {Subscription} Subscription object.\n     * @throws {TypeError} If name is not a string or handler is not a function.\n     * \n     * @example\n     * // Basic listener\n     * const sub = emitter.on('user:login', (event) => {\n     *   console.log(`User ${event.data.userId} logged in`);\n     * });\n     * \n     * @example\n     * // One-time listener\n     * emitter.on('init:complete', handler, { once: true });\n     * \n     * @example\n     * // With AbortController\n     * const controller = new AbortController();\n     * emitter.on('data:update', handler, { signal: controller.signal });\n     * controller.abort(); // Removes listener\n     * \n     * @example\n     * // Priority-based ordering\n     * emitter.on('event', lowPriorityHandler, { priority: 1 });\n     * emitter.on('event', highPriorityHandler, { priority: 10 }); // Runs first\n     */\n    on(name, handler, options = {}) {\n        if (typeof name !== 'string') {\n            throw new TypeError('Signal name must be a string');\n        }\n        if (typeof handler !== 'function') {\n            throw new TypeError('Handler must be a function');\n        }\n\n        const id = `sub_${++this[SUB_COUNTER]}`;\n\n        // V8 Optimization: Consistent object shape for hidden class caching\n        // All entries have same properties in same order\n        /** @type {ListenerEntry} */\n        const entry = {\n            id,\n            handler,\n            priority: options.priority ?? 0,\n            mode: options.mode ?? 'async',\n            once: options.once ?? false,\n            signal: options.signal ?? null\n        };\n\n        // Get or create listeners array for this signal\n        if (!this[LISTENERS].has(name)) {\n            this[LISTENERS].set(name, []);\n        }\n\n        const listeners = this[LISTENERS].get(name);\n\n        // Binary insert for O(log n) search instead of O(n log n) sort\n        if (listeners.length === 0 || entry.priority <= listeners[listeners.length - 1].priority) {\n            // Fast path: append (most common case with priority 0)\n            listeners.push(entry);\n        } else {\n            // Binary search for insert position (higher priority first)\n            let lo = 0, hi = listeners.length;\n            while (lo < hi) {\n                const mid = (lo + hi) >>> 1;\n                if (listeners[mid].priority >= entry.priority) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid;\n                }\n            }\n            listeners.splice(lo, 0, entry);\n        }\n\n        // Sync FAST_CACHE for ultra-fast emitSync\n        this[FAST_CACHE][name] = listeners.map(e => e.handler);\n\n        // Memory leak detection: warn if too many listeners\n        const maxListeners = this[MAX_LISTENERS];\n        if (maxListeners > 0 && listeners.length > maxListeners) {\n            console.warn(\n                `[CrossBus] Possible memory leak: ${listeners.length} listeners for \"${name}\". ` +\n                `Use setMaxListeners(n) to increase limit.`\n            );\n        }\n\n        // Create subscription object\n        let active = true;\n        const subscription = {\n            id,\n            signalName: name,\n            get active() { return active; },\n            unsubscribe: () => {\n                if (active) {\n                    this.#removeListener(name, id);\n                    active = false;\n                }\n            }\n        };\n\n        // Handle AbortSignal\n        if (entry.signal) {\n            if (entry.signal.aborted) {\n                // Already aborted, remove immediately\n                this.#removeListener(name, id);\n                active = false;\n            } else {\n                entry.signal.addEventListener('abort', () => {\n                    subscription.unsubscribe();\n                }, { once: true });\n            }\n        }\n\n        return subscription;\n    }\n\n    /**\n     * Registers a one-time listener.\n     * Convenience method for `on(name, handler, { once: true })`.\n     * \n     * @param {string} name - Signal name.\n     * @param {SignalHandler} handler - Callback function.\n     * @param {ListenerOptions} [options={}] - Additional options.\n     * @returns {Subscription} Subscription object.\n     */\n    once(name, handler, options = {}) {\n        return this.on(name, handler, { ...options, once: true });\n    }\n\n    /**\n     * Ultra-fast listener registration for performance-critical paths.\n     * \n     * Unlike on(), this method:\n     * - No input validation (caller must ensure correct types)\n     * - No subscription object (returns unbind function directly)\n     * - No priority, once, or AbortSignal support\n     * - Direct push to FAST_CACHE (minimal overhead)\n     * \n     * Use when you need maximum subscribe performance.\n     * \n     * @param {string} name - Signal name.\n     * @param {EventListener} handler - Callback function.\n     * @returns {Function} Unbind function (call to remove listener).\n     * \n     * @example\n     * // 50M+ ops/sec subscribe/unsubscribe\n     * const off = emitter.onFast('tick', (data) => console.log(data));\n     * off(); // Remove listener\n     */\n    onFast(name, handler) {\n        // Match nanoevents exactly: ||= pattern, minimal code\n        (this[FAST_CACHE][name] ||= []).push(handler);\n        return () => {\n            this[FAST_CACHE][name] = this[FAST_CACHE][name]?.filter(h => h !== handler);\n        };\n    }\n\n    /**\n     * Ultra-fast listener removal for performance-critical paths.\n     * \n     * @param {string} name - Signal name.\n     * @param {EventListener} handler - Handler to remove.\n     */\n    offFast(name, handler) {\n        const cache = this[FAST_CACHE][name];\n        if (cache) {\n            const idx = cache.indexOf(handler);\n            if (idx !== -1) cache.splice(idx, 1);\n        }\n        // Also clean LISTENERS\n        const listeners = this[LISTENERS].get(name);\n        if (listeners) {\n            const idx = listeners.findIndex(e => e.handler === handler);\n            if (idx !== -1) listeners.splice(idx, 1);\n        }\n    }\n\n    /**\n     * Removes signal listener(s).\n     * \n     * @param {string} name - Signal name.\n     * @param {SignalHandler} [handler] - Specific handler to remove.\n     *                                    If omitted, removes ALL listeners.\n     * @returns {RemoveResult} Result of the removal.\n     * @throws {TypeError} If name is not a string.\n     * \n     * @example\n     * // Remove specific handler\n     * const result = emitter.off('msg', myHandler);\n     * // => { success: true, removedCount: 1, remainingCount: 0 }\n     * \n     * @example\n     * // Remove ALL listeners for a signal\n     * emitter.off('updates');\n     * // => { success: true, removedCount: 2, remainingCount: 0 }\n     */\n    off(name, handler) {\n        if (typeof name !== 'string') {\n            throw new TypeError('Signal name must be a string');\n        }\n\n        const listeners = this[LISTENERS].get(name);\n\n        if (!listeners || listeners.length === 0) {\n            return { success: false, removedCount: 0, remainingCount: 0 };\n        }\n\n        let removedCount = 0;\n\n        if (handler === undefined) {\n            // Remove all listeners for this signal\n            removedCount = listeners.length;\n            this[LISTENERS].delete(name);\n            delete this[FAST_CACHE][name];\n        } else {\n            // Remove specific handler\n            const initialLength = listeners.length;\n            const filtered = listeners.filter(entry => entry.handler !== handler);\n            removedCount = initialLength - filtered.length;\n\n            if (filtered.length === 0) {\n                this[LISTENERS].delete(name);\n                delete this[FAST_CACHE][name];\n            } else {\n                this[LISTENERS].set(name, filtered);\n                this[FAST_CACHE][name] = filtered.map(e => e.handler);\n            }\n        }\n\n        const remaining = this[LISTENERS].get(name)?.length ?? 0;\n\n        return {\n            success: removedCount > 0,\n            removedCount,\n            remainingCount: remaining\n        };\n    }\n\n    /**\n     * Ultra-fast synchronous emit for performance-critical paths.\n     * \n     * Unlike emit(), this method:\n     * - Is synchronous (no async/await overhead)\n     * - Passes data directly (no event envelope)\n     * - Skips messageId, timestamp generation\n     * - No wildcard matching (exact match only)\n     * \n     * Use for high-frequency events where metadata is not needed.\n     * \n     * @param {string} name - Signal name (exact match only).\n     * @param {*} data - Payload to pass directly to handlers.\n     * @returns {number} Number of listeners invoked.\n     * \n     * @example\n     * // 150M+ ops/sec - use for hot paths\n     * emitter.emitSync('tick', { x: 100, y: 200 });\n     */\n    emitSync(name, data) {\n        // Ultra-fast path: use Object-based cache (faster than Map.get)\n        const callbacks = this[FAST_CACHE][name];\n        if (!callbacks) return 0;\n\n        // Direct callback invocation (no .handler indirection)\n        const len = callbacks.length;\n        if (len === 1) {\n            callbacks[0](data);\n            return 1;\n        }\n        if (len === 2) {\n            callbacks[0](data);\n            callbacks[1](data);\n            return 2;\n        }\n        if (len === 3) {\n            callbacks[0](data);\n            callbacks[1](data);\n            callbacks[2](data);\n            return 3;\n        }\n        if (len === 4) {\n            callbacks[0](data);\n            callbacks[1](data);\n            callbacks[2](data);\n            callbacks[3](data);\n            return 4;\n        }\n\n        // General loop for 5+ listeners\n        for (let i = 0; i < len; i++) {\n            callbacks[i](data);\n        }\n        return len;\n    }\n\n    /**\n     * Emits a signal to local listeners.\n     * \n     * @param {string} name - Signal name.\n     * @param {*} data - Payload data.\n     * @param {Partial<SignalSource>} [source] - Signal source info.\n     * @returns {Promise<number>} Number of listeners invoked.\n     * @throws {TypeError} If name is not a string.\n     * \n     * @example\n     * const count = await emitter.emit('user:login', { userId: 123 });\n     * console.log(`Notified ${count} listeners`);\n     */\n    async emit(name, data, source) {\n        if (typeof name !== 'string') {\n            throw new TypeError('Signal name must be a string');\n        }\n\n        // Fast path: single exact-match listener, no wildcards\n        const exactListeners = this[LISTENERS].get(name);\n        const hasWildcard = this[LISTENERS].has('*');\n\n        if (exactListeners?.length === 1 && !hasWildcard && !source) {\n            const entry = exactListeners[0];\n            const event = {\n                name,\n                data,\n                messageId: crypto.randomUUID(),\n                timestamp: Date.now(),\n                source: DEFAULT_SOURCE\n            };\n\n            try {\n                if (entry.mode === 'sync') {\n                    await entry.handler(event);\n                } else {\n                    Promise.resolve().then(() => entry.handler(event));\n                }\n            } catch (error) {\n                console.error(`[CrossBus] Handler error for \"${name}\":`, error);\n            }\n\n            if (entry.once) {\n                this.#removeListener(name, entry.id);\n            }\n\n            return 1;\n        }\n\n        // Full path: multiple listeners or wildcards\n        const event = {\n            name,\n            data,\n            messageId: crypto.randomUUID(),\n            timestamp: Date.now(),\n            source: source ? { ...DEFAULT_SOURCE, ...source } : DEFAULT_SOURCE\n        };\n\n        // Collect matching listeners\n        const matchingEntries = this.#getMatchingListeners(name);\n\n        // Track entries to remove (once: true)\n        const toRemove = [];\n\n        // Invoke handlers\n        for (const { signalName, entry } of matchingEntries) {\n            try {\n                if (entry.mode === 'sync') {\n                    await entry.handler(event);\n                } else {\n                    // Fire async without blocking\n                    Promise.resolve().then(() => entry.handler(event));\n                }\n            } catch (error) {\n                // Log but don't throw - other listeners should still run\n                console.error(`[CrossBus] Handler error for \"${name}\":`, error);\n            }\n\n            if (entry.once) {\n                toRemove.push({ signalName, id: entry.id });\n            }\n        }\n\n        // Remove once listeners\n        for (const { signalName, id } of toRemove) {\n            this.#removeListener(signalName, id);\n        }\n\n        return matchingEntries.length;\n    }\n\n    /**\n     * Checks if there are any listeners for a signal.\n     * \n     * @param {string} name - Signal name (exact match only).\n     * @returns {boolean} True if listeners exist.\n     */\n    hasListeners(name) {\n        const listeners = this[LISTENERS].get(name);\n        return listeners !== undefined && listeners.length > 0;\n    }\n\n    /**\n     * Gets the count of listeners for a signal.\n     * \n     * @param {string} name - Signal name (exact match only).\n     * @returns {number} Number of listeners.\n     */\n    listenerCount(name) {\n        return this[LISTENERS].get(name)?.length ?? 0;\n    }\n\n    /**\n     * Gets all registered signal names.\n     * \n     * @returns {string[]} Array of signal names.\n     */\n    getSignalNames() {\n        return Array.from(this[LISTENERS].keys());\n    }\n\n    /**\n     * Removes all listeners.\n     */\n    clear() {\n        this[LISTENERS].clear();\n        // Reset FAST_CACHE to empty object\n        for (const key in this[FAST_CACHE]) {\n            delete this[FAST_CACHE][key];\n        }\n    }\n\n    /**\n     * Gets all listeners matching a signal name (including wildcards).\n     * \n     * \n     * @param {string} name - Signal name to match.\n     * @returns {Array<{signalName: string, entry: ListenerEntry}>} Matching entries.\n     */\n    #getMatchingListeners(name) {\n        // Fast path: check exact match first and if no wildcards registered\n        const exactListeners = this[LISTENERS].get(name);\n        const globalWildcard = this[LISTENERS].get('*');\n\n        // Find namespace wildcards (e.g., 'user:*' for 'user:login')\n        let namespaceWildcard = null;\n        const colonIdx = name.indexOf(':');\n        if (colonIdx > 0) {\n            const wildcardPattern = name.slice(0, colonIdx + 1) + '*';\n            namespaceWildcard = this[LISTENERS].get(wildcardPattern);\n        }\n\n        // Super-fast path: only exact match, no wildcards\n        if (exactListeners && !globalWildcard && !namespaceWildcard) {\n            return exactListeners.map(entry => ({ signalName: name, entry }));\n        }\n\n        // Fast path: single source, already sorted\n        const sources = [\n            exactListeners && { signalName: name, entries: exactListeners },\n            globalWildcard && { signalName: '*', entries: globalWildcard },\n            namespaceWildcard && { signalName: name.slice(0, colonIdx + 1) + '*', entries: namespaceWildcard }\n        ].filter(Boolean);\n\n        if (sources.length === 0) {\n            return [];\n        }\n\n        if (sources.length === 1) {\n            // Single source: already sorted, no merge needed\n            return sources[0].entries.map(entry => ({ signalName: sources[0].signalName, entry }));\n        }\n\n        // Multiple sources: collect and merge-sort by priority\n        const results = [];\n        for (const { signalName, entries } of sources) {\n            for (const entry of entries) {\n                results.push({ signalName, entry });\n            }\n        }\n\n        // Only sort when merging multiple sources\n        results.sort((a, b) => b.entry.priority - a.entry.priority);\n\n        return results;\n    }\n\n\n\n    /**\n     * Removes a listener by ID.\n     * \n     * \n     * @param {string} name - Signal name.\n     * @param {string} id - Subscription ID.\n     */\n    #removeListener(name, id) {\n        const listeners = this[LISTENERS].get(name);\n        if (!listeners) return;\n\n        const filtered = listeners.filter(entry => entry.id !== id);\n\n        if (filtered.length === 0) {\n            this[LISTENERS].delete(name);\n            delete this[FAST_CACHE][name];\n        } else {\n            this[LISTENERS].set(name, filtered);\n            this[FAST_CACHE][name] = filtered.map(e => e.handler);\n        }\n    }\n}\n\n/**\n * Creates an ultra-fast plain object emitter that beats nanoevents.\n * \n * Unlike EventEmitter class, this is a minimal plain object with:\n * - No class overhead\n * - No Symbol lookups\n * - No validation\n * - Direct property access\n * \n * Benchmarks:\n * - on/off cycle: 45M ops/sec (vs nanoevents 38M) = 1.18x faster\n * - emit (10 listeners): 82M ops/sec (vs nanoevents 65M) = 1.26x faster\n * \n * @returns {Object} Fast emitter with on(), emit() methods\n * \n * @example\n * const emitter = createFastEmitter();\n * const off = emitter.on('event', (data) => console.log(data));\n * emitter.emit('event', { value: 42 });\n * off(); // Remove listener\n */\nexport const createFastEmitter = () => ({\n    events: {},\n\n    /**\n     * Subscribe to an event. Returns unbind function.\n     * @param {string} event - Event name\n     * @param {EventListener} cb - Callback function\n     * @returns {Function} Unbind function\n     */\n    on(event, cb) {\n        (this.events[event] ||= []).push(cb);\n        return () => {\n            this.events[event] = this.events[event]?.filter(i => cb !== i);\n        };\n    },\n\n    /**\n     * Emit an event to all listeners.\n     * @param {string} event - Event name\n     * @param {*} data - Data to pass to listeners\n     */\n    emit(event, data) {\n        const c = this.events[event];\n        if (!c) return;\n        const len = c.length;\n        // Unrolled for 1-4 (most common)\n        if (len === 1) { c[0](data); return; }\n        if (len === 2) { c[0](data); c[1](data); return; }\n        if (len === 3) { c[0](data); c[1](data); c[2](data); return; }\n        if (len === 4) { c[0](data); c[1](data); c[2](data); c[3](data); return; }\n        // Loop for 5+\n        for (let i = 0; i < len; i++) c[i](data);\n    },\n\n    /**\n     * Remove all listeners for an event or all events.\n     * @param {string} [event] - Event name (omit to clear all)\n     */\n    off(event) {\n        if (event) {\n            delete this.events[event];\n        } else {\n            this.events = {};\n        }\n    }\n});\n\n","/**\n * @fileoverview Centralized error handling for CrossBus.\n * @module common/errors\n */\n\n/**\n * Error codes for CrossBus.\n * @readonly\n * @enum {string}\n */\nexport const ErrorCode = Object.freeze({\n    // Connection errors\n    HANDSHAKE_TIMEOUT: 'ERR_HANDSHAKE_TIMEOUT',\n    HANDSHAKE_REJECTED: 'ERR_HANDSHAKE_REJECTED',\n    ORIGIN_FORBIDDEN: 'ERR_ORIGIN_FORBIDDEN',\n    PEER_EXISTS: 'ERR_PEER_EXISTS',\n    PEER_NOT_FOUND: 'ERR_PEER_NOT_FOUND',\n    PEER_DISCONNECTED: 'ERR_PEER_DISCONNECTED',\n    RECONNECT_FAILED: 'ERR_RECONNECT_FAILED',\n    UNSUPPORTED: 'ERR_UNSUPPORTED',\n    NOT_CONNECTED: 'ERR_NOT_CONNECTED',\n\n    // Message errors\n    ACK_TIMEOUT: 'ERR_ACK_TIMEOUT',\n    RESPONSE_TIMEOUT: 'ERR_RESPONSE_TIMEOUT',\n    QUEUE_FULL: 'ERR_QUEUE_FULL',\n    INVALID_MESSAGE: 'ERR_INVALID_MESSAGE',\n    VERSION_MISMATCH: 'ERR_VERSION_MISMATCH',\n    CLONE_ERROR: 'ERR_CLONE_ERROR',\n    TRANSFER_ERROR: 'ERR_TRANSFER_ERROR',\n    MESSAGE_TOO_LARGE: 'ERR_MESSAGE_TOO_LARGE',\n\n    // Routing errors\n    UNREACHABLE: 'ERR_UNREACHABLE',\n    TTL_EXCEEDED: 'ERR_TTL_EXCEEDED',\n    NO_ROUTE: 'ERR_NO_ROUTE',\n\n    // Handler errors\n    NO_HANDLER: 'ERR_NO_HANDLER',\n    HANDLER_ERROR: 'ERR_HANDLER_ERROR',\n    HANDLER_TIMEOUT: 'ERR_HANDLER_TIMEOUT',\n    HANDLER_EXISTS: 'ERR_HANDLER_EXISTS',\n    SEND_FAILED: 'ERR_SEND_FAILED',\n\n    // Channel errors\n    CHANNEL_FAILED: 'ERR_CHANNEL_FAILED',\n    CHANNEL_CLOSED: 'ERR_CHANNEL_CLOSED',\n\n    // Resource errors\n    MAX_PEERS: 'ERR_MAX_PEERS',\n    MAX_PENDING: 'ERR_MAX_PENDING',\n    DESTROYED: 'ERR_DESTROYED',\n\n    // Circuit Breaker\n    CIRCUIT_OPEN: 'ERR_CIRCUIT_OPEN',\n\n    // Security errors\n    PAYLOAD_TOO_LARGE: 'ERR_PAYLOAD_TOO_LARGE',\n    RATE_LIMITED: 'ERR_RATE_LIMITED',\n    UNAUTHORIZED: 'ERR_UNAUTHORIZED',\n    INVALID_PAYLOAD: 'ERR_INVALID_PAYLOAD'\n});\n\n/**\n * Error metadata including default messages, retryability, and AI-friendly suggestions.\n * @type {Object<ErrorCode, {message: string, retryable: boolean, suggestion: string}>}\n */\nconst ERROR_META = Object.freeze({\n    [ErrorCode.HANDSHAKE_TIMEOUT]: {\n        message: 'Handshake timed out',\n        retryable: true,\n        suggestion: 'Increase timeout or check if target is loaded. Use iframe.onload before connecting.'\n    },\n    [ErrorCode.HANDSHAKE_REJECTED]: {\n        message: 'Handshake rejected by peer',\n        retryable: false,\n        suggestion: 'Check targetOrigin matches the peer\\'s origin. Verify peer allows your origin.'\n    },\n    [ErrorCode.ORIGIN_FORBIDDEN]: {\n        message: 'Origin not in allowed origins list',\n        retryable: false,\n        suggestion: 'Add your origin to allowedOrigins option or use targetOrigin: \"*\" for development.'\n    },\n    [ErrorCode.PEER_EXISTS]: {\n        message: 'Peer with this ID already exists',\n        retryable: false,\n        suggestion: 'Use unique peerId for each context. Try: peerId: `agent-${Date.now()}`'\n    },\n    [ErrorCode.PEER_NOT_FOUND]: {\n        message: 'Peer not found',\n        retryable: false,\n        suggestion: 'Check if peer is connected using bus.peers. Wait for peer connection before request.'\n    },\n    [ErrorCode.PEER_DISCONNECTED]: {\n        message: 'Peer is disconnected',\n        retryable: true,\n        suggestion: 'Wait for peer to reconnect. Listen for \"peer:join\" event before retry.'\n    },\n    [ErrorCode.RECONNECT_FAILED]: {\n        message: 'Max reconnection attempts reached',\n        retryable: false,\n        suggestion: 'Check network connectivity. Consider increasing maxRetries option.'\n    },\n    [ErrorCode.UNSUPPORTED]: {\n        message: 'Operation not supported by this environment',\n        retryable: false,\n        suggestion: 'This feature requires a browser environment. Check for feature availability first.'\n    },\n    [ErrorCode.NOT_CONNECTED]: {\n        message: 'Transport is not connected',\n        retryable: true,\n        suggestion: 'Call addTransport() and wait for connection before sending messages.'\n    },\n    [ErrorCode.ACK_TIMEOUT]: {\n        message: 'ACK not received within timeout',\n        retryable: true,\n        suggestion: 'Increase ackTimeout option or check peer availability.'\n    },\n    [ErrorCode.RESPONSE_TIMEOUT]: {\n        message: 'Response not received within timeout',\n        retryable: true,\n        suggestion: 'Increase timeout in request options: { timeout: 10000 }. Check if handler exists on peer.'\n    },\n    [ErrorCode.QUEUE_FULL]: {\n        message: 'Message queue is full',\n        retryable: false,\n        suggestion: 'Increase maxQueueSize or wait for queue to drain. Consider using batching plugin.'\n    },\n    [ErrorCode.INVALID_MESSAGE]: {\n        message: 'Invalid message format',\n        retryable: false,\n        suggestion: 'Ensure message data is JSON-serializable. Avoid DOM nodes and functions.'\n    },\n    [ErrorCode.VERSION_MISMATCH]: {\n        message: 'Protocol version mismatch',\n        retryable: false,\n        suggestion: 'Update CrossBus to same version on both sides.'\n    },\n    [ErrorCode.CLONE_ERROR]: {\n        message: 'Data cannot be cloned (contains functions or DOM nodes)',\n        retryable: false,\n        suggestion: 'Remove functions, DOM nodes, and circular references from message data.'\n    },\n    [ErrorCode.TRANSFER_ERROR]: {\n        message: 'Failed to transfer object ownership',\n        retryable: false,\n        suggestion: 'Ensure ArrayBuffers are not detached. Each buffer can only be transferred once.'\n    },\n    [ErrorCode.MESSAGE_TOO_LARGE]: {\n        message: 'Message exceeds maximum size',\n        retryable: false,\n        suggestion: 'Use streaming for large payloads or increase maxMessageSize option.'\n    },\n    [ErrorCode.UNREACHABLE]: {\n        message: 'Destination peer is unreachable',\n        retryable: true,\n        suggestion: 'Check if peer is still connected. Use bus.peers to list available peers.'\n    },\n    [ErrorCode.TTL_EXCEEDED]: {\n        message: 'Message TTL exceeded (possible routing loop)',\n        retryable: false,\n        suggestion: 'Check for circular transport configurations. Increase maxTTL if needed.'\n    },\n    [ErrorCode.NO_ROUTE]: {\n        message: 'No route to destination',\n        retryable: false,\n        suggestion: 'Add transport connecting to target peer. Set isHub: true on orchestrator.'\n    },\n    [ErrorCode.NO_HANDLER]: {\n        message: 'No handler registered for this request',\n        retryable: false,\n        suggestion: 'Register handler on target: bus.handle(\"handlerName\", fn). Check handler name spelling.'\n    },\n    [ErrorCode.HANDLER_ERROR]: {\n        message: 'Handler threw an exception',\n        retryable: false,\n        suggestion: 'Check target peer logs for error. Wrap handler in try/catch.'\n    },\n    [ErrorCode.HANDLER_TIMEOUT]: {\n        message: 'Handler did not respond within timeout',\n        retryable: true,\n        suggestion: 'Handler is slow. Increase timeout or optimize handler performance.'\n    },\n    [ErrorCode.HANDLER_EXISTS]: {\n        message: 'Handler already registered with this name',\n        retryable: false,\n        suggestion: 'Use different handler name or call bus.removeHandler() first.'\n    },\n    [ErrorCode.SEND_FAILED]: {\n        message: 'Failed to send message to peer',\n        retryable: true,\n        suggestion: 'Check transport status. Target window may be closed or blocked.'\n    },\n    [ErrorCode.CHANNEL_FAILED]: {\n        message: 'Failed to create direct channel',\n        retryable: true,\n        suggestion: 'Check browser support for MessageChannel. Retry after short delay.'\n    },\n    [ErrorCode.CHANNEL_CLOSED]: {\n        message: 'Channel was closed unexpectedly',\n        retryable: false,\n        suggestion: 'Target context was destroyed. Check if iframe/worker still exists.'\n    },\n    [ErrorCode.MAX_PEERS]: {\n        message: 'Maximum number of peers reached',\n        retryable: false,\n        suggestion: 'Increase maxPeers option or disconnect unused peers first.'\n    },\n    [ErrorCode.MAX_PENDING]: {\n        message: 'Maximum pending requests reached',\n        retryable: false,\n        suggestion: 'Wait for pending requests to complete. Increase maxPendingRequests option.'\n    },\n    [ErrorCode.DESTROYED]: {\n        message: 'CrossBus instance has been destroyed',\n        retryable: false,\n        suggestion: 'Create new CrossBus instance. Do not use bus after calling destroy().'\n    },\n    [ErrorCode.CIRCUIT_OPEN]: {\n        message: 'Circuit breaker is open',\n        retryable: false,\n        suggestion: 'Too many failures. Wait for circuit to reset or call circuit.reset().'\n    },\n    [ErrorCode.PAYLOAD_TOO_LARGE]: {\n        message: 'Payload exceeds maximum allowed size',\n        retryable: false,\n        suggestion: 'Reduce payload size or increase maxPayloadSize option. Consider using streaming for large data.'\n    },\n    [ErrorCode.RATE_LIMITED]: {\n        message: 'Request rate limit exceeded',\n        retryable: true,\n        suggestion: 'Wait before retrying. Consider adding delay or using exponential backoff.'\n    },\n    [ErrorCode.UNAUTHORIZED]: {\n        message: 'Peer is not authorized to call this handler',\n        retryable: false,\n        suggestion: 'Add peer to handler allowedPeers list or remove peer restrictions.'\n    },\n    [ErrorCode.INVALID_PAYLOAD]: {\n        message: 'Payload validation failed',\n        retryable: false,\n        suggestion: 'Check payload structure against handler requirements.'\n    }\n});\n\n/**\n * Custom error class for CrossBus.\n * \n * @extends Error\n * \n * @example\n * try {\n *   await bus.emit('msg', data, 'unknown-peer');\n * } catch (err) {\n *   if (err instanceof CrossBusError) {\n *     console.log(err.code);      // 'ERR_PEER_NOT_FOUND'\n *     console.log(err.message);   // 'Peer not found'\n *     console.log(err.details);   // { peerId: 'unknown-peer' }\n *     console.log(err.retryable); // false\n *   }\n * }\n */\nexport class CrossBusError extends Error {\n    /**\n     * Error code.\n     * @type {ErrorCode}\n     */\n    code;\n\n    /**\n     * Additional error context.\n     * @type {Object}\n     */\n    details;\n\n    /**\n     * Whether the operation can be retried.\n     * @type {boolean}\n     */\n    retryable;\n\n    /**\n     * Original error that caused this error.\n     * @type {Error|undefined}\n     */\n    cause;\n\n    /**\n     * Timestamp when error occurred.\n     * @type {number}\n     */\n    timestamp;\n\n    /**\n     * Creates a new CrossBusError.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {string} [message] - Custom message (uses default if omitted).\n     * @param {Object} [options] - Additional options.\n     * @param {Object} [options.details={}] - Error context.\n     * @param {boolean} [options.retryable] - Override default retryable.\n     * @param {Error} [options.cause] - Original error.\n     */\n    constructor(code, message, options = {}) {\n        const meta = ERROR_META[code] ?? { message: 'Unknown error', retryable: false };\n        super(message ?? meta.message);\n\n        this.name = 'CrossBusError';\n        this.code = code;\n        this.details = options.details ?? {};\n        this.retryable = options.retryable ?? meta.retryable;\n        this.cause = options.cause;\n        this.timestamp = Date.now();\n\n        // Maintain proper stack trace in V8\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CrossBusError);\n        }\n    }\n\n    /**\n     * Creates error from code with default message.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {Object} [details] - Error context.\n     * @returns {CrossBusError}\n     */\n    static from(code, details = {}) {\n        return new CrossBusError(code, undefined, { details });\n    }\n\n    /**\n     * Creates error from another error.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {Error} cause - Original error.\n     * @param {Object} [details] - Additional context.\n     * @returns {CrossBusError}\n     */\n    static wrap(code, cause, details = {}) {\n        return new CrossBusError(code, cause.message, { cause, details });\n    }\n\n    /**\n     * Converts error to JSON-serializable object.\n     * @returns {Object}\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            code: this.code,\n            message: this.message,\n            details: this.details,\n            retryable: this.retryable,\n            timestamp: this.timestamp\n        };\n    }\n\n    /**\n     * String representation.\n     * @returns {string}\n     */\n    toString() {\n        return `${this.name} [${this.code}]: ${this.message}`;\n    }\n}\n\n/**\n * Checks if an error is a CrossBusError.\n * \n * @param {*} err - Value to check.\n * @returns {boolean}\n */\nexport function isCrossBusError(err) {\n    return err instanceof CrossBusError;\n}\n\n/**\n * Checks if an error is retryable.\n * \n * @param {Error} err - Error to check.\n * @returns {boolean}\n */\nexport function isRetryable(err) {\n    if (err instanceof CrossBusError) {\n        return err.retryable;\n    }\n    return false;\n}\n","/**\n * @fileoverview Message router for hub-based routing.\n * Routes messages between peers through a central hub.\n * @module router/message-router\n */\n\nimport { MessageType, PeerStatus } from '../common/types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { EventEmitter } from '../core/event-emitter.js';\n\n/**\n * @typedef {Object} RoutingEntry\n * @property {string} peerId - Peer identifier.\n * @property {Function} sendFn - Function to send to this peer.\n * @property {Object} meta - Peer metadata.\n * @property {string} origin - Peer origin.\n * @property {PeerStatus} status - Connection status.\n * @property {number} connectedAt - Connection timestamp.\n */\n\n/**\n * @typedef {Object} RouteResult\n * @property {boolean} success - Whether routing succeeded.\n * @property {number} delivered - Number of peers message was delivered to.\n * @property {string[]} failed - Peer IDs that failed delivery.\n */\n\n/**\n * Message router for hub-based communication pattern.\n * \n * In hub mode, all messages flow through a central router which:\n * - Maintains peer registry\n * - Routes unicast messages to specific peers\n * - Broadcasts messages to all/selected peers\n * - Tracks message delivery\n * \n * Performance optimizations:\n * - Object-based cache for fast peer lookup (faster than Map.get)\n * - Direct sendFn cache to avoid property indirection\n * - Unrolled loops for common broadcast patterns\n * \n * @example\n * const router = new MessageRouter();\n * \n * // Register peers\n * router.addPeer('widget-1', (msg) => iframe1.postMessage(msg));\n * router.addPeer('widget-2', (msg) => iframe2.postMessage(msg));\n * \n * // Route unicast\n * router.route({ target: 'widget-1', payload: data });\n * \n * // Route broadcast\n * router.broadcast({ payload: data });\n */\nexport class MessageRouter extends EventEmitter {\n    /** @type {Map<string, RoutingEntry>} Full feature storage */\n    #peers = new Map();\n\n    /** @type {number} */\n    #messageSeq = 0;\n\n    /** @type {Map<string, number>} Per-peer sequence numbers */\n    #peerSeq = new Map();\n\n    /** @type {Object<string, RoutingEntry>} Fast Object-based cache for peer lookup */\n    #peerCache = Object.create(null);\n\n    /** @type {Object<string, Function>} Fast Object-based cache for sendFn direct access */\n    #sendFnCache = Object.create(null);\n\n    /** @type {string[]} Cached peer IDs array for fast iteration */\n    #peerIds = [];\n\n    /**\n     * Creates a new message router.\n     */\n    constructor() {\n        super();\n    }\n\n    /**\n     * Adds a peer to the routing table.\n     * \n     * @param {string} peerId - Unique peer identifier.\n     * @param {EventListener} sendFn - Function to send messages to peer.\n     * @param {Object} [options={}] - Additional options.\n     * @param {Object} [options.meta={}] - Peer metadata.\n     * @param {string} [options.origin='unknown'] - Peer origin.\n     * @throws {CrossBusError} If peer already exists.\n     * \n     * @example\n     * router.addPeer('iframe-widget', (msg) => {\n     *   iframe.contentWindow.postMessage(msg, '*');\n     * }, { meta: { type: 'widget' } });\n     */\n    addPeer(peerId, sendFn, options = {}) {\n        if (this.#peers.has(peerId)) {\n            throw CrossBusError.from(ErrorCode.PEER_EXISTS, { peerId });\n        }\n\n        if (typeof sendFn !== 'function') {\n            throw new TypeError('sendFn must be a function');\n        }\n\n        /** @type {RoutingEntry} */\n        const entry = {\n            peerId,\n            sendFn,\n            meta: options.meta ?? {},\n            origin: options.origin ?? 'unknown',\n            status: PeerStatus.CONNECTED,\n            connectedAt: Date.now()\n        };\n\n        // Full feature storage\n        this.#peers.set(peerId, entry);\n        this.#peerSeq.set(peerId, 0);\n\n        // Sync fast caches for O(1) lookup\n        this.#peerCache[peerId] = entry;\n        this.#sendFnCache[peerId] = sendFn;\n        this.#peerIds.push(peerId);\n\n        // Emit peer added event\n        this.emit('peer:added', { peerId, meta: entry.meta });\n    }\n\n    /**\n     * Removes a peer from the routing table.\n     * \n     * @param {string} peerId - Peer to remove.\n     * @returns {boolean} True if peer was removed.\n     */\n    removePeer(peerId) {\n        const peer = this.#peerCache[peerId];\n        if (!peer) return false;\n\n        // Full storage cleanup\n        this.#peers.delete(peerId);\n        this.#peerSeq.delete(peerId);\n\n        // Sync fast caches\n        delete this.#peerCache[peerId];\n        delete this.#sendFnCache[peerId];\n        const idx = this.#peerIds.indexOf(peerId);\n        if (idx !== -1) this.#peerIds.splice(idx, 1);\n\n        // Emit peer removed event\n        this.emit('peer:removed', { peerId, meta: peer.meta });\n\n        return true;\n    }\n\n    /**\n     * Gets a peer by ID.\n     * \n     * @param {string} peerId\n     * @returns {RoutingEntry|undefined}\n     */\n    getPeer(peerId) {\n        // Fast Object-based lookup (faster than Map.get)\n        return this.#peerCache[peerId];\n    }\n\n    /**\n     * Gets all connected peer IDs.\n     * \n     * @returns {string[]}\n     */\n    getPeerIds() {\n        // Return cached array (avoids Array.from overhead)\n        return this.#peerIds.slice();\n    }\n\n    /**\n     * Gets count of connected peers.\n     * \n     * @returns {number}\n     */\n    get peerCount() {\n        return this.#peers.size;\n    }\n\n    /**\n     * Routes a message to a specific peer or broadcasts.\n     * \n     * @param {Object} message - Message to route.\n     * @param {string} [message.target] - Target peer ID (omit for broadcast).\n     * @param {Object} message.payload - Message payload.\n     * @param {Object} [options] - Broadcast options\n     * @param {string[]} [options.exclude] - Peer IDs to exclude from broadcast.\n     * @returns {RouteResult}\n     */\n    route(message, options = {}) {\n        const { target, payload } = message;\n\n        if (target) {\n            // Unicast to specific peer\n            return this.#routeUnicast(target, payload);\n        } else {\n            // Broadcast to all peers - lazy Set creation\n            const excludeArr = options.exclude;\n            const exclude = excludeArr?.length ? new Set(excludeArr) : null;\n            return this.#routeBroadcast(payload, exclude);\n        }\n    }\n\n    /**\n     * Broadcasts a message to all peers.\n     * \n     * @param {Object} payload - Message payload.\n     * @param {Object} [options={}] - Broadcast options.\n     * @param {string[]} [options.exclude] - Peers to exclude.\n     * @param {string[]} [options.include] - Only include these peers.\n     * @returns {RouteResult}\n     */\n    broadcast(payload, options = {}) {\n        // Lazy Set creation - skip allocation when not needed\n        const excludeArr = options.exclude;\n        const exclude = excludeArr?.length ? new Set(excludeArr) : null;\n        const includeArr = options.include;\n        const include = includeArr?.length ? new Set(includeArr) : null;\n\n        let delivered = 0;\n        const failed = [];\n\n        for (const [peerId, peer] of this.#peers) {\n            // Skip excluded peers\n            if (exclude?.has(peerId)) continue;\n\n            // Skip if not in include list (when specified)\n            if (include && !include.has(peerId)) continue;\n\n            // Skip disconnected peers\n            if (peer.status !== PeerStatus.CONNECTED) continue;\n\n            try {\n                const envelope = this.#createEnvelope(peerId, payload, MessageType.BROADCAST);\n                peer.sendFn(envelope);\n                delivered++;\n            } catch (error) {\n                console.error(`[Router] Failed to send to ${peerId}:`, error);\n                failed.push(peerId);\n            }\n        }\n\n        return { success: failed.length === 0, delivered, failed };\n    }\n\n    /**\n     * Gets the next sequence number for a peer.\n     * Used for causal ordering in SignalStore.\n     * \n     * @param {string} peerId\n     * @returns {number}\n     */\n    getSequence(peerId) {\n        return this.#peerSeq.get(peerId) ?? 0;\n    }\n\n    /**\n     * Updates peer status.\n     * \n     * @param {string} peerId\n     * @param {PeerStatus} status\n     */\n    setPeerStatus(peerId, status) {\n        const peer = this.#peerCache[peerId];\n        if (peer) {\n            peer.status = status;\n            this.emit('peer:status', { peerId, status });\n        }\n    }\n\n    /**\n     * Clears all peers.\n     */\n    clearPeers() {\n        // Fast iteration using cached array\n        const peerIds = this.#peerIds.slice();\n        for (const peerId of peerIds) {\n            this.removePeer(peerId);\n        }\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Routes to a single peer.\n     * \n     */\n    #routeUnicast(peerId, payload) {\n        const peer = this.#peerCache[peerId];\n\n        if (!peer) {\n            return {\n                success: false,\n                delivered: 0,\n                failed: [peerId],\n                error: ErrorCode.PEER_NOT_FOUND\n            };\n        }\n\n        if (peer.status !== PeerStatus.CONNECTED) {\n            return {\n                success: false,\n                delivered: 0,\n                failed: [peerId],\n                error: ErrorCode.PEER_DISCONNECTED\n            };\n        }\n\n        try {\n            // If payload is already a protocol message (has the marker), send directly\n            // Otherwise wrap in envelope for signals/broadcasts\n            const messageToSend = (payload && payload._cb)\n                ? payload\n                : this.#createEnvelope(peerId, payload, MessageType.SIGNAL);\n            peer.sendFn(messageToSend);\n            return { success: true, delivered: 1, failed: [] };\n        } catch (error) {\n            console.error(`[Router] Failed to send to ${peerId}:`, error);\n            return { success: false, delivered: 0, failed: [peerId] };\n        }\n    }\n\n    /**\n     * Broadcasts to multiple peers.\n     * \n     */\n    #routeBroadcast(payload, exclude) {\n        // exclude is already a Set or null from route()\n        return this.broadcast(payload, exclude ? { exclude: Array.from(exclude) } : {});\n    }\n\n    /**\n     * Creates a message envelope with routing info.\n     * \n     */\n    #createEnvelope(peerId, payload, type) {\n        // Increment per-peer sequence\n        const seq = (this.#peerSeq.get(peerId) ?? 0) + 1;\n        this.#peerSeq.set(peerId, seq);\n\n        return {\n            id: `msg_${++this.#messageSeq}`,\n            t: type,\n            ts: Date.now(),\n            seq,\n            p: payload\n        };\n    }\n}\n","/**\n * @fileoverview Pending requests tracker for request/response pattern.\n * Tracks outgoing requests and matches them with responses.\n * @module router/pending-requests\n */\n\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { deferred, withTimeout } from '../common/utils.js';\n\n/**\n * @typedef {Object} PendingRequest\n * @property {string} id - Request ID.\n * @property {string} targetPeer - Target peer ID.\n * @property {string} handlerName - Name of the handler.\n * @property {number} createdAt - When request was created.\n * @property {number} timeout - Timeout in ms.\n * @property {Function} resolve - Promise resolve function.\n * @property {Function} reject - Promise reject function.\n * @property {*} [defaultValue] - Value to return on timeout.\n */\n\n/**\n * @typedef {Object} RequestOptions\n * @property {number} [timeout=30000] - Request timeout in ms.\n * @property {*} [defaultValue] - Value to return on timeout instead of throwing.\n */\n\n/**\n * @typedef {Object} ResponseData\n * @property {string} requestId - Original request ID.\n * @property {boolean} success - Whether handler succeeded.\n * @property {*} [data] - Response data if successful.\n * @property {Object} [error] - Error if failed.\n */\n\n/**\n * Tracks pending requests and matches responses.\n * \n * Supports:\n * - Timeout handling\n * - Automatic cleanup\n * - Error propagation\n * - Request cancellation\n * \n * @example\n * const tracker = new PendingRequests();\n * \n * // Create request\n * const { requestId, promise } = tracker.create('peer-1', 'getData', {\n *   timeout: 5000\n * });\n * \n * // Send request via transport...\n * transport.send({ id: requestId, type: 'request', handler: 'getData' });\n * \n * // When response arrives:\n * tracker.resolve(requestId, responseData);\n * \n * // Or wait for response:\n * const result = await promise;\n */\nexport class PendingRequests {\n    /** @type {Map<string, PendingRequest>} Full feature storage */\n    #pending = new Map();\n\n    /** @type {Object<string, PendingRequest>} Fast Object-based cache for lookup */\n    #cache = Object.create(null);\n\n    /** @type {number} */\n    #requestCounter = 0;\n\n    /** @type {number} Default timeout */\n    #defaultTimeout;\n\n    /** @type {number} Maximum pending requests */\n    #maxPending;\n\n    /**\n     * Creates a new pending requests tracker.\n     * \n     * @param {Object} [options={}]\n     * @param {number} [options.defaultTimeout=30000] - Default timeout in ms.\n     * @param {number} [options.maxPending=1000] - Maximum pending requests (0 = unlimited).\n     */\n    constructor(options = {}) {\n        this.#defaultTimeout = options.defaultTimeout ?? 30000;\n        this.#maxPending = options.maxPending ?? 1000;\n    }\n\n    /**\n     * Creates a new pending request.\n     * \n     * @param {string} targetPeer - Target peer ID.\n     * @param {string} handlerName - Name of the handler to invoke.\n     * @param {RequestOptions} [options={}] - Request options.\n     * @returns {{ requestId: string, promise: Promise<*> }}\n     * \n     * @example\n     * const { requestId, promise } = tracker.create('widget', 'getState');\n     * const result = await promise;\n     */\n    create(targetPeer, handlerName, options = {}) {\n        // Enforce max pending limit to prevent memory exhaustion\n        if (this.#maxPending > 0 && this.#pending.size >= this.#maxPending) {\n            throw CrossBusError.from(ErrorCode.MAX_PENDING, {\n                current: this.#pending.size,\n                max: this.#maxPending,\n                targetPeer,\n                handlerName\n            });\n        }\n\n        const now = Date.now();\n        const requestId = `req_${++this.#requestCounter}_${now}`;\n        const timeout = options.timeout ?? this.#defaultTimeout;\n        const { promise, resolve, reject } = deferred();\n\n        /** @type {PendingRequest} */\n        const pending = {\n            id: requestId,\n            targetPeer,\n            handlerName,\n            createdAt: now,\n            timeout,\n            resolve,\n            reject,\n            defaultValue: options.defaultValue\n        };\n\n        this.#pending.set(requestId, pending);\n        this.#cache[requestId] = pending;  // Sync fast cache\n\n        // Set up timeout\n        const timeoutPromise = withTimeout(promise, timeout).catch(error => {\n            // Cleanup on timeout - use cache for fast check\n            if (requestId in this.#cache) {\n                this.#pending.delete(requestId);\n                delete this.#cache[requestId];\n\n                // Return default value if provided\n                if ('defaultValue' in options) {\n                    return options.defaultValue;\n                }\n\n                throw CrossBusError.from(ErrorCode.RESPONSE_TIMEOUT, {\n                    requestId,\n                    targetPeer,\n                    handlerName,\n                    timeout\n                });\n            }\n            throw error;\n        });\n\n        return { requestId, promise: timeoutPromise };\n    }\n\n    /**\n     * Resolves a pending request with response data.\n     * \n     * @param {string} requestId - Request ID to resolve.\n     * @param {ResponseData} response - Response data.\n     * @returns {boolean} True if request was found and resolved.\n     */\n    resolve(requestId, response) {\n        const pending = this.#cache[requestId];\n        if (!pending) return false;\n\n        // Sync both storages\n        this.#pending.delete(requestId);\n        delete this.#cache[requestId];\n\n        if (response.success) {\n            pending.resolve(response.data);\n        } else {\n            const error = CrossBusError.from(\n                response.error?.code ?? ErrorCode.HANDLER_ERROR,\n                {\n                    requestId,\n                    targetPeer: pending.targetPeer,\n                    handlerName: pending.handlerName,\n                    originalError: response.error\n                }\n            );\n            error.message = response.error?.message ?? 'Handler error';\n            pending.reject(error);\n        }\n\n        return true;\n    }\n\n    /**\n     * Rejects a pending request with an error.\n     * \n     * @param {string} requestId - Request ID to reject.\n     * @param {Error|string} error - Error or error message.\n     * @returns {boolean} True if request was found and rejected.\n     */\n    reject(requestId, error) {\n        const pending = this.#cache[requestId];\n        if (!pending) return false;\n\n        // Sync both storages\n        this.#pending.delete(requestId);\n        delete this.#cache[requestId];\n\n        const err = error instanceof Error ? error : new Error(error);\n        pending.reject(err);\n\n        return true;\n    }\n\n    /**\n     * Cancels a pending request.\n     * \n     * @param {string} requestId - Request ID to cancel.\n     * @returns {boolean} True if request was found and cancelled.\n     */\n    cancel(requestId) {\n        const pending = this.#cache[requestId];\n        if (!pending) return false;\n\n        // Sync both storages\n        this.#pending.delete(requestId);\n        delete this.#cache[requestId];\n        pending.reject(new Error('Request cancelled'));\n\n        return true;\n    }\n\n    /**\n     * Cancels all pending requests for a peer.\n     * Used when peer disconnects.\n     * \n     * @param {string} peerId - Peer ID.\n     * @returns {number} Number of requests cancelled.\n     */\n    cancelForPeer(peerId) {\n        let count = 0;\n\n        for (const [requestId, pending] of this.#pending) {\n            if (pending.targetPeer === peerId) {\n                this.#pending.delete(requestId);\n                delete this.#cache[requestId];  // Sync cache\n                pending.reject(CrossBusError.from(ErrorCode.PEER_DISCONNECTED, {\n                    peerId,\n                    requestId\n                }));\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    /**\n     * Cancels all pending requests.\n     * \n     * @returns {number} Number of requests cancelled.\n     */\n    cancelAll() {\n        const count = this.#pending.size;\n\n        for (const [requestId, pending] of this.#pending) {\n            pending.reject(new Error('All requests cancelled'));\n        }\n\n        this.#pending.clear();\n        // Reset cache to empty object\n        for (const key in this.#cache) {\n            delete this.#cache[key];\n        }\n        return count;\n    }\n\n    /**\n     * Checks if a request is pending.\n     * \n     * @param {string} requestId\n     * @returns {boolean}\n     */\n    has(requestId) {\n        // Fast Object-based check (faster than Map.has)\n        return requestId in this.#cache;\n    }\n\n    /**\n     * Gets a pending request.\n     * \n     * @param {string} requestId\n     * @returns {PendingRequest|undefined}\n     */\n    get(requestId) {\n        // Fast Object-based lookup\n        return this.#cache[requestId];\n    }\n\n    /**\n     * Gets count of pending requests.\n     * @returns {number}\n     */\n    get size() {\n        return this.#pending.size;\n    }\n\n    /**\n     * Gets all pending request IDs.\n     * @returns {string[]}\n     */\n    getRequestIds() {\n        return Array.from(this.#pending.keys());\n    }\n\n    /**\n     * Gets pending requests for a specific peer.\n     * \n     * @param {string} peerId\n     * @returns {PendingRequest[]}\n     */\n    getForPeer(peerId) {\n        const requests = [];\n        for (const pending of this.#pending.values()) {\n            if (pending.targetPeer === peerId) {\n                requests.push(pending);\n            }\n        }\n        return requests;\n    }\n}\n","/**\n * @fileoverview Secure handshake protocol for peer negotiation.\n * Handles connection establishment, authentication, and capability exchange.\n * @module security/handshake\n */\n\nimport { MessageType, HandshakePhase } from '../common/types.js';\nimport { ErrorCode } from '../common/errors.js';\nimport { uuid, deferred, withTimeout } from '../common/utils.js';\n\n/**\n * @typedef {Object} HandshakeConfig\n * @property {string} [peerId] - Our peer ID (auto-generated if not specified).\n * @property {number} [timeout=10000] - Handshake timeout in ms.\n * @property {Object} [meta={}] - Metadata to share with peer.\n * @property {string[]} [capabilities=[]] - Supported capabilities.\n */\n\n/**\n * @typedef {Object} PeerInfo\n * @property {string} peerId - Remote peer's ID.\n * @property {string} origin - Remote peer's origin.\n * @property {string} type - Remote peer's type (iframe, worker, etc).\n * @property {Object} meta - Remote peer's metadata.\n * @property {string[]} capabilities - Remote peer's capabilities.\n * @property {number} connectedAt - Connection timestamp.\n */\n\n/**\n * @typedef {Object} HandshakeResult\n * @property {boolean} success - Whether handshake succeeded.\n * @property {PeerInfo} [peer] - Peer info if successful.\n * @property {string} [error] - Error code if failed.\n * @property {string} [reason] - Error reason if failed.\n */\n\n/**\n * Handshake protocol for secure peer establishment.\n * \n * Protocol flow:\n * ```\n * INITIATOR                          RESPONDER\n *                                        \n *       HANDSHAKE_INIT                   \n *       { peerId, meta, caps }           \n *         \n *                                        \n *       HANDSHAKE_ACK                    \n *       { peerId, meta, caps, accept }   \n *         \n *                                        \n *       HANDSHAKE_COMPLETE               \n *       { confirmed: true }              \n *         \n *                                        \n *        Connected                      \n * ```\n */\nexport class Handshake {\n    /** @type {string} */\n    #localPeerId;\n\n    /** @type {Object} */\n    #meta;\n\n    /** @type {string[]} */\n    #capabilities;\n\n    /** @type {number} */\n    #timeout;\n\n    /** @type {Map<string, Object>} */\n    #pendingHandshakes = new Map();\n\n    /**\n     * Creates a new Handshake handler.\n     * \n     * @param {HandshakeConfig} [config={}]\n     */\n    constructor(config = {}) {\n        this.#localPeerId = config.peerId ?? uuid();\n        this.#meta = config.meta ?? {};\n        this.#capabilities = config.capabilities ?? [];\n        this.#timeout = config.timeout ?? 10000;\n    }\n\n    /**\n     * Gets the local peer ID.\n     * @returns {string}\n     */\n    get peerId() {\n        return this.#localPeerId;\n    }\n\n    /**\n     * Creates a handshake initiation message.\n     * \n     * @returns {Object} Handshake init message.\n     */\n    createInitMessage() {\n        return {\n            type: MessageType.HANDSHAKE_INIT,\n            handshakeId: uuid(),\n            peerId: this.#localPeerId,\n            meta: this.#meta,\n            capabilities: this.#capabilities,\n            timestamp: Date.now()\n        };\n    }\n\n    /**\n     * Creates a handshake acknowledgment message.\n     * \n     * @param {Object} initMessage - The received init message.\n     * @param {boolean} accept - Whether to accept the connection.\n     * @param {string} [reason] - Rejection reason if not accepted.\n     * @returns {Object} Handshake ack message.\n     */\n    createAckMessage(initMessage, accept, reason) {\n        return {\n            type: MessageType.HANDSHAKE_ACK,\n            handshakeId: initMessage.handshakeId,\n            peerId: this.#localPeerId,\n            meta: this.#meta,\n            capabilities: this.#capabilities,\n            accept,\n            reason: accept ? undefined : reason,\n            timestamp: Date.now()\n        };\n    }\n\n    /**\n     * Creates a handshake completion message.\n     * \n     * @param {string} handshakeId - The handshake ID.\n     * @returns {Object} Handshake complete message.\n     */\n    createCompleteMessage(handshakeId) {\n        return {\n            type: MessageType.HANDSHAKE_COMPLETE,\n            handshakeId,\n            confirmed: true,\n            timestamp: Date.now()\n        };\n    }\n\n    /**\n     * Initiates a handshake with a peer.\n     * \n     * @param {EventListener} sendFn - Function to send messages to peer.\n     * @returns {Promise<HandshakeResult>} Result of handshake attempt.\n     */\n    async initiate(sendFn) {\n        const initMsg = this.createInitMessage();\n        const { promise, resolve, reject } = deferred();\n\n        // Store pending handshake\n        this.#pendingHandshakes.set(initMsg.handshakeId, {\n            phase: HandshakePhase.INIT_SENT,\n            resolve,\n            reject,\n            initMsg,\n            startTime: Date.now()\n        });\n\n        // Send init message\n        sendFn(initMsg);\n\n        // Wait for response with timeout\n        try {\n            const result = await withTimeout(promise, this.#timeout);\n            return result;\n        } catch (/** @type {any} */ error) {\n            this.#pendingHandshakes.delete(initMsg.handshakeId);\n\n            if (error.code === ErrorCode.HANDSHAKE_TIMEOUT) {\n                return {\n                    success: false,\n                    error: ErrorCode.HANDSHAKE_TIMEOUT,\n                    reason: `Handshake timeout after ${this.#timeout}ms`\n                };\n            }\n\n            return {\n                success: false,\n                error: ErrorCode.HANDSHAKE_REJECTED,\n                reason: error.message\n            };\n        }\n    }\n\n    /**\n     * Handles a received handshake message.\n     * \n     * @param {Object} message - Received handshake message.\n     * @param {string} origin - Origin of the message.\n     * @param {EventListener} sendFn - Function to send response.\n     * @param {EventListener} [validateFn] - Optional validation function.\n     * @returns {PeerInfo|null} Peer info if handshake completes, null otherwise.\n     */\n    handleMessage(message, origin, sendFn, validateFn) {\n        switch (message.type) {\n            case MessageType.HANDSHAKE_INIT:\n                return this.#handleInit(message, origin, sendFn, validateFn);\n\n            case MessageType.HANDSHAKE_ACK:\n                return this.#handleAck(message, origin, sendFn);\n\n            case MessageType.HANDSHAKE_COMPLETE:\n                return this.#handleComplete(message, origin);\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Checks if a handshake is pending.\n     * \n     * @param {string} handshakeId\n     * @returns {boolean}\n     */\n    hasPending(handshakeId) {\n        return this.#pendingHandshakes.has(handshakeId);\n    }\n\n    /**\n     * Cancels a pending handshake.\n     * \n     * @param {string} handshakeId\n     */\n    cancel(handshakeId) {\n        const pending = this.#pendingHandshakes.get(handshakeId);\n        if (pending) {\n            pending.reject(new Error('Handshake cancelled'));\n            this.#pendingHandshakes.delete(handshakeId);\n        }\n    }\n\n    /**\n     * Cancels all pending handshakes.\n     */\n    cancelAll() {\n        for (const [id, pending] of this.#pendingHandshakes) {\n            pending.reject(new Error('All handshakes cancelled'));\n        }\n        this.#pendingHandshakes.clear();\n    }\n\n    // \n    // Private handlers\n    // \n\n    /**\n     * Handles HANDSHAKE_INIT message (we are responder).\n     * \n     */\n    #handleInit(message, origin, sendFn, validateFn) {\n        // Validate if validator provided\n        if (validateFn && !validateFn(message, origin)) {\n            const ack = this.createAckMessage(message, false, 'Validation failed');\n            sendFn(ack);\n            return null;\n        }\n\n        // Accept the connection\n        const ack = this.createAckMessage(message, true);\n        sendFn(ack);\n\n        // Store awaiting complete\n        this.#pendingHandshakes.set(message.handshakeId, {\n            phase: HandshakePhase.ACK_SENT,\n            remotePeer: {\n                peerId: message.peerId,\n                origin,\n                meta: message.meta,\n                capabilities: message.capabilities\n            }\n        });\n\n        return null; // Wait for complete message\n    }\n\n    /**\n     * Handles HANDSHAKE_ACK message (we are initiator).\n     * \n     */\n    #handleAck(message, origin, sendFn) {\n        const pending = this.#pendingHandshakes.get(message.handshakeId);\n        if (!pending) {\n            return null; // Unknown handshake\n        }\n\n        if (!message.accept) {\n            // Rejected\n            pending.reject(new Error(message.reason || 'Connection rejected'));\n            this.#pendingHandshakes.delete(message.handshakeId);\n            return null;\n        }\n\n        // Send complete message\n        const complete = this.createCompleteMessage(message.handshakeId);\n        sendFn(complete);\n\n        // Create peer info\n        const peerInfo = {\n            peerId: message.peerId,\n            origin,\n            meta: message.meta,\n            capabilities: message.capabilities,\n            type: 'unknown', // Will be updated by PeerRegistry\n            connectedAt: Date.now()\n        };\n\n        // Resolve the promise\n        pending.resolve({\n            success: true,\n            peer: peerInfo\n        });\n\n        this.#pendingHandshakes.delete(message.handshakeId);\n        return peerInfo;\n    }\n\n    /**\n     * Handles HANDSHAKE_COMPLETE message (we are responder).\n     * \n     */\n    #handleComplete(message, origin) {\n        const pending = this.#pendingHandshakes.get(message.handshakeId);\n        if (!pending || pending.phase !== HandshakePhase.ACK_SENT) {\n            return null;\n        }\n\n        if (!message.confirmed) {\n            this.#pendingHandshakes.delete(message.handshakeId);\n            return null;\n        }\n\n        // Handshake complete!\n        const peerInfo = {\n            ...pending.remotePeer,\n            connectedAt: Date.now()\n        };\n\n        this.#pendingHandshakes.delete(message.handshakeId);\n        return peerInfo;\n    }\n}\n","/**\n * @fileoverview Origin validation for cross-origin security.\n * Validates message origins against an allowlist.\n * @module security/origin-validator\n */\n\n/**\n * @typedef {Object} OriginValidatorOptions\n * @property {string[]} [allowed=[]] - Allowed origins. Empty = same-origin only.\n * @property {boolean} [allowAll=false] - Allow all origins (dangerous!).\n */\n\n/**\n * Validates message origins against a configured allowlist.\n * \n * Supports:\n * - Exact matches: 'https://example.com'\n * - Wildcards: 'https://*.example.com' (subdomains only)\n * - Protocols: 'chrome-extension://*', 'file://*'\n * \n * @example\n * const validator = new OriginValidator({\n *   allowed: [\n *     'https://app.example.com',\n *     'https://*.widgets.com'\n *   ]\n * });\n * \n * validator.isAllowed('https://app.example.com');     // true\n * validator.isAllowed('https://foo.widgets.com');     // true\n * validator.isAllowed('https://evil.com');            // false\n */\nexport class OriginValidator {\n    /** @type {Set<string>} */\n    #exactOrigins = new Set();\n\n    /** @type {RegExp[]} */\n    #patterns = [];\n\n    /** @type {boolean} */\n    #allowAll = false;\n\n    /** @type {string|undefined} */\n    #selfOrigin;\n\n    /**\n     * Creates a new origin validator.\n     * \n     * @param {OriginValidatorOptions} [options={}] - Configuration.\n     */\n    constructor(options = {}) {\n        this.#allowAll = options.allowAll ?? false;\n        this.#selfOrigin = globalThis.location?.origin;\n\n        // Process allowed origins\n        if (options.allowed) {\n            for (const origin of options.allowed) {\n                this.#addOrigin(origin);\n            }\n        }\n    }\n\n    /**\n     * Checks if an origin is allowed.\n     * \n     * @param {string} origin - Origin to check (e.g., 'https://example.com').\n     * @returns {boolean} True if allowed.\n     * \n     * @example\n     * validator.isAllowed('https://trusted.com');  // true\n     * validator.isAllowed('https://unknown.com');  // false\n     */\n    isAllowed(origin) {\n        // Allow-all mode (dangerous but sometimes needed)\n        if (this.#allowAll) {\n            return true;\n        }\n\n        // Null origin (file://, sandboxed iframes, etc.)\n        if (origin === 'null' || origin === null) {\n            return this.#exactOrigins.has('null');\n        }\n\n        // Empty/no allowed origins = same-origin only\n        if (this.#exactOrigins.size === 0 && this.#patterns.length === 0) {\n            return origin === this.#selfOrigin;\n        }\n\n        // Check exact match first (fast path)\n        if (this.#exactOrigins.has(origin)) {\n            return true;\n        }\n\n        // Check pattern matches\n        for (const pattern of this.#patterns) {\n            if (pattern.test(origin)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Adds an origin to the allowlist.\n     * \n     * @param {string} origin - Origin to add (supports wildcards).\n     * @returns {this} For chaining.\n     */\n    allow(origin) {\n        this.#addOrigin(origin);\n        return this;\n    }\n\n    /**\n     * Removes an origin from the allowlist.\n     * \n     * @param {string} origin - Origin to remove.\n     * @returns {boolean} True if removed.\n     */\n    disallow(origin) {\n        // For exact origins\n        if (this.#exactOrigins.has(origin)) {\n            this.#exactOrigins.delete(origin);\n            return true;\n        }\n\n        // For patterns, we'd need to store the original string\n        // For simplicity, patterns cannot be removed individually\n        return false;\n    }\n\n    /**\n     * Gets all exact (non-pattern) allowed origins.\n     * \n     * @returns {string[]} Array of allowed origins.\n     */\n    getAllowed() {\n        return Array.from(this.#exactOrigins);\n    }\n\n    /**\n     * Clears all allowed origins.\n     */\n    clear() {\n        this.#exactOrigins.clear();\n        this.#patterns = [];\n    }\n\n    /**\n     * Gets the current origin (if available).\n     * @returns {string|undefined}\n     */\n    get selfOrigin() {\n        return this.#selfOrigin;\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Adds an origin to the appropriate collection.\n     * \n     * @param {string} origin\n     */\n    #addOrigin(origin) {\n        if (typeof origin !== 'string') {\n            throw new TypeError('Origin must be a string');\n        }\n\n        // Wildcard '*' means allow all\n        if (origin === '*') {\n            this.#allowAll = true;\n            return;\n        }\n\n        // Contains wildcards - create pattern\n        if (origin.includes('*')) {\n            const pattern = this.#createPattern(origin);\n            this.#patterns.push(pattern);\n        } else {\n            // Exact origin\n            this.#exactOrigins.add(origin);\n        }\n    }\n\n    /**\n     * Creates a RegExp from a wildcard pattern.\n     * Uses bounded quantifiers to prevent ReDoS attacks.\n     * \n     * @param {string} pattern - Pattern with wildcards.\n     * @returns {RegExp}\n     */\n    #createPattern(pattern) {\n        // Escape special regex characters except *\n        const escaped = pattern\n            .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')\n            // Use bounded quantifier to prevent catastrophic backtracking\n            // Allows up to 253 chars per segment (max DNS label)\n            .replace(/\\*/g, '[a-zA-Z0-9.-]{0,253}');\n\n        return new RegExp(`^${escaped}$`);\n    }\n}\n\n/**\n * Creates an origin validator with common configurations.\n */\nexport const OriginValidatorPresets = {\n    /**\n     * Same-origin only (most secure).\n     * @returns {OriginValidator}\n     */\n    sameOrigin() {\n        return new OriginValidator();\n    },\n\n    /**\n     * Allow all origins (use with caution!).\n     * @returns {OriginValidator}\n     */\n    allowAll() {\n        return new OriginValidator({ allowAll: true });\n    },\n\n    /**\n     * Allow specific domains.\n     * @param {string[]} origins\n     * @returns {OriginValidator}\n     */\n    fromList(origins) {\n        return new OriginValidator({ allowed: origins });\n    }\n};\n","/**\n * @fileoverview CrossBus - Main facade for cross-context messaging.\n * Provides a unified API for inter-context communication.\n * @module core/cross-bus\n */\n\nimport { EventEmitter } from './event-emitter.js';\nimport { MessageType, PeerStatus } from '../common/types.js';\nimport { createSignalMessage, createRequestMessage, createResponseMessage } from './message-types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { uuid } from '../common/utils.js';\nimport { MessageRouter } from '../router/message-router.js';\nimport { PendingRequests } from '../router/pending-requests.js';\nimport { Handshake } from '../security/handshake.js';\nimport { OriginValidator } from '../security/origin-validator.js';\n\n/**\n * @typedef {Object} CrossBusOptions\n * @property {string} [peerId] - Unique peer identifier (auto-generated if not specified).\n * @property {boolean} [isHub=false] - Whether this instance is the hub.\n * @property {number} [requestTimeout=30000] - Default request timeout in ms.\n * @property {number} [handshakeTimeout=10000] - Handshake timeout in ms.\n * @property {string[]} [allowedOrigins=[]] - Allowed origins for incoming connections.\n * @property {Object} [meta={}] - Metadata to share with peers.\n * @property {string[]} [capabilities=[]] - Supported capabilities.\n * @property {string} [contentType='application/json'] - Preferred serialization format.\n * @property {number} [maxPayloadSize=1048576] - Maximum payload size in bytes (default: 1MB).\n * @property {number} [maxPendingRequests=100] - Maximum concurrent pending requests.\n * @property {boolean} [strictMode=false] - Enforce strict security (disallows wildcard origins).\n * @property {boolean} [debug=false] - Enable verbose debug logging.\n * @property {string} [debugPrefix='[CrossBus]'] - Prefix for debug log messages.\n */\n\n/**\n * @typedef {Object} HandlerOptions\n * @property {string[]} [allowedPeers] - Peer IDs allowed to call this handler.\n * @property {number} [rateLimit] - Max calls per second from each peer.\n * @property {Function} [validatePayload] - Custom payload validator function.\n */\n\n/**\n * @typedef {Object} PeerInfo\n * @property {string} peerId - Peer identifier.\n * @property {string} origin - Peer origin.\n * @property {Object} meta - Peer metadata.\n * @property {PeerStatus} status - Connection status.\n * @property {number} connectedAt - Connection timestamp.\n */\n\n/**\n * @typedef {Object} RequestOptions\n * @property {number} [timeout] - Request timeout in ms.\n * @property {*} [defaultValue] - Value to return on timeout instead of throwing.\n */\n\n/**\n * @typedef {Object} BroadcastRequestOptions\n * @property {number} [timeout] - Per-peer timeout in ms.\n * @property {string[]} [exclude] - Peer IDs to exclude.\n * @property {boolean} [ignoreErrors=true] - Whether to ignore peer errors.\n */\n\n/**\n * @typedef {Object} HookContext\n * @property {'signal'|'request'|'response'} type - Message type.\n * @property {string} [peerId] - Peer ID (if applicable).\n * @property {string} [handlerName] - Handler name (for requests).\n * @property {'inbound'|'outbound'} direction - Hook direction.\n */\n\n/**\n * @callback MessageHook\n * @param {*} payload - Payload to transform.\n * @param {HookContext} context - Hook context.\n * @returns {*|Promise<*>} Transformed payload.\n */\n\n/**\n * @typedef {Object} HookEntry\n * @property {MessageHook} fn - Hook function.\n * @property {number} priority - Execution priority (lower = first).\n */\n\n/**\n * @callback RequestHandler\n * @param {*} payload - Request payload.\n * @param {Object} context - Request context (peerId, meta, etc).\n * @returns {Promise<*>|*} - Response data.\n */\n\n/**\n * CrossBus - Zero-leak, high-performance cross-context messaging.\n * \n * Features:\n * - Hub/Mesh routing\n * - Request/Response pattern\n * - Broadcast to all peers\n * - ACK-based reliability\n * - Origin validation\n * - Resource lifecycle management\n * \n * @example\n * // Hub (main page)\n * const hub = new CrossBus({ isHub: true });\n * \n * // Connect iframe\n * hub.connect(iframe.contentWindow, {\n *   targetOrigin: 'https://widget.example.com'\n * });\n * \n * // Register handler\n * hub.handle('getData', async (payload, ctx) => {\n *   return { items: await fetchItems() };\n * });\n * \n * // Emit signal\n * hub.emit('user:login', { userId: 123 });\n * \n * // Request/Response\n * const result = await hub.request('widget-1', 'getStatus');\n * \n * // Cleanup\n * hub.destroy();\n */\nexport class CrossBus extends EventEmitter {\n    /** @type {string} */\n    #peerId;\n\n    /** @type {boolean} */\n    #isHub;\n\n    /** @type {MessageRouter} */\n    #router;\n\n    /** @type {PendingRequests} */\n    #pendingRequests;\n\n    /** @type {Handshake} */\n    #handshake;\n\n    /** @type {OriginValidator} */\n    #originValidator;\n\n    /** @type {string} */\n    #contentType;\n\n    /** @type {Map<string, RequestHandler>} */\n    #handlers = new Map();\n\n    /** @type {HookEntry[]} */\n    #inboundHooks = [];\n\n    /** @type {HookEntry[]} */\n    #outboundHooks = [];\n\n    /** @type {Object} */\n    #meta;\n\n    /** @type {string[]} */\n    #capabilities;\n\n    /** @type {number} */\n    #requestTimeout;\n\n    /** @type {number} */\n    #maxPayloadSize;\n\n    /** @type {number} */\n    #maxPendingRequests;\n\n    /** @type {boolean} */\n    #strictMode;\n\n    /** @type {Map<string, { count: number, resetAt: number }>} */\n    #rateLimitCounters = new Map();\n\n    /** @type {Map<string, HandlerOptions>} */\n    #handlerOptions = new Map();\n\n    /** @type {boolean} */\n    #debug = false;\n\n    /** @type {string} */\n    #debugPrefix = '[CrossBus]';\n\n    /** @type {number} */\n    #createdAt;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /**\n     * Creates a new CrossBus instance.\n     * \n     * @param {CrossBusOptions} [options={}]\n     */\n    constructor(options = {}) {\n        super();\n\n        this.#peerId = options.peerId ?? uuid();\n        this.#isHub = options.isHub ?? false;\n        this.#meta = options.meta ?? {};\n        this.#capabilities = options.capabilities ?? [];\n        this.#requestTimeout = options.requestTimeout ?? 30000;\n\n        // Initialize components\n        this.#router = new MessageRouter();\n        this.#pendingRequests = new PendingRequests({\n            defaultTimeout: this.#requestTimeout\n        });\n        this.#handshake = new Handshake({\n            peerId: this.#peerId,\n            meta: this.#meta,\n            capabilities: this.#capabilities,\n            timeout: options.handshakeTimeout ?? 10000\n        });\n        this.#originValidator = new OriginValidator({\n            allowed: options.allowedOrigins ?? []\n        });\n\n        // Serialization setup\n        this.#contentType = options.contentType ?? 'application/json';\n        // this.#serializer = getSerializer(this.#contentType);\n\n        // Security settings\n        this.#maxPayloadSize = options.maxPayloadSize ?? 1024 * 1024; // 1MB\n        this.#maxPendingRequests = options.maxPendingRequests ?? 100;\n        this.#strictMode = options.strictMode ?? false;\n\n        // Debug settings\n        this.#debug = options.debug ?? false;\n        this.#debugPrefix = options.debugPrefix ?? '[CrossBus]';\n        this.#createdAt = Date.now();\n\n        // Development security warnings\n        this.#emitSecurityWarnings(options);\n\n        // Initialize handshake capability\n        this.#capabilities.push(`serializer:${this.#contentType}`);\n\n        // Wire up router events\n        this.#router.on('peer:added', (e) => { this.emit('peer:connected', e.data); });\n        this.#router.on('peer:removed', (e) => { this.emit('peer:disconnected', e.data); });\n        this.#router.on('peer:status', (e) => { this.emit('peer:status', e.data); });\n\n        if (this.#debug) {\n            this.#log('info', `Initialized (isHub: ${this.#isHub})`);\n        }\n    }\n\n    /**\n     * Gets the local peer ID.\n     * @returns {string}\n     */\n    get peerId() {\n        return this.#peerId;\n    }\n\n    /**\n     * Gets whether this instance is the hub.\n     * @returns {boolean}\n     */\n    get isHub() {\n        return this.#isHub;\n    }\n\n    /**\n     * Gets connected peer count.\n     * @returns {number}\n     */\n    get peerCount() {\n        return this.#router.peerCount;\n    }\n\n    /**\n     * Gets all connected peer IDs.\n     * @returns {string[]}\n     */\n    get peers() {\n        return this.#router.getPeerIds();\n    }\n\n    /**\n     * Gets peer info by ID.\n     * \n     * @param {string} peerId\n     * @returns {PeerInfo|undefined}\n     */\n    getPeer(peerId) {\n        return this.#router.getPeer(peerId);\n    }\n\n    // \n    // Messaging API\n    // \n\n    /**\n     * Sends a signal to all connected peers.\n     * \n     * @param {string} signalName - Signal name (e.g., 'user:login').\n     * @param {*} [payload] - Signal payload.\n     * @param {Object} [options={}] - Send options.\n     * @param {string[]} [options.exclude] - Peer IDs to exclude.\n     * @returns {Promise<{ delivered: number, failed: string[] }>}\n     *  \n     * @example\n     * bus.signal('user:login', { userId: 123 });\n     */\n    async signal(signalName, payload, options = {}) {\n        this.#assertNotDestroyed();\n\n        // Apply outbound hooks\n        const transformedPayload = await this.#runHooks(\n            this.#outboundHooks,\n            payload,\n            { type: 'signal', direction: 'outbound' }\n        );\n\n        const message = createSignalMessage(\n            signalName,\n            transformedPayload,\n            this.#peerId\n        );\n\n        const result = await this.#router.broadcast(message, options);\n\n        this.#log('out', `SIGNAL \"${signalName}\" to ${result.delivered} peers`);\n\n        return result;\n    }\n\n    /**\n     * Sends a request to a specific peer and waits for response.\n     * \n     * @param {string} peerId - Target peer ID.\n     * @param {string} handlerName - Handler to invoke.\n     * @param {*} [payload] - Request payload.\n     * @param {RequestOptions} [options={}]\n     * @returns {Promise<*>} Handler response.\n     * \n     * @example\n     * const data = await bus.request('widget-1', 'getData', { id: 5 });\n     */\n    async request(peerId, handlerName, payload, options = {}) {\n        this.#assertNotDestroyed();\n\n        this.#log('out', `REQUEST \"${handlerName}\" to ${peerId}`);\n\n        const peer = this.#router.getPeer(peerId);\n        if (!peer) {\n            throw CrossBusError.from(ErrorCode.PEER_NOT_FOUND, { peerId });\n        }\n\n        // Create pending request\n        const { requestId, promise } = this.#pendingRequests.create(\n            peerId,\n            handlerName,\n            { timeout: options.timeout ?? this.#requestTimeout }\n        );\n\n        // Apply outbound hooks\n        const transformedPayload = await this.#runHooks(\n            this.#outboundHooks,\n            payload,\n            { type: 'request', peerId, handlerName, direction: 'outbound' }\n        );\n\n        // Build request message\n        const message = createRequestMessage(\n            handlerName,\n            transformedPayload,\n            this.#peerId,\n            peerId,\n            requestId // Pass the tracking ID\n        );\n\n        // Send request\n        const result = this.#router.route({ target: peerId, payload: message });\n\n        if (!result.success) {\n            this.#pendingRequests.cancel(requestId);\n            throw CrossBusError.from(ErrorCode.SEND_FAILED, { peerId });\n        }\n\n        return promise;\n    }\n\n    /**\n     * Broadcasts a request to all peers and collects responses.\n     * \n     * @param {string} handlerName - Handler to invoke on all peers.\n     * @param {*} [payload] - Request payload.\n     * @param {BroadcastRequestOptions} [options={}]\n     * @returns {Promise<Map<string, *>>} Map of peerId -> response.\n     * \n     * @example\n     * const responses = await bus.broadcastRequest('getStatus');\n     * for (const [peerId, status] of responses) {\n     *   console.log(`${peerId}: ${status.state}`);\n     * }\n     */\n    async broadcastRequest(handlerName, payload, options = {}) {\n        this.#assertNotDestroyed();\n\n        const timeout = options.timeout ?? this.#requestTimeout;\n        const ignoreErrors = options.ignoreErrors ?? true;\n        const exclude = new Set(options.exclude ?? []);\n\n        const results = new Map();\n        const promises = [];\n\n        for (const peerId of this.#router.getPeerIds()) {\n            if (exclude.has(peerId)) continue;\n\n            const requestPromise = this.request(peerId, handlerName, payload, { timeout })\n                .then(response => {\n                    results.set(peerId, { success: true, data: response });\n                })\n                .catch(error => {\n                    if (ignoreErrors) {\n                        results.set(peerId, { success: false, error: error.message });\n                    } else {\n                        throw error;\n                    }\n                });\n\n            promises.push(requestPromise);\n        }\n\n        await Promise.all(promises);\n        return results;\n    }\n\n    // \n    // Handler API\n    // \n\n    /**\n     * Registers a request handler.\n     * \n     * @param {string} handlerName - Handler name.\n     * @param {RequestHandler} handler - Handler function.\n     * @param {HandlerOptions} [options={}] - Security options.\n     * @returns {Function} Unregister function.\n     * \n     * @example\n     * // Basic handler\n     * const unhandle = bus.handle('getData', async (payload, ctx) => {\n     *   return await fetchData(payload.id);\n     * });\n     * \n     * // Secure handler with restrictions\n     * bus.handle('sensitiveData', async (payload) => { ... }, {\n     *   allowedPeers: ['trusted-agent'],  // Only these peers can call\n     *   rateLimit: 10,                    // Max 10 calls/second per peer\n     *   validatePayload: (p) => p.id != null  // Custom validation\n     * });\n     */\n    handle(handlerName, handler, options = {}) {\n        if (this.#handlers.has(handlerName)) {\n            throw CrossBusError.from(ErrorCode.HANDLER_EXISTS, { handlerName });\n        }\n\n        // Store handler options for security checks\n        if (options.allowedPeers || options.rateLimit || options.validatePayload) {\n            this.#handlerOptions.set(handlerName, options);\n        }\n\n        this.#handlers.set(handlerName, handler);\n\n        return () => {\n            this.#handlers.delete(handlerName);\n            this.#handlerOptions.delete(handlerName);\n        };\n    }\n\n    /**\n     * Removes a handler.\n     * \n     * @param {string} handlerName\n     * @returns {boolean} True if handler was removed.\n     */\n    unhandle(handlerName) {\n        return this.#handlers.delete(handlerName);\n    }\n\n    /**\n     * Checks if a handler is registered.\n     * \n     * @param {string} handlerName\n     * @returns {boolean}\n     */\n    hasHandler(handlerName) {\n        return this.#handlers.has(handlerName);\n    }\n\n    // \n    // Hook API\n    // \n\n    /**\n     * Adds an inbound hook to transform incoming payloads.\n     * \n     * @param {MessageHook} hookFn - Hook function.\n     * @param {number} [priority=10] - Execution priority (lower = first).\n     * @returns {Function} Unregister function.\n     * \n     * @example\n     * // Decrypt incoming messages\n     * const unhook = bus.addInboundHook(async (payload, ctx) => {\n     *   return await decrypt(payload);\n     * });\n     */\n    addInboundHook(hookFn, priority = 10) {\n        if (typeof hookFn !== 'function') {\n            throw new TypeError('hookFn must be a function');\n        }\n\n        const entry = { fn: hookFn, priority };\n        this.#inboundHooks.push(entry);\n        this.#inboundHooks.sort((a, b) => a.priority - b.priority);\n\n        return () => this.removeInboundHook(hookFn);\n    }\n\n    /**\n     * Adds an outbound hook to transform outgoing payloads.\n     * \n     * @param {MessageHook} hookFn - Hook function.\n     * @param {number} [priority=10] - Execution priority (lower = first).\n     * @returns {Function} Unregister function.\n     * \n     * @example\n     * // Encrypt outgoing messages\n     * const unhook = bus.addOutboundHook(async (payload, ctx) => {\n     *   return await encrypt(payload);\n     * });\n     */\n    addOutboundHook(hookFn, priority = 10) {\n        if (typeof hookFn !== 'function') {\n            throw new TypeError('hookFn must be a function');\n        }\n\n        const entry = { fn: hookFn, priority };\n        this.#outboundHooks.push(entry);\n        this.#outboundHooks.sort((a, b) => a.priority - b.priority);\n\n        return () => this.removeOutboundHook(hookFn);\n    }\n\n    /**\n     * Removes an inbound hook.\n     * \n     * @param {MessageHook} hookFn\n     * @returns {boolean} True if removed.\n     */\n    removeInboundHook(hookFn) {\n        const index = this.#inboundHooks.findIndex(e => e.fn === hookFn);\n        if (index !== -1) {\n            this.#inboundHooks.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes an outbound hook.\n     * \n     * @param {MessageHook} hookFn\n     * @returns {boolean} True if removed.\n     */\n    removeOutboundHook(hookFn) {\n        const index = this.#outboundHooks.findIndex(e => e.fn === hookFn);\n        if (index !== -1) {\n            this.#outboundHooks.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n\n    // \n    // Connection API\n    // \n\n    /**\n     * Adds a peer with a send function.\n     * Used for hub mode when managing connections manually.\n     * \n     * @param {string} peerId - Peer identifier.\n     * @param {EventListener} sendFn - Function to send messages.\n     * @param {Object} [options={}] - Additional options.\n     */\n    addPeer(peerId, sendFn, options = {}) {\n        this.#assertNotDestroyed();\n        this.#router.addPeer(peerId, sendFn, options);\n    }\n\n    /**\n     * Removes a peer.\n     * \n     * @param {string} peerId\n     * @returns {boolean}\n     */\n    removePeer(peerId) {\n        this.#pendingRequests.cancelForPeer(peerId);\n        return this.#router.removePeer(peerId);\n    }\n\n    /**\n     * Adds a transport and automatically wires up message handling.\n     * This is the recommended way to connect transports for AI agents.\n     * \n     * @param {Object} transport - Transport instance with send() and onMessage() methods.\n     * @param {Object} [options={}] - Additional options.\n     * @param {string} [options.peerId] - Override peer ID (defaults to transport's peerId or auto-generated).\n     * @param {string} [options.origin='*'] - Origin for message validation.\n     * @returns {Function} Cleanup function to remove the transport.\n     * \n     * @example\n     * // Simple usage\n     * const cleanup = bus.addTransport(new PostMessageTransport(iframe.contentWindow));\n     * \n     * // With options\n     * const cleanup = bus.addTransport(transport, { peerId: 'my-agent' });\n     * \n     * // Cleanup when done\n     * cleanup();\n     */\n    addTransport(transport, options = {}) {\n        this.#assertNotDestroyed();\n\n        if (!transport || typeof transport.send !== 'function') {\n            throw new TypeError('Transport must have a send() method');\n        }\n\n        const peerId = options.peerId || transport.peerId || `transport-${uuid()}`;\n        const origin = options.origin || '*';\n\n        // Wire up inbound: transport -> CrossBus\n        if (typeof transport.onMessage === 'function') {\n            transport.onMessage((message) => {\n                this.handleMessage(message, origin, peerId);\n            });\n        }\n\n        // Wire up outbound: CrossBus -> transport\n        this.addPeer(peerId, (message) => {\n            transport.send(message);\n        }, options);\n\n        // Return cleanup function\n        return () => {\n            this.removePeer(peerId);\n            if (typeof transport.destroy === 'function') {\n                transport.destroy();\n            }\n        };\n    }\n\n    /**\n     * Handles an incoming message.\n     * Call this when receiving a message from any transport.\n     * \n     * @param {Object} message - The received message.\n     * @param {string} origin - Origin of the message.\n     * @param {string} [peerId] - Source peer ID if known.\n     * @param {Function} [replyFn] - Function to reply to the sender.\n     */\n    async handleMessage(message, origin, peerId, replyFn) {\n        if (this.#destroyed) return;\n\n        // Validate origin\n        if (!this.#originValidator.isAllowed(origin)) {\n            console.warn(`[CrossBus] Blocked message from unauthorized origin: ${origin}`);\n            return;\n        }\n\n        // Apply inbound hooks to payload\n        // Apply inbound hooks to payload\n        // Support both standard 'payload'/'data' and legacy 'p'\n        const rawPayload = message.payload ?? message.data ?? message.p;\n        const msgType = message.type ?? message.t;\n\n        // Normalize fields based on schema\n        let handlerOrName = message.handler ?? message.name;\n        let dataContent = rawPayload;\n\n        // If ProtocolMessage (has 'payload' object containing metadata), extract from it\n        if (message.payload && typeof message.payload === 'object' && !message.p) {\n            if (msgType === MessageType.SIGNAL || msgType === MessageType.BROADCAST) {\n                handlerOrName = message.payload.name;\n                dataContent = message.payload.data;\n            } else if (msgType === MessageType.REQUEST) {\n                handlerOrName = message.payload.name;\n                dataContent = message.payload.data;\n            } else if (msgType === MessageType.RESPONSE) {\n                // Response payload structure? createResponseMessage puts 'data' in payload\n                dataContent = message.payload.data;\n            }\n        }\n        // Handle envelope format: { t, p: { type, payload: { name, data } } }\n        // Router creates envelopes with 'p' containing the original signal message\n        // Detect by: has 't' (not 'type'), has 'p' with nested 'payload' (ProtocolMessage structure)\n        else if (message.t && !message.type && message.p && typeof message.p === 'object' && message.p.payload) {\n            const innerMsg = message.p;\n            // Extract from nested ProtocolMessage\n            handlerOrName = innerMsg.payload.name ?? innerMsg.name;\n            dataContent = innerMsg.payload.data ?? innerMsg.data;\n        }\n\n        if (dataContent !== undefined) {\n            const hookContext = {\n                type: msgType === MessageType.SIGNAL ? 'signal' :\n                    msgType === MessageType.REQUEST ? 'request' : 'response',\n                peerId,\n                handlerName: handlerOrName,\n                direction: 'inbound'\n            };\n            // Run hooks\n            dataContent = await this.#runHooks(this.#inboundHooks, dataContent, hookContext);\n        }\n\n        switch (msgType) {\n            case MessageType.BROADCAST:  // Broadcast has same structure as signal\n            case MessageType.SIGNAL:\n                if (typeof handlerOrName !== 'string') {\n                    console.warn('[CrossBus] Invalid signal name type');\n                    return;\n                }\n                await this.#handleSignal(handlerOrName, dataContent, peerId);\n                break;\n\n            case MessageType.REQUEST:\n                if (typeof handlerOrName !== 'string') {\n                    console.warn('[CrossBus] Invalid handler name type');\n                    return;\n                }\n                // Pass normalized ID\n                // const reqId = message.id ?? (message.payload ? message.payload.id : undefined);\n                // Wait, 'id' is top level in ProtocolMessage AND legacy.\n\n                await this.#handleRequest(message.id, handlerOrName, dataContent, peerId, replyFn);\n                break;\n\n            case MessageType.RESPONSE: {\n                let success = message.success;\n                let error = message.error;\n\n                // Extract from ProtocolMessage payload if needed\n                if (message.payload && message.payload.success !== undefined) {\n                    success = message.payload.success;\n                    error = message.payload.error;\n                }\n\n                // If legacy response structure inside payload?\n                this.#handleResponse(message.payload?.requestId ?? message.id, success, dataContent, error);\n                break;\n            }\n\n            case MessageType.HANDSHAKE_INIT:\n            case MessageType.HANDSHAKE_ACK:\n            case MessageType.HANDSHAKE_COMPLETE:\n                this.#handshake.handleMessage(message, origin, /** @type {EventListener} */(replyFn));\n                break;\n\n            default:\n                console.warn(`[CrossBus] Unknown message type: ${msgType}`);\n        }\n    }\n\n    // \n    // Lifecycle\n    // \n\n    /**\n     * Destroys the CrossBus, cleaning up all resources.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n\n        // Cancel all pending requests\n        this.#pendingRequests.cancelAll();\n\n        // Clear handlers\n        this.#handlers.clear();\n\n        // Clear peers\n        this.#router.clearPeers();\n\n        // Clear event listeners\n        this.clear();\n\n        this.emit('destroyed', {});\n    }\n\n    /**\n     * Checks if the bus has been destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n\n    // \n    // Private handlers\n    // \n\n    /**\n     * Handles incoming signal.\n     * \n     */\n    async #handleSignal(name, data, peerId) {\n        await this.emit(name, {\n            payload: data,\n            source: peerId\n        });\n    }\n\n    /**\n     * Handles incoming request.\n     * \n     */\n    async #handleRequest(requestId, handlerName, data, peerId, replyFn) {\n        const handler = this.#handlers.get(handlerName);\n\n        let response;\n\n        if (!handler) {\n            response = createResponseMessage(\n                requestId,\n                null,\n                this.#peerId,\n                false,\n                {\n                    code: ErrorCode.NO_HANDLER,\n                    message: 'Handler not found'\n                }\n            );\n        } else {\n            // Check handler security (allowedPeers, rateLimit, validatePayload)\n            const securityCheck = this.#checkHandlerSecurity(handlerName, peerId, data);\n            if (!securityCheck.allowed) {\n                response = createResponseMessage(\n                    requestId,\n                    null,\n                    this.#peerId,\n                    false,\n                    {\n                        code: securityCheck.error?.code ?? ErrorCode.UNAUTHORIZED,\n                        message: securityCheck.error?.message ?? 'Security check failed'\n                    }\n                );\n            } else {\n                try {\n                    const result = await handler(data, {\n                        peerId,\n                        requestId: requestId,\n                        handlerName: handlerName\n                    });\n\n                    // Apply outbound hooks to response\n                    const transformedResult = await this.#runHooks(\n                        this.#outboundHooks,\n                        result,\n                        { type: 'response', peerId, handlerName: handlerName, direction: 'outbound' }\n                    );\n\n                    response = createResponseMessage(\n                        requestId,\n                        transformedResult,\n                        this.#peerId,\n                        true\n                    );\n                } catch (/** @type {any} */ error) {\n                    response = createResponseMessage(\n                        requestId,\n                        null,\n                        this.#peerId,\n                        false,\n                        {\n                            code: error.code ?? ErrorCode.HANDLER_ERROR,\n                            message: error.message\n                        }\n                    );\n                }\n            }\n        }\n\n        // Send response\n        if (replyFn) {\n            replyFn(response);\n        } else if (peerId) {\n            this.#router.route({ target: peerId, payload: response });\n        }\n    }\n\n    /**\n     * Handles incoming response.\n     * \n     */\n    #handleResponse(requestId, success, data, error) {\n        this.#pendingRequests.resolve(requestId, {\n            requestId,\n            success,\n            data,\n            error\n        });\n    }\n\n    /**\n     * Asserts the bus is not destroyed.\n     * \n     */\n    #assertNotDestroyed() {\n        if (this.#destroyed) {\n            throw CrossBusError.from(ErrorCode.DESTROYED, {\n                context: 'CrossBus operation'\n            });\n        }\n    }\n\n    /**\n     * Runs a chain of hooks on a payload.\n     * \n     */\n    async #runHooks(hooks, payload, context) {\n        let current = payload;\n        for (const { fn } of hooks) {\n            try {\n                current = await fn(current, context);\n            } catch (error) {\n                console.error('[CrossBus] Hook error:', error);\n                // Continue with unmodified payload on error\n            }\n        }\n        return current;\n    }\n\n    // \n    // Security Methods\n    // \n\n    /**\n     * Emits security warnings in development mode.\n     * @param {CrossBusOptions} options\n     */\n    #emitSecurityWarnings(options) {\n        // Only warn in development\n        const isDev = typeof process !== 'undefined'\n            ? process.env?.NODE_ENV !== 'production'\n            : typeof window !== 'undefined' && window.location?.hostname === 'localhost';\n\n        if (!isDev) return;\n\n        // Warn if allowedOrigins is not specified\n        if (!options.allowedOrigins || options.allowedOrigins.length === 0) {\n            console.warn(\n                '[CrossBus Security]  No allowedOrigins specified.\\n' +\n                'This bus will REJECT all incoming messages from transports.\\n' +\n                'To receive messages, specify allowed origins:\\n' +\n                '  allowedOrigins: [\"https://trusted-domain.com\"]\\n' +\n                'For development only: allowedOrigins: [\"*\"]'\n            );\n        }\n\n        // Warn about wildcard origins\n        if (options.allowedOrigins?.includes('*')) {\n            console.warn(\n                '[CrossBus Security]  allowedOrigins: [\"*\"] accepts messages from ANY origin.\\n' +\n                'This is INSECURE in production. Use specific origins instead:\\n' +\n                '  allowedOrigins: [\"https://trusted-domain.com\"]\\n' +\n                'For production, use:\\n' +\n                '  CrossBus.createSecure({ allowedOrigins: [\"https://...\"] })\\n' +\n                'Suppress this warning with NODE_ENV=production'\n            );\n\n            // In strict mode, throw error\n            if (this.#strictMode) {\n                throw new Error(\n                    'strictMode: allowedOrigins: [\"*\"] is not allowed. ' +\n                    'Use specific origins for security.'\n                );\n            }\n        }\n    }\n\n    /**\n     * Checks handler security before execution.\n     * @param {string} handlerName\n     * @param {string} peerId\n     * @param {*} payload\n     * @returns {{ allowed: boolean, error?: CrossBusError }}\n     */\n    #checkHandlerSecurity(handlerName, peerId, payload) {\n        const options = this.#handlerOptions.get(handlerName);\n        if (!options) {\n            return { allowed: true };\n        }\n\n        // Check peer allowlist\n        if (options.allowedPeers && !options.allowedPeers.includes(peerId)) {\n            return {\n                allowed: false,\n                error: CrossBusError.from(ErrorCode.UNAUTHORIZED, {\n                    handler: handlerName,\n                    peer: peerId,\n                    allowedPeers: options.allowedPeers\n                })\n            };\n        }\n\n        // Check rate limit\n        if (options.rateLimit) {\n            const limitKey = `${handlerName}:${peerId}`;\n            if (!this.#checkRateLimit(limitKey, options.rateLimit)) {\n                return {\n                    allowed: false,\n                    error: CrossBusError.from(ErrorCode.RATE_LIMITED, {\n                        handler: handlerName,\n                        peer: peerId,\n                        limit: options.rateLimit\n                    })\n                };\n            }\n        }\n\n        // Validate payload\n        if (options.validatePayload) {\n            try {\n                const isValid = options.validatePayload(payload);\n                if (!isValid) {\n                    return {\n                        allowed: false,\n                        error: CrossBusError.from(ErrorCode.INVALID_PAYLOAD, {\n                            handler: handlerName\n                        })\n                    };\n                }\n            } catch (/** @type {any} */ e) {\n                return {\n                    allowed: false,\n                    error: CrossBusError.from(ErrorCode.INVALID_PAYLOAD, {\n                        handler: handlerName,\n                        reason: e?.message ?? 'Validation error'\n                    })\n                };\n            }\n        }\n\n        return { allowed: true };\n    }\n\n    /**\n     * Checks rate limit for a key.\n     * @param {string} key - Rate limit key (e.g., \"handlerName:peerId\")\n     * @param {number} maxPerSecond - Maximum calls per second\n     * @returns {boolean} - True if allowed, false if rate limited\n     */\n    #checkRateLimit(key, maxPerSecond) {\n        const now = Date.now();\n        const counter = this.#rateLimitCounters.get(key);\n\n        if (!counter || now >= counter.resetAt) {\n            // Start new window\n            this.#rateLimitCounters.set(key, {\n                count: 1,\n                resetAt: now + 1000\n            });\n            return true;\n        }\n\n        if (counter.count >= maxPerSecond) {\n            return false;\n        }\n\n        counter.count++;\n        return true;\n    }\n\n\n\n    /**\n     * Gets the maximum payload size.\n     * @returns {number}\n     */\n    get maxPayloadSize() {\n        return this.#maxPayloadSize;\n    }\n\n    /**\n     * Gets whether strict mode is enabled.\n     * @returns {boolean}\n     */\n    get strictMode() {\n        return this.#strictMode;\n    }\n\n    /**\n     * Gets whether debug mode is enabled.\n     * @returns {boolean}\n     */\n    get debug() {\n        return this.#debug;\n    }\n\n    /**\n     * Gets the uptime in milliseconds.\n     * @returns {number}\n     */\n    get uptime() {\n        return Date.now() - this.#createdAt;\n    }\n\n    // \n    // Debug Logging\n    // \n\n    /**\n     * Logs a debug message if debug mode is enabled.\n     * @param {'in'|'out'|'info'|'warn'|'error'} type - Log type\n     * @param {string} message - Message to log\n     */\n    #log(type, message) {\n        if (!this.#debug) return;\n\n        const arrow = type === 'out' ? '' :\n            type === 'in' ? '' :\n                type === 'warn' ? '' :\n                    type === 'error' ? '' : '';\n\n        // eslint-disable-next-line no-console\n        console.log(`${this.#debugPrefix} ${arrow} ${message}`);\n    }\n\n    // \n    // Health Check\n    // \n\n    /**\n     * Returns the health status of the CrossBus instance.\n     * Useful for monitoring and diagnostics.\n     * \n     * @returns {Object} Health status object\n     * \n     * @example\n     * const health = bus.healthCheck();\n     * // {\n     * //   status: 'healthy',\n     * //   peerId: 'hub-1',\n     * //   uptime: 123456,\n     * //   peers: { total: 5, connected: 4 },\n     * //   handlers: ['getData', 'setData'],\n     * //   memory: { heapUsed: 12345678 }\n     * // }\n     */\n    healthCheck() {\n        const peerIds = this.#router.getPeerIds();\n        const connectedCount = peerIds.length;\n\n        // Determine status\n        let status = 'healthy';\n        if (this.#destroyed) {\n            status = 'unhealthy';\n        } else if (connectedCount === 0 && this.#isHub) {\n            status = 'degraded';\n        }\n\n        // Get memory usage if available\n        let memory;\n        if (typeof process !== 'undefined' && process.memoryUsage) {\n            try {\n                const mem = process.memoryUsage();\n                memory = {\n                    heapUsed: mem.heapUsed,\n                    heapTotal: mem.heapTotal,\n                    rss: mem.rss\n                };\n            } catch {\n                // Memory info not available\n            }\n        }\n\n        return {\n            status,\n            peerId: this.#peerId,\n            isHub: this.#isHub,\n            uptime: this.uptime,\n            peers: {\n                total: connectedCount,\n                ids: peerIds\n            },\n            handlers: Array.from(this.#handlers.keys()),\n            pendingRequests: this.#pendingRequests.size ?? 0,\n            destroyed: this.#destroyed,\n            ...(memory && { memory })\n        };\n    }\n\n    // \n    // Static Factory Methods\n    // \n\n    /**\n     * Creates a pre-configured secure CrossBus instance.\n     * Recommended for production use by AI agents.\n     * \n     * Enforces:\n     * - strictMode (no wildcard origins)\n     * - 1MB max payload size\n     * - 100 max pending requests\n     * - 30s request timeout\n     * \n     * @param {CrossBusOptions} options - Configuration options\n     * @returns {CrossBus} Configured instance\n     * @throws {Error} If allowedOrigins contains '*' or is missing\n     * \n     * @example\n     * // For production use\n     * const hub = CrossBus.createSecure({\n     *   peerId: 'my-hub',\n     *   isHub: true,\n     *   allowedOrigins: ['https://trusted-domain.com']\n     * });\n     */\n    static createSecure(options = {}) {\n        if (!options.allowedOrigins || options.allowedOrigins.length === 0) {\n            throw new Error(\n                'createSecure() requires allowedOrigins to be specified. ' +\n                'For development, use: new CrossBus({ allowedOrigins: [\"*\"] })'\n            );\n        }\n\n        if (options.allowedOrigins.includes('*')) {\n            throw new Error(\n                'createSecure() does not allow wildcard origins. ' +\n                'Specify exact origins: allowedOrigins: [\"https://example.com\"]'\n            );\n        }\n\n        return new CrossBus({\n            strictMode: true,\n            maxPayloadSize: 1024 * 1024,\n            maxPendingRequests: 100,\n            requestTimeout: 30000,\n            ...options\n        });\n    }\n\n    // \n    // Diagnostics (AI Agent Helper)\n    // \n\n    /**\n     * Performs diagnostics and returns troubleshooting suggestions.\n     * Designed to help AI agents identify and fix common issues.\n     * \n     * @returns {Object} Diagnostic report with issues and suggestions\n     * \n     * @example\n     * const report = bus.diagnose();\n     * if (report.issues.length > 0) {\n     *   console.log('Issues found:', report.issues);\n     *   console.log('Suggestions:', report.suggestions);\n     * }\n     */\n    diagnose() {\n        const issues = [];\n        const suggestions = [];\n        const warnings = [];\n\n        // Check if destroyed\n        if (this.#destroyed) {\n            issues.push('Instance is destroyed');\n            suggestions.push('Create a new CrossBus instance');\n            return { status: 'error', issues, suggestions, warnings };\n        }\n\n        // Check peer connections\n        const peerCount = this.#router.getPeerIds().length;\n        if (peerCount === 0) {\n            if (this.#isHub) {\n                warnings.push('Hub has no connected peers');\n                suggestions.push('Add transports with addTransport() or wait for agents to connect');\n            } else {\n                issues.push('Agent has no connected peers');\n                suggestions.push('Add a transport to connect to hub: bus.addTransport(transport, {peerId: \"hub\"})');\n            }\n        }\n\n        // Check handlers\n        const handlerCount = this.#handlers.size;\n        if (this.#isHub && handlerCount === 0) {\n            warnings.push('Hub has no registered handlers');\n            suggestions.push('Register handlers with bus.handle(\"name\", fn)');\n        }\n\n        // Check pending requests\n        const pendingCount = this.#pendingRequests.size ?? 0;\n        if (pendingCount > this.#maxPendingRequests * 0.8) {\n            warnings.push(`High pending request count: ${pendingCount}/${this.#maxPendingRequests}`);\n            suggestions.push('Consider increasing maxPendingRequests or check for slow handlers');\n        }\n\n        // Check strict mode in production hints\n        if (!this.#strictMode) {\n            warnings.push('strictMode is disabled');\n            suggestions.push('For production, use CrossBus.createSecure() or set strictMode: true');\n        }\n\n        // Determine overall status\n        let status = 'healthy';\n        if (issues.length > 0) {\n            status = 'error';\n        } else if (warnings.length > 0) {\n            status = 'warning';\n        }\n\n        return {\n            status,\n            peerId: this.#peerId,\n            isHub: this.#isHub,\n            peerCount,\n            handlerCount,\n            pendingRequests: pendingCount,\n            uptime: this.uptime,\n            issues,\n            warnings,\n            suggestions\n        };\n    }\n}\n"],"names":["createMessage","type","payload","meta","id","Object","freeze","PROTOCOL_MARKER","PROTOCOL_PREFIX","version","crypto","randomUUID","timestamp","Date","now","createResponseMessage","requestId","data","sourcePeerId","success","error","MessageType","RESPONSE","source","uuid","replace","c","r","Math","random","toString","deferred","Promise","withResolvers","resolve","reject","promise","res","rej","withTimeout","ms","message","race","_","setTimeout","Error","LISTENERS","Symbol","SUB_COUNTER","MAX_LISTENERS","FAST_CACHE","DEFAULT_SOURCE","peerId","origin","globalThis","location","EventEmitter","constructor","this","Map","create","setMaxListeners","n","getMaxListeners","on","name","handler","options","TypeError","entry","priority","mode","once","signal","has","set","listeners","get","length","push","lo","hi","mid","splice","map","e","active","subscription","signalName","unsubscribe","removeListener","aborted","addEventListener","onFast","filter","h","offFast","cache","idx","indexOf","findIndex","off","removedCount","remainingCount","undefined","delete","initialLength","filtered","emitSync","callbacks","len","i","emit","exactListeners","hasWildcard","event","messageId","then","matchingEntries","getMatchingListeners","toRemove","hasListeners","listenerCount","getSignalNames","Array","from","keys","clear","key","globalWildcard","namespaceWildcard","colonIdx","wildcardPattern","slice","sources","entries","Boolean","results","sort","a","b","SIGNAL","REQUEST","ACK","HANDSHAKE","HANDSHAKE_INIT","HANDSHAKE_ACK","HANDSHAKE_COMPLETE","PING","PONG","BYE","BROADCAST","HandshakePhase","INIT","INIT_SENT","ACK_SENT","DONE","PeerStatus","CONNECTING","CONNECTED","DISCONNECTED","RECONNECTING","FAILED","ErrorCode","HANDSHAKE_TIMEOUT","HANDSHAKE_REJECTED","ORIGIN_FORBIDDEN","PEER_EXISTS","PEER_NOT_FOUND","PEER_DISCONNECTED","RECONNECT_FAILED","UNSUPPORTED","NOT_CONNECTED","ACK_TIMEOUT","RESPONSE_TIMEOUT","QUEUE_FULL","INVALID_MESSAGE","VERSION_MISMATCH","CLONE_ERROR","TRANSFER_ERROR","MESSAGE_TOO_LARGE","UNREACHABLE","TTL_EXCEEDED","NO_ROUTE","NO_HANDLER","HANDLER_ERROR","HANDLER_TIMEOUT","HANDLER_EXISTS","SEND_FAILED","CHANNEL_FAILED","CHANNEL_CLOSED","MAX_PEERS","MAX_PENDING","DESTROYED","CIRCUIT_OPEN","PAYLOAD_TOO_LARGE","RATE_LIMITED","UNAUTHORIZED","INVALID_PAYLOAD","ERROR_META","retryable","suggestion","CrossBusError","code","details","cause","super","captureStackTrace","wrap","toJSON","MessageRouter","peers","messageSeq","peerSeq","peerCache","sendFnCache","peerIds","addPeer","sendFn","status","connectedAt","removePeer","peer","getPeer","getPeerIds","peerCount","size","route","target","routeUnicast","excludeArr","exclude","Set","routeBroadcast","broadcast","includeArr","include","delivered","failed","envelope","createEnvelope","getSequence","setPeerStatus","clearPeers","messageToSend","_cb","seq","t","ts","p","PendingRequests","pending","requestCounter","defaultTimeout","maxPending","targetPeer","handlerName","current","max","timeout","createdAt","defaultValue","timeoutPromise","catch","response","originalError","err","cancel","cancelForPeer","count","cancelAll","getRequestIds","getForPeer","requests","values","Handshake","localPeerId","capabilities","pendingHandshakes","config","createInitMessage","handshakeId","createAckMessage","initMessage","accept","reason","createCompleteMessage","confirmed","initiate","initMsg","phase","startTime","handleMessage","validateFn","handleInit","handleAck","handleComplete","hasPending","remotePeer","peerInfo","OriginValidator","exactOrigins","patterns","allowAll","selfOrigin","allowed","addOrigin","isAllowed","pattern","test","allow","disallow","getAllowed","includes","createPattern","add","escaped","RegExp","CrossBus","isHub","router","pendingRequests","handshake","originValidator","contentType","handlers","inboundHooks","outboundHooks","requestTimeout","maxPayloadSize","maxPendingRequests","strictMode","rateLimitCounters","handlerOptions","debug","debugPrefix","destroyed","handshakeTimeout","allowedOrigins","emitSecurityWarnings","log","assertNotDestroyed","destPeerId","dest","createSignalMessage","runHooks","direction","result","request","createRequestMessage","broadcastRequest","ignoreErrors","promises","requestPromise","all","handle","allowedPeers","rateLimit","validatePayload","unhandle","hasHandler","addInboundHook","hookFn","fn","removeInboundHook","addOutboundHook","removeOutboundHook","index","addTransport","transport","send","onMessage","destroy","replyFn","msgType","handlerOrName","dataContent","innerMsg","hookContext","handleSignal","handleRequest","handleResponse","isDestroyed","securityCheck","checkHandlerSecurity","context","hooks","process","env","NODE_ENV","window","hostname","checkRateLimit","limit","maxPerSecond","counter","resetAt","uptime","healthCheck","connectedCount","memory","memoryUsage","mem","heapUsed","heapTotal","rss","total","ids","createSecure","diagnose","issues","suggestions","warnings","handlerCount","pendingCount"],"mappings":"AAoFO,SAASA,EAAcC,EAAMC,EAASC,EAAO,CAAA,EAAIC,EAAK,MAC3D,OAAOC,OAAOC,OAAO,CACnBC,CAACC,GCtE2B,EDuE5BC,QCvE4B,EDwE5BL,GAAIA,GAAMM,OAAOC,aACjBV,OACAW,UAAWC,KAAKC,MAChBZ,QAASG,OAAOC,OAAO,IAAKJ,IAC5BC,KAAME,OAAOC,OAAO,IAAKH,KAE7B,CAmHO,SAASY,EAAsBC,EAAWC,EAAMC,EAAcC,GAAU,EAAMC,EAAQ,MAC3F,OAAOpB,EAAcqB,EAAYC,SAAU,CACzCN,YACAC,OACAM,OAAQL,EACRC,UACAC,SAEJ,CE9MO,SAASI,IACZ,MAAsB,oBAAXd,QAA0BA,OAAOC,WACjCD,OAAOC,aAGX,uCAAuCc,QAAQ,QAAUC,IAC5D,MAAMC,EAAoB,GAAhBC,KAAKC,SAAgB,EAE/B,OADgB,MAANH,EAAYC,EAAS,EAAJA,EAAU,GAC5BG,SAAS,KAE1B,CA6CO,SAASC,IAGZ,GAAqC,mBAA1BC,QAAQC,cAEf,OAAOD,QAAQC,gBAGnB,IAAIC,EAASC,EAMb,MAAO,CAAEC,QALO,IAAIJ,QAAQ,CAACK,EAAKC,KAC9BJ,EAAUG,EACVF,EAASG,IAGKJ,UAASC,SAC/B,CAoCO,SAASI,EAAYH,EAASI,EAAIC,EAAU,uBAC/C,OAAOT,QAAQU,KAAK,CAChBN,EACA,IAAIJ,QAAQ,CAACW,EAAGR,KACZS,WAAW,IAAMT,EAAO,IAAIU,MAAMJ,IAAWD,MAGzD,CCrHA,MAAMM,EAAYC,OAAO,aAGnBC,EAAcD,OAAO,cAGrBE,EAAgBF,OAAO,gBAGvBG,EAAaH,OAAO,aAMpBI,EAAiB9C,OAAOC,OAAO,CACjC8C,OAAQ,OACRC,YAAuC,IAAxBC,WAAWC,SAA2BD,WAAWC,SAASF,OAAS,UAClFpD,KAAM,UA8EH,MAAMuD,EACT,WAAAC,GAEIC,KAAKZ,GAAa,IAAIa,IAGtBD,KAAKV,GAAe,EAGpBU,KAAKT,GA7FiB,GAgGtBS,KAAKR,GAAc7C,OAAOuD,OAAO,KACrC,CAMA,eAAAC,CAAgBC,GAEZ,OADAJ,KAAKT,GAAiBa,EACfJ,IACX,CAMA,eAAAK,GACI,OAAOL,KAAKT,EAChB,CAgCA,EAAAe,CAAGC,EAAMC,EAASC,EAAU,CAAA,GACxB,GAAoB,iBAATF,EACP,MAAM,IAAIG,UAAU,gCAExB,GAAuB,mBAAZF,EACP,MAAM,IAAIE,UAAU,8BAGxB,MAAMhE,EAAK,UAASsD,KAAKV,GAKnBqB,EAAQ,CACVjE,KACA8D,UACAI,SAAUH,EAAQG,UAAY,EAC9BC,KAAMJ,EAAQI,MAAQ,QACtBC,KAAML,EAAQK,OAAQ,EACtBC,OAAQN,EAAQM,QAAU,MAIzBf,KAAKZ,GAAW4B,IAAIT,IACrBP,KAAKZ,GAAW6B,IAAIV,EAAM,IAG9B,MAAMW,EAAYlB,KAAKZ,GAAW+B,IAAIZ,GAGtC,GAAyB,IAArBW,EAAUE,QAAgBT,EAAMC,UAAYM,EAAUA,EAAUE,OAAS,GAAGR,SAE5EM,EAAUG,KAAKV,OACZ,CAEH,IAAIW,EAAK,EAAGC,EAAKL,EAAUE,OAC3B,KAAOE,EAAKC,GAAI,CACZ,MAAMC,EAAOF,EAAKC,IAAQ,EACtBL,EAAUM,GAAKZ,UAAYD,EAAMC,SACjCU,EAAKE,EAAM,EAEXD,EAAKC,CAEb,CACAN,EAAUO,OAAOH,EAAI,EAAGX,EAC5B,CAGAX,KAAKR,GAAYe,GAAQW,EAAUQ,IAAIC,GAAKA,EAAEnB,SAY9C,IAAIoB,GAAS,EACb,MAAMC,EAAe,CACjBnF,KACAoF,WAAYvB,EACZ,UAAIqB,GAAW,OAAOA,CAAQ,EAC9BG,YAAa,KACLH,IACA5B,MAAKgC,EAAgBzB,EAAM7D,GAC3BkF,GAAS,KAkBrB,OAZIjB,EAAMI,SACFJ,EAAMI,OAAOkB,SAEbjC,MAAKgC,EAAgBzB,EAAM7D,GAC3BkF,GAAS,GAETjB,EAAMI,OAAOmB,iBAAiB,QAAS,KACnCL,EAAaE,eACd,CAAEjB,MAAM,KAIZe,CACX,CAWA,IAAAf,CAAKP,EAAMC,EAASC,EAAU,CAAA,GAC1B,OAAOT,KAAKM,GAAGC,EAAMC,EAAS,IAAKC,EAASK,MAAM,GACtD,CAsBA,MAAAqB,CAAO5B,EAAMC,GAGT,OADCR,KAAKR,GAAYe,KAAU,IAAIc,KAAKb,GAC9B,KACHR,KAAKR,GAAYe,GAAQP,KAAKR,GAAYe,IAAO6B,OAAOC,GAAKA,IAAM7B,GAE3E,CAQA,OAAA8B,CAAQ/B,EAAMC,GACV,MAAM+B,EAAQvC,KAAKR,GAAYe,GAC/B,GAAIgC,EAAO,CACP,MAAMC,EAAMD,EAAME,QAAQjC,IACd,IAARgC,GAAYD,EAAMd,OAAOe,EAAK,EACtC,CAEA,MAAMtB,EAAYlB,KAAKZ,GAAW+B,IAAIZ,GACtC,GAAIW,EAAW,CACX,MAAMsB,EAAMtB,EAAUwB,UAAUf,GAAKA,EAAEnB,UAAYA,IACvC,IAARgC,GAAYtB,EAAUO,OAAOe,EAAK,EAC1C,CACJ,CAqBA,GAAAG,CAAIpC,EAAMC,GACN,GAAoB,iBAATD,EACP,MAAM,IAAIG,UAAU,gCAGxB,MAAMQ,EAAYlB,KAAKZ,GAAW+B,IAAIZ,GAEtC,IAAKW,GAAkC,IAArBA,EAAUE,OACxB,MAAO,CAAE3D,SAAS,EAAOmF,aAAc,EAAGC,eAAgB,GAG9D,IAAID,EAAe,EAEnB,QAAgBE,IAAZtC,EAEAoC,EAAe1B,EAAUE,OACzBpB,KAAKZ,GAAW2D,OAAOxC,UAChBP,KAAKR,GAAYe,OACrB,CAEH,MAAMyC,EAAgB9B,EAAUE,OAC1B6B,EAAW/B,EAAUkB,OAAOzB,GAASA,EAAMH,UAAYA,GAC7DoC,EAAeI,EAAgBC,EAAS7B,OAEhB,IAApB6B,EAAS7B,QACTpB,KAAKZ,GAAW2D,OAAOxC,UAChBP,KAAKR,GAAYe,KAExBP,KAAKZ,GAAW6B,IAAIV,EAAM0C,GAC1BjD,KAAKR,GAAYe,GAAQ0C,EAASvB,IAAIC,GAAKA,EAAEnB,SAErD,CAIA,MAAO,CACH/C,QAASmF,EAAe,EACxBA,eACAC,eALc7C,KAAKZ,GAAW+B,IAAIZ,IAAOa,QAAU,EAO3D,CAqBA,QAAA8B,CAAS3C,EAAMhD,GAEX,MAAM4F,EAAYnD,KAAKR,GAAYe,GACnC,IAAK4C,EAAW,OAAO,EAGvB,MAAMC,EAAMD,EAAU/B,OACtB,GAAY,IAARgC,EAEA,OADAD,EAAU,GAAG5F,GACN,EAEX,GAAY,IAAR6F,EAGA,OAFAD,EAAU,GAAG5F,GACb4F,EAAU,GAAG5F,GACN,EAEX,GAAY,IAAR6F,EAIA,OAHAD,EAAU,GAAG5F,GACb4F,EAAU,GAAG5F,GACb4F,EAAU,GAAG5F,GACN,EAEX,GAAY,IAAR6F,EAKA,OAJAD,EAAU,GAAG5F,GACb4F,EAAU,GAAG5F,GACb4F,EAAU,GAAG5F,GACb4F,EAAU,GAAG5F,GACN,EAIX,IAAK,IAAI8F,EAAI,EAAGA,EAAID,EAAKC,IACrBF,EAAUE,GAAG9F,GAEjB,OAAO6F,CACX,CAeA,UAAME,CAAK/C,EAAMhD,EAAMM,GACnB,GAAoB,iBAAT0C,EACP,MAAM,IAAIG,UAAU,gCAIxB,MAAM6C,EAAiBvD,KAAKZ,GAAW+B,IAAIZ,GACrCiD,EAAcxD,KAAKZ,GAAW4B,IAAI,KAExC,GAA+B,IAA3BuC,GAAgBnC,SAAiBoC,IAAgB3F,EAAQ,CACzD,MAAM8C,EAAQ4C,EAAe,GACvBE,EAAQ,CACVlD,OACAhD,OACAmG,UAAW1G,OAAOC,aAClBC,UAAWC,KAAKC,MAChBS,OAAQ4B,GAGZ,IACuB,SAAfkB,EAAME,WACAF,EAAMH,QAAQiD,GAEpBnF,QAAQE,UAAUmF,KAAK,IAAMhD,EAAMH,QAAQiD,GAEnD,CAAE,MAAO/F,GAET,CAMA,OAJIiD,EAAMG,MACNd,MAAKgC,EAAgBzB,EAAMI,EAAMjE,IAG9B,CACX,CAGA,MAAM+G,EAAQ,CACVlD,OACAhD,OACAmG,UAAW1G,OAAOC,aAClBC,UAAWC,KAAKC,MAChBS,OAAQA,EAAS,IAAK4B,KAAmB5B,GAAW4B,GAIlDmE,EAAkB5D,MAAK6D,EAAsBtD,GAG7CuD,EAAW,GAGjB,IAAK,MAAMhC,WAAEA,EAAUnB,MAAEA,KAAWiD,EAAiB,CACjD,IACuB,SAAfjD,EAAME,WACAF,EAAMH,QAAQiD,GAGpBnF,QAAQE,UAAUmF,KAAK,IAAMhD,EAAMH,QAAQiD,GAEnD,CAAE,MAAO/F,GAGT,CAEIiD,EAAMG,MACNgD,EAASzC,KAAK,CAAES,aAAYpF,GAAIiE,EAAMjE,IAE9C,CAGA,IAAK,MAAMoF,WAAEA,EAAUpF,GAAEA,KAAQoH,EAC7B9D,MAAKgC,EAAgBF,EAAYpF,GAGrC,OAAOkH,EAAgBxC,MAC3B,CAQA,YAAA2C,CAAaxD,GACT,MAAMW,EAAYlB,KAAKZ,GAAW+B,IAAIZ,GACtC,YAAqBuC,IAAd5B,GAA2BA,EAAUE,OAAS,CACzD,CAQA,aAAA4C,CAAczD,GACV,OAAOP,KAAKZ,GAAW+B,IAAIZ,IAAOa,QAAU,CAChD,CAOA,cAAA6C,GACI,OAAOC,MAAMC,KAAKnE,KAAKZ,GAAWgF,OACtC,CAKA,KAAAC,GACIrE,KAAKZ,GAAWiF,QAEhB,IAAK,MAAMC,KAAOtE,KAAKR,UACZQ,KAAKR,GAAY8E,EAEhC,CASA,EAAAT,CAAsBtD,GAElB,MAAMgD,EAAiBvD,KAAKZ,GAAW+B,IAAIZ,GACrCgE,EAAiBvE,KAAKZ,GAAW+B,IAAI,KAG3C,IAAIqD,EAAoB,KACxB,MAAMC,EAAWlE,EAAKkC,QAAQ,KAC9B,GAAIgC,EAAW,EAAG,CACd,MAAMC,EAAkBnE,EAAKoE,MAAM,EAAGF,EAAW,GAAK,IACtDD,EAAoBxE,KAAKZ,GAAW+B,IAAIuD,EAC5C,CAGA,GAAInB,IAAmBgB,IAAmBC,EACtC,OAAOjB,EAAe7B,IAAIf,IAAK,CAAOmB,WAAYvB,EAAMI,WAI5D,MAAMiE,EAAU,CACZrB,GAAkB,CAAEzB,WAAYvB,EAAMsE,QAAStB,GAC/CgB,GAAkB,CAAEzC,WAAY,IAAK+C,QAASN,GAC9CC,GAAqB,CAAE1C,WAAYvB,EAAKoE,MAAM,EAAGF,EAAW,GAAK,IAAKI,QAASL,IACjFpC,OAAO0C,SAET,GAAuB,IAAnBF,EAAQxD,OACR,MAAO,GAGX,GAAuB,IAAnBwD,EAAQxD,OAER,OAAOwD,EAAQ,GAAGC,QAAQnD,IAAIf,IAAK,CAAOmB,WAAY8C,EAAQ,GAAG9C,WAAYnB,WAIjF,MAAMoE,EAAU,GAChB,IAAK,MAAMjD,WAAEA,EAAU+C,QAAEA,KAAaD,EAClC,IAAK,MAAMjE,KAASkE,EAChBE,EAAQ1D,KAAK,CAAES,aAAYnB,UAOnC,OAFAoE,EAAQC,KAAK,CAACC,EAAGC,IAAMA,EAAEvE,MAAMC,SAAWqE,EAAEtE,MAAMC,UAE3CmE,CACX,CAWA,EAAA/C,CAAgBzB,EAAM7D,GAClB,MAAMwE,EAAYlB,KAAKZ,GAAW+B,IAAIZ,GACtC,IAAKW,EAAW,OAEhB,MAAM+B,EAAW/B,EAAUkB,OAAOzB,GAASA,EAAMjE,KAAOA,GAEhC,IAApBuG,EAAS7B,QACTpB,KAAKZ,GAAW2D,OAAOxC,UAChBP,KAAKR,GAAYe,KAExBP,KAAKZ,GAAW6B,IAAIV,EAAM0C,GAC1BjD,KAAKR,GAAYe,GAAQ0C,EAASvB,IAAIC,GAAKA,EAAEnB,SAErD,EFvnBG,MAAM3D,EAAkB,MAalBc,EAAchB,OAAOC,OAAO,CAErCuI,OAAQ,MAERC,QAAS,MAETxH,SAAU,MAEVyH,IAAK,MAELC,UAAW,MACXC,eAAgB,WAChBC,cAAe,UACfC,mBAAoB,WAEpBC,KAAM,MAENC,KAAM,MAENC,IAAK,MAELC,UAAW,OAQFC,EAAiBnJ,OAAOC,OAAO,CACxCmJ,KAAM,OACNC,UAAW,YACXX,IAAK,MACLY,SAAU,WACVC,KAAM,SAQGC,EAAaxJ,OAAOC,OAAO,CACpCwJ,WAAY,aACZC,UAAW,YACXC,aAAc,eACdC,aAAc,eACdC,OAAQ,WG5DCC,EAAY9J,OAAOC,OAAO,CAEnC8J,kBAAmB,wBACnBC,mBAAoB,yBACpBC,iBAAkB,uBAClBC,YAAa,kBACbC,eAAgB,qBAChBC,kBAAmB,wBACnBC,iBAAkB,uBAClBC,YAAa,kBACbC,cAAe,oBAGfC,YAAa,kBACbC,iBAAkB,uBAClBC,WAAY,iBACZC,gBAAiB,sBACjBC,iBAAkB,uBAClBC,YAAa,kBACbC,eAAgB,qBAChBC,kBAAmB,wBAGnBC,YAAa,kBACbC,aAAc,mBACdC,SAAU,eAGVC,WAAY,iBACZC,cAAe,oBACfC,gBAAiB,sBACjBC,eAAgB,qBAChBC,YAAa,kBAGbC,eAAgB,qBAChBC,eAAgB,qBAGhBC,UAAW,gBACXC,YAAa,kBACbC,UAAW,gBAGXC,aAAc,mBAGdC,kBAAmB,wBACnBC,aAAc,mBACdC,aAAc,mBACdC,gBAAiB,wBAOfC,EAAalM,OAAOC,OAAO,CAC7B,CAAC6J,EAAUC,mBAAoB,CAC3B3H,QAAS,sBACT+J,WAAW,EACXC,WAAY,uFAEhB,CAACtC,EAAUE,oBAAqB,CAC5B5H,QAAS,6BACT+J,WAAW,EACXC,WAAY,iFAEhB,CAACtC,EAAUG,kBAAmB,CAC1B7H,QAAS,qCACT+J,WAAW,EACXC,WAAY,sFAEhB,CAACtC,EAAUI,aAAc,CACrB9H,QAAS,mCACT+J,WAAW,EACXC,WAAY,0EAEhB,CAACtC,EAAUK,gBAAiB,CACxB/H,QAAS,iBACT+J,WAAW,EACXC,WAAY,wFAEhB,CAACtC,EAAUM,mBAAoB,CAC3BhI,QAAS,uBACT+J,WAAW,EACXC,WAAY,0EAEhB,CAACtC,EAAUO,kBAAmB,CAC1BjI,QAAS,oCACT+J,WAAW,EACXC,WAAY,sEAEhB,CAACtC,EAAUQ,aAAc,CACrBlI,QAAS,8CACT+J,WAAW,EACXC,WAAY,sFAEhB,CAACtC,EAAUS,eAAgB,CACvBnI,QAAS,6BACT+J,WAAW,EACXC,WAAY,wEAEhB,CAACtC,EAAUU,aAAc,CACrBpI,QAAS,kCACT+J,WAAW,EACXC,WAAY,0DAEhB,CAACtC,EAAUW,kBAAmB,CAC1BrI,QAAS,uCACT+J,WAAW,EACXC,WAAY,6FAEhB,CAACtC,EAAUY,YAAa,CACpBtI,QAAS,wBACT+J,WAAW,EACXC,WAAY,qFAEhB,CAACtC,EAAUa,iBAAkB,CACzBvI,QAAS,yBACT+J,WAAW,EACXC,WAAY,4EAEhB,CAACtC,EAAUc,kBAAmB,CAC1BxI,QAAS,4BACT+J,WAAW,EACXC,WAAY,kDAEhB,CAACtC,EAAUe,aAAc,CACrBzI,QAAS,0DACT+J,WAAW,EACXC,WAAY,2EAEhB,CAACtC,EAAUgB,gBAAiB,CACxB1I,QAAS,sCACT+J,WAAW,EACXC,WAAY,mFAEhB,CAACtC,EAAUiB,mBAAoB,CAC3B3I,QAAS,+BACT+J,WAAW,EACXC,WAAY,uEAEhB,CAACtC,EAAUkB,aAAc,CACrB5I,QAAS,kCACT+J,WAAW,EACXC,WAAY,4EAEhB,CAACtC,EAAUmB,cAAe,CACtB7I,QAAS,+CACT+J,WAAW,EACXC,WAAY,2EAEhB,CAACtC,EAAUoB,UAAW,CAClB9I,QAAS,0BACT+J,WAAW,EACXC,WAAY,6EAEhB,CAACtC,EAAUqB,YAAa,CACpB/I,QAAS,yCACT+J,WAAW,EACXC,WAAY,2FAEhB,CAACtC,EAAUsB,eAAgB,CACvBhJ,QAAS,6BACT+J,WAAW,EACXC,WAAY,gEAEhB,CAACtC,EAAUuB,iBAAkB,CACzBjJ,QAAS,yCACT+J,WAAW,EACXC,WAAY,sEAEhB,CAACtC,EAAUwB,gBAAiB,CACxBlJ,QAAS,4CACT+J,WAAW,EACXC,WAAY,iEAEhB,CAACtC,EAAUyB,aAAc,CACrBnJ,QAAS,iCACT+J,WAAW,EACXC,WAAY,mEAEhB,CAACtC,EAAU0B,gBAAiB,CACxBpJ,QAAS,kCACT+J,WAAW,EACXC,WAAY,sEAEhB,CAACtC,EAAU2B,gBAAiB,CACxBrJ,QAAS,kCACT+J,WAAW,EACXC,WAAY,sEAEhB,CAACtC,EAAU4B,WAAY,CACnBtJ,QAAS,kCACT+J,WAAW,EACXC,WAAY,8DAEhB,CAACtC,EAAU6B,aAAc,CACrBvJ,QAAS,mCACT+J,WAAW,EACXC,WAAY,8EAEhB,CAACtC,EAAU8B,WAAY,CACnBxJ,QAAS,uCACT+J,WAAW,EACXC,WAAY,yEAEhB,CAACtC,EAAU+B,cAAe,CACtBzJ,QAAS,0BACT+J,WAAW,EACXC,WAAY,yEAEhB,CAACtC,EAAUgC,mBAAoB,CAC3B1J,QAAS,uCACT+J,WAAW,EACXC,WAAY,mGAEhB,CAACtC,EAAUiC,cAAe,CACtB3J,QAAS,8BACT+J,WAAW,EACXC,WAAY,6EAEhB,CAACtC,EAAUkC,cAAe,CACtB5J,QAAS,8CACT+J,WAAW,EACXC,WAAY,sEAEhB,CAACtC,EAAUmC,iBAAkB,CACzB7J,QAAS,4BACT+J,WAAW,EACXC,WAAY,2DAqBb,MAAMC,UAAsB7J,MAK/B8J,KAMAC,QAMAJ,UAMAK,MAMAjM,UAYA,WAAA6C,CAAYkJ,EAAMlK,EAAS0B,EAAU,CAAA,GACjC,MAAMhE,EAAOoM,EAAWI,IAAS,CAAElK,QAAS,gBAAiB+J,WAAW,GACxEM,MAAMrK,GAAWtC,EAAKsC,SAEtBiB,KAAKO,KAAO,gBACZP,KAAKiJ,KAAOA,EACZjJ,KAAKkJ,QAAUzI,EAAQyI,SAAW,CAAA,EAClClJ,KAAK8I,UAAYrI,EAAQqI,WAAarM,EAAKqM,UAC3C9I,KAAKmJ,MAAQ1I,EAAQ0I,MACrBnJ,KAAK9C,UAAYC,KAAKC,MAGlB+B,MAAMkK,mBACNlK,MAAMkK,kBAAkBrJ,KAAMgJ,EAEtC,CASA,WAAO7E,CAAK8E,EAAMC,EAAU,IACxB,OAAO,IAAIF,EAAcC,OAAMnG,EAAW,CAAEoG,WAChD,CAUA,WAAOI,CAAKL,EAAME,EAAOD,EAAU,CAAA,GAC/B,OAAO,IAAIF,EAAcC,EAAME,EAAMpK,QAAS,CAAEoK,QAAOD,WAC3D,CAMA,MAAAK,GACI,MAAO,CACHhJ,KAAMP,KAAKO,KACX0I,KAAMjJ,KAAKiJ,KACXlK,QAASiB,KAAKjB,QACdmK,QAASlJ,KAAKkJ,QACdJ,UAAW9I,KAAK8I,UAChB5L,UAAW8C,KAAK9C,UAExB,CAMA,QAAAkB,GACI,MAAO,GAAG4B,KAAKO,SAASP,KAAKiJ,UAAUjJ,KAAKjB,SAChD,ECtTG,MAAMyK,UAAsB1J,EAE/B2J,GAAS,IAAIxJ,IAGbyJ,GAAc,EAGdC,GAAW,IAAI1J,IAGf2J,GAAajN,OAAOuD,OAAO,MAG3B2J,GAAelN,OAAOuD,OAAO,MAG7B4J,GAAW,GAKX,WAAA/J,GACIqJ,OACJ,CAiBA,OAAAW,CAAQrK,EAAQsK,EAAQvJ,EAAU,CAAA,GAC9B,GAAIT,MAAKyJ,EAAOzI,IAAItB,GAChB,MAAMsJ,EAAc7E,KAAKsC,EAAUI,YAAa,CAAEnH,WAGtD,GAAsB,mBAAXsK,EACP,MAAM,IAAItJ,UAAU,6BAIxB,MAAMC,EAAQ,CACVjB,SACAsK,SACAvN,KAAMgE,EAAQhE,MAAQ,CAAA,EACtBkD,OAAQc,EAAQd,QAAU,UAC1BsK,OAAQ9D,EAAWE,UACnB6D,YAAa/M,KAAKC,OAItB4C,MAAKyJ,EAAOxI,IAAIvB,EAAQiB,GACxBX,MAAK2J,EAAS1I,IAAIvB,EAAQ,GAG1BM,MAAK4J,EAAWlK,GAAUiB,EAC1BX,MAAK6J,EAAanK,GAAUsK,EAC5BhK,MAAK8J,EAASzI,KAAK3B,GAGnBM,KAAKsD,KAAK,aAAc,CAAE5D,SAAQjD,KAAMkE,EAAMlE,MAClD,CAQA,UAAA0N,CAAWzK,GACP,MAAM0K,EAAOpK,MAAK4J,EAAWlK,GAC7B,IAAK0K,EAAM,OAAO,EAGlBpK,MAAKyJ,EAAO1G,OAAOrD,GACnBM,MAAK2J,EAAS5G,OAAOrD,UAGdM,MAAK4J,EAAWlK,UAChBM,MAAK6J,EAAanK,GACzB,MAAM8C,EAAMxC,MAAK8J,EAASrH,QAAQ/C,GAMlC,OALY,IAAR8C,GAAYxC,MAAK8J,EAASrI,OAAOe,EAAK,GAG1CxC,KAAKsD,KAAK,eAAgB,CAAE5D,SAAQjD,KAAM2N,EAAK3N,QAExC,CACX,CAQA,OAAA4N,CAAQ3K,GAEJ,OAAOM,MAAK4J,EAAWlK,EAC3B,CAOA,UAAA4K,GAEI,OAAOtK,MAAK8J,EAASnF,OACzB,CAOA,aAAI4F,GACA,OAAOvK,MAAKyJ,EAAOe,IACvB,CAYA,KAAAC,CAAM1L,EAAS0B,EAAU,IACrB,MAAMiK,OAAEA,EAAMlO,QAAEA,GAAYuC,EAE5B,GAAI2L,EAEA,OAAO1K,MAAK2K,EAAcD,EAAQlO,GAC/B,CAEH,MAAMoO,EAAanK,EAAQoK,QACrBA,EAAUD,GAAYxJ,OAAS,IAAI0J,IAAIF,GAAc,KAC3D,OAAO5K,MAAK+K,EAAgBvO,EAASqO,EACzC,CACJ,CAWA,SAAAG,CAAUxO,EAASiE,EAAU,IAEzB,MAAMmK,EAAanK,EAAQoK,QACrBA,EAAUD,GAAYxJ,OAAS,IAAI0J,IAAIF,GAAc,KACrDK,EAAaxK,EAAQyK,QACrBA,EAAUD,GAAY7J,OAAS,IAAI0J,IAAIG,GAAc,KAE3D,IAAIE,EAAY,EAChB,MAAMC,EAAS,GAEf,IAAK,MAAO1L,EAAQ0K,KAASpK,MAAKyJ,EAE9B,IAAIoB,GAAS7J,IAAItB,MAGbwL,GAAYA,EAAQlK,IAAItB,KAGxB0K,EAAKH,SAAW9D,EAAWE,UAE/B,IACI,MAAMgF,EAAWrL,MAAKsL,EAAgB5L,EAAQlD,EAASmB,EAAYkI,WACnEuE,EAAKJ,OAAOqB,GACZF,GACJ,CAAE,MAAOzN,GAEL0N,EAAO/J,KAAK3B,EAChB,CAGJ,MAAO,CAAEjC,QAA2B,IAAlB2N,EAAOhK,OAAc+J,YAAWC,SACtD,CASA,WAAAG,CAAY7L,GACR,OAAOM,MAAK2J,EAASxI,IAAIzB,IAAW,CACxC,CAQA,aAAA8L,CAAc9L,EAAQuK,GAClB,MAAMG,EAAOpK,MAAK4J,EAAWlK,GACzB0K,IACAA,EAAKH,OAASA,EACdjK,KAAKsD,KAAK,cAAe,CAAE5D,SAAQuK,WAE3C,CAKA,UAAAwB,GAEI,MAAM3B,EAAU9J,MAAK8J,EAASnF,QAC9B,IAAK,MAAMjF,KAAUoK,EACjB9J,KAAKmK,WAAWzK,EAExB,CAUA,EAAAiL,CAAcjL,EAAQlD,GAClB,MAAM4N,EAAOpK,MAAK4J,EAAWlK,GAE7B,IAAK0K,EACD,MAAO,CACH3M,SAAS,EACT0N,UAAW,EACXC,OAAQ,CAAC1L,GACThC,MAAO+I,EAAUK,gBAIzB,GAAIsD,EAAKH,SAAW9D,EAAWE,UAC3B,MAAO,CACH5I,SAAS,EACT0N,UAAW,EACXC,OAAQ,CAAC1L,GACThC,MAAO+I,EAAUM,mBAIzB,IAGI,MAAM2E,EAAiBlP,GAAWA,EAAQmP,EACpCnP,EACAwD,MAAKsL,EAAgB5L,EAAQlD,EAASmB,EAAYwH,QAExD,OADAiF,EAAKJ,OAAO0B,GACL,CAAEjO,SAAS,EAAM0N,UAAW,EAAGC,OAAQ,GAClD,CAAE,MAAO1N,GAEL,MAAO,CAAED,SAAS,EAAO0N,UAAW,EAAGC,OAAQ,CAAC1L,GACpD,CACJ,CAMA,EAAAqL,CAAgBvO,EAASqO,GAErB,OAAO7K,KAAKgL,UAAUxO,EAASqO,EAAU,CAAEA,QAAS3G,MAAMC,KAAK0G,IAAa,CAAA,EAChF,CAMA,EAAAS,CAAgB5L,EAAQlD,EAASD,GAE7B,MAAMqP,GAAO5L,MAAK2J,EAASxI,IAAIzB,IAAW,GAAK,EAG/C,OAFAM,MAAK2J,EAAS1I,IAAIvB,EAAQkM,GAEnB,CACHlP,GAAI,UAASsD,MAAK0J,EAClBmC,EAAGtP,EACHuP,GAAI3O,KAAKC,MACTwO,MACAG,EAAGvP,EAEX,ECpSG,MAAMwP,EAETC,GAAW,IAAIhM,IAGfsC,GAAS5F,OAAOuD,OAAO,MAGvBgM,GAAkB,EAGlBC,GAGAC,GASA,WAAArM,CAAYU,EAAU,IAClBT,MAAKmM,EAAkB1L,EAAQ0L,gBAAkB,IACjDnM,MAAKoM,EAAc3L,EAAQ2L,YAAc,GAC7C,CAcA,MAAAlM,CAAOmM,EAAYC,EAAa7L,EAAU,CAAA,GAEtC,GAAIT,MAAKoM,EAAc,GAAKpM,MAAKiM,EAASzB,MAAQxK,MAAKoM,EACnD,MAAMpD,EAAc7E,KAAKsC,EAAU6B,YAAa,CAC5CiE,QAASvM,MAAKiM,EAASzB,KACvBgC,IAAKxM,MAAKoM,EACVC,aACAC,gBAIR,MAAMlP,EAAMD,KAAKC,MACXE,EAAY,SAAS0C,MAAKkM,KAAmB9O,IAC7CqP,EAAUhM,EAAQgM,SAAWzM,MAAKmM,GAClCzN,QAAEA,EAAOF,QAAEA,EAAOC,OAAEA,GAAWJ,IAG/B4N,EAAU,CACZvP,GAAIY,EACJ+O,aACAC,cACAI,UAAWtP,EACXqP,UACAjO,UACAC,SACAkO,aAAclM,EAAQkM,cAG1B3M,MAAKiM,EAAShL,IAAI3D,EAAW2O,GAC7BjM,MAAKuC,EAAOjF,GAAa2O,EAGzB,MAAMW,EAAiB/N,EAAYH,EAAS+N,GAASI,MAAMnP,IAEvD,GAAIJ,KAAa0C,MAAKuC,EAAQ,CAK1B,GAJAvC,MAAKiM,EAASlJ,OAAOzF,UACd0C,MAAKuC,EAAOjF,GAGf,iBAAkBmD,EAClB,OAAOA,EAAQkM,aAGnB,MAAM3D,EAAc7E,KAAKsC,EAAUW,iBAAkB,CACjD9J,YACA+O,aACAC,cACAG,WAER,CACA,MAAM/O,IAGV,MAAO,CAAEJ,YAAWoB,QAASkO,EACjC,CASA,OAAApO,CAAQlB,EAAWwP,GACf,MAAMb,EAAUjM,MAAKuC,EAAOjF,GAC5B,IAAK2O,EAAS,OAAO,EAMrB,GAHAjM,MAAKiM,EAASlJ,OAAOzF,UACd0C,MAAKuC,EAAOjF,GAEfwP,EAASrP,QACTwO,EAAQzN,QAAQsO,EAASvP,UACtB,CACH,MAAMG,EAAQsL,EAAc7E,KACxB2I,EAASpP,OAAOuL,MAAQxC,EAAUsB,cAClC,CACIzK,YACA+O,WAAYJ,EAAQI,WACpBC,YAAaL,EAAQK,YACrBS,cAAeD,EAASpP,QAGhCA,EAAMqB,QAAU+N,EAASpP,OAAOqB,SAAW,gBAC3CkN,EAAQxN,OAAOf,EACnB,CAEA,OAAO,CACX,CASA,MAAAe,CAAOnB,EAAWI,GACd,MAAMuO,EAAUjM,MAAKuC,EAAOjF,GAC5B,IAAK2O,EAAS,OAAO,EAGrBjM,MAAKiM,EAASlJ,OAAOzF,UACd0C,MAAKuC,EAAOjF,GAEnB,MAAM0P,EAAMtP,aAAiByB,MAAQzB,EAAQ,IAAIyB,MAAMzB,GAGvD,OAFAuO,EAAQxN,OAAOuO,IAER,CACX,CAQA,MAAAC,CAAO3P,GACH,MAAM2O,EAAUjM,MAAKuC,EAAOjF,GAC5B,QAAK2O,IAGLjM,MAAKiM,EAASlJ,OAAOzF,UACd0C,MAAKuC,EAAOjF,GACnB2O,EAAQxN,OAAO,IAAIU,MAAM,uBAElB,EACX,CASA,aAAA+N,CAAcxN,GACV,IAAIyN,EAAQ,EAEZ,IAAK,MAAO7P,EAAW2O,KAAYjM,MAAKiM,EAChCA,EAAQI,aAAe3M,IACvBM,MAAKiM,EAASlJ,OAAOzF,UACd0C,MAAKuC,EAAOjF,GACnB2O,EAAQxN,OAAOuK,EAAc7E,KAAKsC,EAAUM,kBAAmB,CAC3DrH,SACApC,eAEJ6P,KAIR,OAAOA,CACX,CAOA,SAAAC,GACI,MAAMD,EAAQnN,MAAKiM,EAASzB,KAE5B,IAAK,MAAOlN,EAAW2O,KAAYjM,MAAKiM,EACpCA,EAAQxN,OAAO,IAAIU,MAAM,2BAG7Ba,MAAKiM,EAAS5H,QAEd,IAAK,MAAMC,KAAOtE,MAAKuC,SACZvC,MAAKuC,EAAO+B,GAEvB,OAAO6I,CACX,CAQA,GAAAnM,CAAI1D,GAEA,OAAOA,KAAa0C,MAAKuC,CAC7B,CAQA,GAAApB,CAAI7D,GAEA,OAAO0C,MAAKuC,EAAOjF,EACvB,CAMA,QAAIkN,GACA,OAAOxK,MAAKiM,EAASzB,IACzB,CAMA,aAAA6C,GACI,OAAOnJ,MAAMC,KAAKnE,MAAKiM,EAAS7H,OACpC,CAQA,UAAAkJ,CAAW5N,GACP,MAAM6N,EAAW,GACjB,IAAK,MAAMtB,KAAWjM,MAAKiM,EAASuB,SAC5BvB,EAAQI,aAAe3M,GACvB6N,EAASlM,KAAK4K,GAGtB,OAAOsB,CACX,EC7QG,MAAME,EAETC,GAGAjR,GAGAkR,GAGAlB,GAGAmB,GAAqB,IAAI3N,IAOzB,WAAAF,CAAY8N,EAAS,IACjB7N,MAAK0N,EAAeG,EAAOnO,QAAU5B,IACrCkC,MAAKvD,EAAQoR,EAAOpR,MAAQ,CAAA,EAC5BuD,MAAK2N,EAAgBE,EAAOF,cAAgB,GAC5C3N,MAAKyM,EAAWoB,EAAOpB,SAAW,GACtC,CAMA,UAAI/M,GACA,OAAOM,MAAK0N,CAChB,CAOA,iBAAAI,GACI,MAAO,CACHvR,KAAMoB,EAAY4H,eAClBwI,YAAajQ,IACb4B,OAAQM,MAAK0N,EACbjR,KAAMuD,MAAKvD,EACXkR,aAAc3N,MAAK2N,EACnBzQ,UAAWC,KAAKC,MAExB,CAUA,gBAAA4Q,CAAiBC,EAAaC,EAAQC,GAClC,MAAO,CACH5R,KAAMoB,EAAY6H,cAClBuI,YAAaE,EAAYF,YACzBrO,OAAQM,MAAK0N,EACbjR,KAAMuD,MAAKvD,EACXkR,aAAc3N,MAAK2N,EACnBO,SACAC,OAAQD,OAASpL,EAAYqL,EAC7BjR,UAAWC,KAAKC,MAExB,CAQA,qBAAAgR,CAAsBL,GAClB,MAAO,CACHxR,KAAMoB,EAAY8H,mBAClBsI,cACAM,WAAW,EACXnR,UAAWC,KAAKC,MAExB,CAQA,cAAMkR,CAAStE,GACX,MAAMuE,EAAUvO,KAAK8N,qBACfpP,QAAEA,EAAOF,QAAEA,EAAOC,OAAEA,GAAWJ,IAGrC2B,MAAK4N,EAAmB3M,IAAIsN,EAAQR,YAAa,CAC7CS,MAAO1I,EAAeE,UACtBxH,UACAC,SACA8P,UACAE,UAAWtR,KAAKC,QAIpB4M,EAAOuE,GAGP,IAEI,aADqB1P,EAAYH,EAASsB,MAAKyM,EAEnD,CAAE,MAA0B/O,GAGxB,OAFAsC,MAAK4N,EAAmB7K,OAAOwL,EAAQR,aAEnCrQ,EAAMuL,OAASxC,EAAUC,kBAClB,CACHjJ,SAAS,EACTC,MAAO+I,EAAUC,kBACjByH,OAAQ,2BAA2BnO,MAAKyM,OAIzC,CACHhP,SAAS,EACTC,MAAO+I,EAAUE,mBACjBwH,OAAQzQ,EAAMqB,QAEtB,CACJ,CAWA,aAAA2P,CAAc3P,EAASY,EAAQqK,EAAQ2E,GACnC,OAAQ5P,EAAQxC,MACZ,KAAKoB,EAAY4H,eACb,OAAOvF,MAAK4O,EAAY7P,EAASY,EAAQqK,EAAQ2E,GAErD,KAAKhR,EAAY6H,cACb,OAAOxF,MAAK6O,EAAW9P,EAASY,EAAQqK,GAE5C,KAAKrM,EAAY8H,mBACb,OAAOzF,MAAK8O,EAAgB/P,EAASY,GAEzC,QACI,OAAO,KAEnB,CAQA,UAAAoP,CAAWhB,GACP,OAAO/N,MAAK4N,EAAmB5M,IAAI+M,EACvC,CAOA,MAAAd,CAAOc,GACH,MAAM9B,EAAUjM,MAAK4N,EAAmBzM,IAAI4M,GACxC9B,IACAA,EAAQxN,OAAO,IAAIU,MAAM,wBACzBa,MAAK4N,EAAmB7K,OAAOgL,GAEvC,CAKA,SAAAX,GACI,IAAK,MAAO1Q,EAAIuP,KAAYjM,MAAK4N,EAC7B3B,EAAQxN,OAAO,IAAIU,MAAM,6BAE7Ba,MAAK4N,EAAmBvJ,OAC5B,CAUA,EAAAuK,CAAY7P,EAASY,EAAQqK,EAAQ2E,GAEjC,OAAIA,IAAeA,EAAW5P,EAASY,IAEnCqK,EADYhK,KAAKgO,iBAAiBjP,GAAS,EAAO,sBAE3C,OAKXiL,EADYhK,KAAKgO,iBAAiBjP,GAAS,IAI3CiB,MAAK4N,EAAmB3M,IAAIlC,EAAQgP,YAAa,CAC7CS,MAAO1I,EAAeG,SACtB+I,WAAY,CACRtP,OAAQX,EAAQW,OAChBC,SACAlD,KAAMsC,EAAQtC,KACdkR,aAAc5O,EAAQ4O,gBAIvB,KACX,CAMA,EAAAkB,CAAW9P,EAASY,EAAQqK,GACxB,MAAMiC,EAAUjM,MAAK4N,EAAmBzM,IAAIpC,EAAQgP,aACpD,IAAK9B,EACD,OAAO,KAGX,IAAKlN,EAAQmP,OAIT,OAFAjC,EAAQxN,OAAO,IAAIU,MAAMJ,EAAQoP,QAAU,wBAC3CnO,MAAK4N,EAAmB7K,OAAOhE,EAAQgP,aAChC,KAKX/D,EADiBhK,KAAKoO,sBAAsBrP,EAAQgP,cAIpD,MAAMkB,EAAW,CACbvP,OAAQX,EAAQW,OAChBC,SACAlD,KAAMsC,EAAQtC,KACdkR,aAAc5O,EAAQ4O,aACtBpR,KAAM,UACN2N,YAAa/M,KAAKC,OAUtB,OANA6O,EAAQzN,QAAQ,CACZf,SAAS,EACT2M,KAAM6E,IAGVjP,MAAK4N,EAAmB7K,OAAOhE,EAAQgP,aAChCkB,CACX,CAMA,EAAAH,CAAgB/P,EAASY,GACrB,MAAMsM,EAAUjM,MAAK4N,EAAmBzM,IAAIpC,EAAQgP,aACpD,IAAK9B,GAAWA,EAAQuC,QAAU1I,EAAeG,SAC7C,OAAO,KAGX,IAAKlH,EAAQsP,UAET,OADArO,MAAK4N,EAAmB7K,OAAOhE,EAAQgP,aAChC,KAIX,MAAMkB,EAAW,IACVhD,EAAQ+C,WACX9E,YAAa/M,KAAKC,OAItB,OADA4C,MAAK4N,EAAmB7K,OAAOhE,EAAQgP,aAChCkB,CACX,EC3TG,MAAMC,EAETC,GAAgB,IAAIrE,IAGpBsE,GAAY,GAGZC,IAAY,EAGZC,GAOA,WAAAvP,CAAYU,EAAU,IAKlB,GAJAT,MAAKqP,EAAY5O,EAAQ4O,WAAY,EACrCrP,MAAKsP,EAAc1P,WAAWC,UAAUF,OAGpCc,EAAQ8O,QACR,IAAK,MAAM5P,KAAUc,EAAQ8O,QACzBvP,MAAKwP,EAAW7P,EAG5B,CAYA,SAAA8P,CAAU9P,GAEN,GAAIK,MAAKqP,EACL,OAAO,EAIX,GAAe,SAAX1P,GAAgC,OAAXA,EACrB,OAAOK,MAAKmP,EAAcnO,IAAI,QAIlC,GAAgC,IAA5BhB,MAAKmP,EAAc3E,MAAwC,IAA1BxK,MAAKoP,EAAUhO,OAChD,OAAOzB,IAAWK,MAAKsP,EAI3B,GAAItP,MAAKmP,EAAcnO,IAAIrB,GACvB,OAAO,EAIX,IAAK,MAAM+P,KAAW1P,MAAKoP,EACvB,GAAIM,EAAQC,KAAKhQ,GACb,OAAO,EAIf,OAAO,CACX,CAQA,KAAAiQ,CAAMjQ,GAEF,OADAK,MAAKwP,EAAW7P,GACTK,IACX,CAQA,QAAA6P,CAASlQ,GAEL,QAAIK,MAAKmP,EAAcnO,IAAIrB,KACvBK,MAAKmP,EAAcpM,OAAOpD,IACnB,EAMf,CAOA,UAAAmQ,GACI,OAAO5L,MAAMC,KAAKnE,MAAKmP,EAC3B,CAKA,KAAA9K,GACIrE,MAAKmP,EAAc9K,QACnBrE,MAAKoP,EAAY,EACrB,CAMA,cAAIE,GACA,OAAOtP,MAAKsP,CAChB,CAWA,EAAAE,CAAW7P,GACP,GAAsB,iBAAXA,EACP,MAAM,IAAIe,UAAU,2BAIxB,GAAe,MAAXf,EAMJ,GAAIA,EAAOoQ,SAAS,KAAM,CACtB,MAAML,EAAU1P,MAAKgQ,EAAerQ,GACpCK,MAAKoP,EAAU/N,KAAKqO,EACxB,MAEI1P,MAAKmP,EAAcc,IAAItQ,QAVvBK,MAAKqP,GAAY,CAYzB,CASA,EAAAW,CAAeN,GAEX,MAAMQ,EAAUR,EACX3R,QAAQ,qBAAsB,QAG9BA,QAAQ,MAAO,wBAEpB,OAAO,IAAIoS,OAAO,IAAID,KAC1B,EC/EG,MAAME,UAAiBtQ,EAE1BJ,GAGA2Q,GAGAC,GAGAC,GAGAC,GAGAC,GAGAC,GAGAC,GAAY,IAAI1Q,IAGhB2Q,GAAgB,GAGhBC,GAAiB,GAGjBpU,GAGAkR,GAGAmD,GAGAC,GAGAC,GAGAC,GAGAC,GAAqB,IAAIjR,IAGzBkR,GAAkB,IAAIlR,IAGtBmR,IAAS,EAGTC,GAAe,aAGf3E,GAGA4E,IAAa,EAOb,WAAAvR,CAAYU,EAAU,IAClB2I,QAEApJ,MAAKN,EAAUe,EAAQf,QAAU5B,IACjCkC,MAAKqQ,EAAS5P,EAAQ4P,QAAS,EAC/BrQ,MAAKvD,EAAQgE,EAAQhE,MAAQ,CAAA,EAC7BuD,MAAK2N,EAAgBlN,EAAQkN,cAAgB,GAC7C3N,MAAK8Q,EAAkBrQ,EAAQqQ,gBAAkB,IAGjD9Q,MAAKsQ,EAAU,IAAI9G,EACnBxJ,MAAKuQ,EAAmB,IAAIvE,EAAgB,CACxCG,eAAgBnM,MAAK8Q,IAEzB9Q,MAAKwQ,EAAa,IAAI/C,EAAU,CAC5B/N,OAAQM,MAAKN,EACbjD,KAAMuD,MAAKvD,EACXkR,aAAc3N,MAAK2N,EACnBlB,QAAShM,EAAQ8Q,kBAAoB,MAEzCvR,MAAKyQ,EAAmB,IAAIvB,EAAgB,CACxCK,QAAS9O,EAAQ+Q,gBAAkB,KAIvCxR,MAAK0Q,EAAejQ,EAAQiQ,aAAe,mBAI3C1Q,MAAK+Q,EAAkBtQ,EAAQsQ,gBAAkB,QACjD/Q,MAAKgR,EAAsBvQ,EAAQuQ,oBAAsB,IACzDhR,MAAKiR,EAAcxQ,EAAQwQ,aAAc,EAGzCjR,MAAKoR,EAAS3Q,EAAQ2Q,QAAS,EAC/BpR,MAAKqR,EAAe5Q,EAAQ4Q,aAAe,aAC3CrR,MAAK0M,EAAavP,KAAKC,MAGvB4C,MAAKyR,EAAsBhR,GAG3BT,MAAK2N,EAActM,KAAK,cAAcrB,MAAK0Q,KAG3C1Q,MAAKsQ,EAAQhQ,GAAG,aAAeqB,IAAQ3B,KAAKsD,KAAK,iBAAkB3B,EAAEpE,QACrEyC,MAAKsQ,EAAQhQ,GAAG,eAAiBqB,IAAQ3B,KAAKsD,KAAK,oBAAqB3B,EAAEpE,QAC1EyC,MAAKsQ,EAAQhQ,GAAG,cAAgBqB,IAAQ3B,KAAKsD,KAAK,cAAe3B,EAAEpE,QAE/DyC,MAAKoR,GACLpR,MAAK0R,EAAK,OAAQ,uBAAuB1R,MAAKqQ,KAEtD,CAMA,UAAI3Q,GACA,OAAOM,MAAKN,CAChB,CAMA,SAAI2Q,GACA,OAAOrQ,MAAKqQ,CAChB,CAMA,aAAI9F,GACA,OAAOvK,MAAKsQ,EAAQ/F,SACxB,CAMA,SAAId,GACA,OAAOzJ,MAAKsQ,EAAQhG,YACxB,CAQA,OAAAD,CAAQ3K,GACJ,OAAOM,MAAKsQ,EAAQjG,QAAQ3K,EAChC,CAkBA,YAAMqB,CAAOe,EAAYtF,EAASiE,EAAU,CAAA,GACxCT,MAAK2R,IAGL,MAMM5S,ETrNP,EAA6BwB,EAAMhD,EAAMC,EAAcoU,EAAa,OAClEtV,EAAcqB,EAAYwH,OAAQ,CACvC5E,OACAhD,OACAM,OAAQL,EACRqU,KAAMD,ISgNcE,CACZhQ,QAP6B9B,MAAK+R,EAClC/R,MAAK6Q,EACLrU,EACA,CAAED,KAAM,SAAUyV,UAAW,aAM7BhS,MAAKN,GAGHuS,QAAejS,MAAKsQ,EAAQtF,UAAUjM,EAAS0B,GAIrD,OAFAT,MAAK0R,EAAK,MAAO,WAAW5P,SAAkBmQ,EAAO9G,mBAE9C8G,CACX,CAcA,aAAMC,CAAQxS,EAAQ4M,EAAa9P,EAASiE,EAAU,CAAA,GAMlD,GALAT,MAAK2R,IAEL3R,MAAK0R,EAAK,MAAO,YAAYpF,SAAmB5M,MAEnCM,MAAKsQ,EAAQjG,QAAQ3K,GAE9B,MAAMsJ,EAAc7E,KAAKsC,EAAUK,eAAgB,CAAEpH,WAIzD,MAAMpC,UAAEA,EAASoB,QAAEA,GAAYsB,MAAKuQ,EAAiBrQ,OACjDR,EACA4M,EACA,CAAEG,QAAShM,EAAQgM,SAAWzM,MAAK8Q,IAWjC/R,ETlLP,EAA8BwB,EAAMhD,EAAMC,EAAcoU,EAAYlV,EAAK,OACvEJ,EAAcqB,EAAYyH,QAAS,CACxC7E,OACAhD,OACAM,OAAQL,EACRqU,KAAMD,GACL,CAAA,EAAIlV,GS4KeyV,CACZ7F,QAR6BtM,MAAK+R,EAClC/R,MAAK6Q,EACLrU,EACA,CAAED,KAAM,UAAWmD,SAAQ4M,cAAa0F,UAAW,aAOnDhS,MAAKN,EACLA,EACApC,GAMJ,IAFe0C,MAAKsQ,EAAQ7F,MAAM,CAAEC,OAAQhL,EAAQlD,QAASuC,IAEjDtB,QAER,MADAuC,MAAKuQ,EAAiBtD,OAAO3P,GACvB0L,EAAc7E,KAAKsC,EAAUyB,YAAa,CAAExI,WAGtD,OAAOhB,CACX,CAgBA,sBAAM0T,CAAiB9F,EAAa9P,EAASiE,EAAU,CAAA,GACnDT,MAAK2R,IAEL,MAAMlF,EAAUhM,EAAQgM,SAAWzM,MAAK8Q,EAClCuB,EAAe5R,EAAQ4R,eAAgB,EACvCxH,EAAU,IAAIC,IAAIrK,EAAQoK,SAAW,IAErC9F,EAAU,IAAI9E,IACdqS,EAAW,GAEjB,IAAK,MAAM5S,KAAUM,MAAKsQ,EAAQhG,aAAc,CAC5C,GAAIO,EAAQ7J,IAAItB,GAAS,SAEzB,MAAM6S,EAAiBvS,KAAKkS,QAAQxS,EAAQ4M,EAAa9P,EAAS,CAAEiQ,YAC/D9I,KAAKmJ,IACF/H,EAAQ9D,IAAIvB,EAAQ,CAAEjC,SAAS,EAAMF,KAAMuP,MAE9CD,MAAMnP,IACH,IAAI2U,EAGA,MAAM3U,EAFNqH,EAAQ9D,IAAIvB,EAAQ,CAAEjC,SAAS,EAAOC,MAAOA,EAAMqB,YAM/DuT,EAASjR,KAAKkR,EAClB,CAGA,aADMjU,QAAQkU,IAAIF,GACXvN,CACX,CA2BA,MAAA0N,CAAOnG,EAAa9L,EAASC,EAAU,CAAA,GACnC,GAAIT,MAAK2Q,EAAU3P,IAAIsL,GACnB,MAAMtD,EAAc7E,KAAKsC,EAAUwB,eAAgB,CAAEqE,gBAUzD,OANI7L,EAAQiS,cAAgBjS,EAAQkS,WAAalS,EAAQmS,kBACrD5S,MAAKmR,EAAgBlQ,IAAIqL,EAAa7L,GAG1CT,MAAK2Q,EAAU1P,IAAIqL,EAAa9L,GAEzB,KACHR,MAAK2Q,EAAU5N,OAAOuJ,GACtBtM,MAAKmR,EAAgBpO,OAAOuJ,GAEpC,CAQA,QAAAuG,CAASvG,GACL,OAAOtM,MAAK2Q,EAAU5N,OAAOuJ,EACjC,CAQA,UAAAwG,CAAWxG,GACP,OAAOtM,MAAK2Q,EAAU3P,IAAIsL,EAC9B,CAmBA,cAAAyG,CAAeC,EAAQpS,EAAW,IAC9B,GAAsB,mBAAXoS,EACP,MAAM,IAAItS,UAAU,6BAOxB,OAHAV,MAAK4Q,EAAcvP,KADL,CAAE4R,GAAID,EAAQpS,aAE5BZ,MAAK4Q,EAAc5L,KAAK,CAACC,EAAGC,IAAMD,EAAErE,SAAWsE,EAAEtE,UAE1C,IAAMZ,KAAKkT,kBAAkBF,EACxC,CAeA,eAAAG,CAAgBH,EAAQpS,EAAW,IAC/B,GAAsB,mBAAXoS,EACP,MAAM,IAAItS,UAAU,6BAOxB,OAHAV,MAAK6Q,EAAexP,KADN,CAAE4R,GAAID,EAAQpS,aAE5BZ,MAAK6Q,EAAe7L,KAAK,CAACC,EAAGC,IAAMD,EAAErE,SAAWsE,EAAEtE,UAE3C,IAAMZ,KAAKoT,mBAAmBJ,EACzC,CAQA,iBAAAE,CAAkBF,GACd,MAAMK,EAAQrT,MAAK4Q,EAAclO,UAAUf,GAAKA,EAAEsR,KAAOD,GACzD,OAAc,IAAVK,IACArT,MAAK4Q,EAAcnP,OAAO4R,EAAO,IAC1B,EAGf,CAQA,kBAAAD,CAAmBJ,GACf,MAAMK,EAAQrT,MAAK6Q,EAAenO,UAAUf,GAAKA,EAAEsR,KAAOD,GAC1D,OAAc,IAAVK,IACArT,MAAK6Q,EAAepP,OAAO4R,EAAO,IAC3B,EAGf,CAcA,OAAAtJ,CAAQrK,EAAQsK,EAAQvJ,EAAU,CAAA,GAC9BT,MAAK2R,IACL3R,MAAKsQ,EAAQvG,QAAQrK,EAAQsK,EAAQvJ,EACzC,CAQA,UAAA0J,CAAWzK,GAEP,OADAM,MAAKuQ,EAAiBrD,cAAcxN,GAC7BM,MAAKsQ,EAAQnG,WAAWzK,EACnC,CAsBA,YAAA4T,CAAaC,EAAW9S,EAAU,IAG9B,GAFAT,MAAK2R,KAEA4B,GAAuC,mBAAnBA,EAAUC,KAC/B,MAAM,IAAI9S,UAAU,uCAGxB,MAAMhB,EAASe,EAAQf,QAAU6T,EAAU7T,QAAU,aAAa5B,MAC5D6B,EAASc,EAAQd,QAAU,IAejC,MAZmC,mBAAxB4T,EAAUE,WACjBF,EAAUE,UAAW1U,IACjBiB,KAAK0O,cAAc3P,EAASY,EAAQD,KAK5CM,KAAK+J,QAAQrK,EAASX,IAClBwU,EAAUC,KAAKzU,IAChB0B,GAGI,KACHT,KAAKmK,WAAWzK,GACiB,mBAAtB6T,EAAUG,SACjBH,EAAUG,UAGtB,CAWA,mBAAMhF,CAAc3P,EAASY,EAAQD,EAAQiU,GACzC,GAAI3T,MAAKsR,EAAY,OAGrB,IAAKtR,MAAKyQ,EAAiBhB,UAAU9P,GAEjC,OAMJ,MACMiU,EAAU7U,EAAQxC,MAAQwC,EAAQ8M,EAGxC,IAAIgI,EAAgB9U,EAAQyB,SAAWzB,EAAQwB,KAC3CuT,EALe/U,EAAQvC,SAAWuC,EAAQxB,MAAQwB,EAAQgN,EAQ9D,GAAIhN,EAAQvC,SAAsC,iBAApBuC,EAAQvC,UAAyBuC,EAAQgN,EAC/D6H,IAAYjW,EAAYwH,QAAUyO,IAAYjW,EAAYkI,WAGnD+N,IAAYjW,EAAYyH,SAF/ByO,EAAgB9U,EAAQvC,QAAQ+D,KAChCuT,EAAc/U,EAAQvC,QAAQe,MAIvBqW,IAAYjW,EAAYC,WAE/BkW,EAAc/U,EAAQvC,QAAQe,WAMjC,GAAIwB,EAAQ8M,IAAM9M,EAAQxC,MAAQwC,EAAQgN,GAA0B,iBAAdhN,EAAQgN,GAAkBhN,EAAQgN,EAAEvP,QAAS,CACpG,MAAMuX,EAAWhV,EAAQgN,EAEzB8H,EAAgBE,EAASvX,QAAQ+D,MAAQwT,EAASxT,KAClDuT,EAAcC,EAASvX,QAAQe,MAAQwW,EAASxW,IACpD,CAEA,QAAoBuF,IAAhBgR,EAA2B,CAC3B,MAAME,EAAc,CAChBzX,KAAMqX,IAAYjW,EAAYwH,OAAS,SACnCyO,IAAYjW,EAAYyH,QAAU,UAAY,WAClD1F,SACA4M,YAAauH,EACb7B,UAAW,WAGf8B,QAAoB9T,MAAK+R,EAAU/R,MAAK4Q,EAAekD,EAAaE,EACxE,CAEA,OAAQJ,GACJ,KAAKjW,EAAYkI,UACjB,KAAKlI,EAAYwH,OACb,GAA6B,iBAAlB0O,EAEP,aAEE7T,MAAKiU,GAAcJ,EAAeC,EAAapU,GACrD,MAEJ,KAAK/B,EAAYyH,QACb,GAA6B,iBAAlByO,EAEP,aAME7T,MAAKkU,GAAenV,EAAQrC,GAAImX,EAAeC,EAAapU,EAAQiU,GAC1E,MAEJ,KAAKhW,EAAYC,SAAU,CACvB,IAAIH,EAAUsB,EAAQtB,QAClBC,EAAQqB,EAAQrB,MAGhBqB,EAAQvC,cAAuCsG,IAA5B/D,EAAQvC,QAAQiB,UACnCA,EAAUsB,EAAQvC,QAAQiB,QAC1BC,EAAQqB,EAAQvC,QAAQkB,OAI5BsC,MAAKmU,GAAgBpV,EAAQvC,SAASc,WAAayB,EAAQrC,GAAIe,EAASqW,EAAapW,GACrF,KACJ,CAEA,KAAKC,EAAY4H,eACjB,KAAK5H,EAAY6H,cACjB,KAAK7H,EAAY8H,mBACbzF,MAAKwQ,EAAW9B,cAAc3P,EAASY,EAAM,GAMzD,CASA,OAAA+T,GACQ1T,MAAKsR,IAETtR,MAAKsR,GAAa,EAGlBtR,MAAKuQ,EAAiBnD,YAGtBpN,MAAK2Q,EAAUtM,QAGfrE,MAAKsQ,EAAQ7E,aAGbzL,KAAKqE,QAELrE,KAAKsD,KAAK,YAAa,IAC3B,CAMA,eAAI8Q,GACA,OAAOpU,MAAKsR,CAChB,CAUA,QAAM2C,CAAc1T,EAAMhD,EAAMmC,SACtBM,KAAKsD,KAAK/C,EAAM,CAClB/D,QAASe,EACTM,OAAQ6B,GAEhB,CAMA,QAAMwU,CAAe5W,EAAWgP,EAAa/O,EAAMmC,EAAQiU,GACvD,MAAMnT,EAAUR,MAAK2Q,EAAUxP,IAAImL,GAEnC,IAAIQ,EAEJ,GAAKtM,EAWE,CAEH,MAAM6T,EAAgBrU,MAAKsU,GAAsBhI,EAAa5M,EAAQnC,GACtE,GAAK8W,EAAc9E,QAYf,IACI,MAAM0C,QAAezR,EAAQjD,EAAM,CAC/BmC,SACApC,UAAWA,EACXgP,YAAaA,IAUjBQ,EAAWzP,EACPC,QAP4B0C,MAAK+R,EACjC/R,MAAK6Q,EACLoB,EACA,CAAE1V,KAAM,WAAYmD,SAAQ4M,YAAaA,EAAa0F,UAAW,aAMjEhS,MAAKN,GACL,EAER,CAAE,MAA0BhC,GACxBoP,EAAWzP,EACPC,EACA,KACA0C,MAAKN,GACL,EACA,CACIuJ,KAAMvL,EAAMuL,MAAQxC,EAAUsB,cAC9BhJ,QAASrB,EAAMqB,SAG3B,MA1CA+N,EAAWzP,EACPC,EACA,KACA0C,MAAKN,GACL,EACA,CACIuJ,KAAMoL,EAAc3W,OAAOuL,MAAQxC,EAAUkC,aAC7C5J,QAASsV,EAAc3W,OAAOqB,SAAW,yBAqCzD,MA1DI+N,EAAWzP,EACPC,EACA,KACA0C,MAAKN,GACL,EACA,CACIuJ,KAAMxC,EAAUqB,WAChB/I,QAAS,sBAsDjB4U,EACAA,EAAQ7G,GACDpN,GACPM,MAAKsQ,EAAQ7F,MAAM,CAAEC,OAAQhL,EAAQlD,QAASsQ,GAEtD,CAMA,GAAAqH,CAAgB7W,EAAWG,EAASF,EAAMG,GACtCsC,MAAKuQ,EAAiB/R,QAAQlB,EAAW,CACrCA,YACAG,UACAF,OACAG,SAER,CAMA,EAAAiU,GACI,GAAI3R,MAAKsR,EACL,MAAMtI,EAAc7E,KAAKsC,EAAU8B,UAAW,CAC1CgM,QAAS,sBAGrB,CAMA,OAAMxC,CAAUyC,EAAOhY,EAAS+X,GAC5B,IAAIhI,EAAU/P,EACd,IAAK,MAAMyW,GAAEA,KAAQuB,EACjB,IACIjI,QAAgB0G,EAAG1G,EAASgI,EAChC,CAAE,MAAO7W,GAGT,CAEJ,OAAO6O,CACX,CAUA,EAAAkF,CAAsBhR,GAMlB,IAJiC,oBAAZgU,QACW,eAA1BA,QAAQC,KAAKC,SACK,oBAAXC,QAAwD,cAA9BA,OAAO/U,UAAUgV,WAgBpDpU,EAAQ+Q,gBAAgBzB,SAAS,MAW7B/P,MAAKiR,EACL,MAAM,IAAI9R,MACN,uFAKhB,CASA,GAAAmV,CAAsBhI,EAAa5M,EAAQlD,GACvC,MAAMiE,EAAUT,MAAKmR,EAAgBhQ,IAAImL,GACzC,IAAK7L,EACD,MAAO,CAAE8O,SAAS,GAItB,GAAI9O,EAAQiS,eAAiBjS,EAAQiS,aAAa3C,SAASrQ,GACvD,MAAO,CACH6P,SAAS,EACT7R,MAAOsL,EAAc7E,KAAKsC,EAAUkC,aAAc,CAC9CnI,QAAS8L,EACTlC,KAAM1K,EACNgT,aAAcjS,EAAQiS,gBAMlC,GAAIjS,EAAQkS,YAEH3S,MAAK8U,GADO,GAAGxI,KAAe5M,IACCe,EAAQkS,WACxC,MAAO,CACHpD,SAAS,EACT7R,MAAOsL,EAAc7E,KAAKsC,EAAUiC,aAAc,CAC9ClI,QAAS8L,EACTlC,KAAM1K,EACNqV,MAAOtU,EAAQkS,aAO/B,GAAIlS,EAAQmS,gBACR,IAEI,IADgBnS,EAAQmS,gBAAgBpW,GAEpC,MAAO,CACH+S,SAAS,EACT7R,MAAOsL,EAAc7E,KAAKsC,EAAUmC,gBAAiB,CACjDpI,QAAS8L,IAIzB,CAAE,MAA0B3K,GACxB,MAAO,CACH4N,SAAS,EACT7R,MAAOsL,EAAc7E,KAAKsC,EAAUmC,gBAAiB,CACjDpI,QAAS8L,EACT6B,OAAQxM,GAAG5C,SAAW,qBAGlC,CAGJ,MAAO,CAAEwQ,SAAS,EACtB,CAQA,GAAAuF,CAAgBxQ,EAAK0Q,GACjB,MAAM5X,EAAMD,KAAKC,MACX6X,EAAUjV,MAAKkR,EAAmB/P,IAAImD,GAE5C,OAAK2Q,GAAW7X,GAAO6X,EAAQC,SAE3BlV,MAAKkR,EAAmBjQ,IAAIqD,EAAK,CAC7B6I,MAAO,EACP+H,QAAS9X,EAAM,OAEZ,KAGP6X,EAAQ9H,OAAS6H,IAIrBC,EAAQ9H,QACD,GACX,CAQA,kBAAI4D,GACA,OAAO/Q,MAAK+Q,CAChB,CAMA,cAAIE,GACA,OAAOjR,MAAKiR,CAChB,CAMA,SAAIG,GACA,OAAOpR,MAAKoR,CAChB,CAMA,UAAI+D,GACA,OAAOhY,KAAKC,MAAQ4C,MAAK0M,CAC7B,CAWA,EAAAgF,CAAKnV,EAAMwC,GACFiB,MAAKoR,CASd,CAuBA,WAAAgE,GACI,MAAMtL,EAAU9J,MAAKsQ,EAAQhG,aACvB+K,EAAiBvL,EAAQ1I,OAG/B,IAQIkU,EARArL,EAAS,UASb,GARIjK,MAAKsR,EACLrH,EAAS,YACiB,IAAnBoL,GAAwBrV,MAAKqQ,IACpCpG,EAAS,YAKU,oBAAZwK,SAA2BA,QAAQc,YAC1C,IACI,MAAMC,EAAMf,QAAQc,cACpBD,EAAS,CACLG,SAAUD,EAAIC,SACdC,UAAWF,EAAIE,UACfC,IAAKH,EAAIG,IAEjB,CAAE,MAEF,CAGJ,MAAO,CACH1L,SACAvK,OAAQM,MAAKN,EACb2Q,MAAOrQ,MAAKqQ,EACZ8E,OAAQnV,KAAKmV,OACb1L,MAAO,CACHmM,MAAOP,EACPQ,IAAK/L,GAET6G,SAAUzM,MAAMC,KAAKnE,MAAK2Q,EAAUvM,QACpCmM,gBAAiBvQ,MAAKuQ,EAAiB/F,MAAQ,EAC/C8G,UAAWtR,MAAKsR,KACZgE,GAAU,CAAEA,UAExB,CA4BA,mBAAOQ,CAAarV,EAAU,IAC1B,IAAKA,EAAQ+Q,gBAAoD,IAAlC/Q,EAAQ+Q,eAAepQ,OAClD,MAAM,IAAIjC,MACN,yHAKR,GAAIsB,EAAQ+Q,eAAezB,SAAS,KAChC,MAAM,IAAI5Q,MACN,kHAKR,OAAO,IAAIiR,EAAS,CAChBa,YAAY,EACZF,eAAgB,QAChBC,mBAAoB,IACpBF,eAAgB,OACbrQ,GAEX,CAmBA,QAAAsV,GACI,MAAMC,EAAS,GACTC,EAAc,GACdC,EAAW,GAGjB,GAAIlW,MAAKsR,EAGL,OAFA0E,EAAO3U,KAAK,yBACZ4U,EAAY5U,KAAK,kCACV,CAAE4I,OAAQ,QAAS+L,SAAQC,cAAaC,YAInD,MAAM3L,EAAYvK,MAAKsQ,EAAQhG,aAAalJ,OAC1B,IAAdmJ,IACIvK,MAAKqQ,GACL6F,EAAS7U,KAAK,8BACd4U,EAAY5U,KAAK,sEAEjB2U,EAAO3U,KAAK,gCACZ4U,EAAY5U,KAAK,qFAKzB,MAAM8U,EAAenW,MAAK2Q,EAAUnG,KAChCxK,MAAKqQ,GAA2B,IAAjB8F,IACfD,EAAS7U,KAAK,kCACd4U,EAAY5U,KAAK,kDAIrB,MAAM+U,EAAepW,MAAKuQ,EAAiB/F,MAAQ,EAC/C4L,EAA0C,GAA3BpW,MAAKgR,IACpBkF,EAAS7U,KAAK,+BAA+B+U,KAAgBpW,MAAKgR,KAClEiF,EAAY5U,KAAK,sEAIhBrB,MAAKiR,IACNiF,EAAS7U,KAAK,0BACd4U,EAAY5U,KAAK,wEAIrB,IAAI4I,EAAS,UAOb,OANI+L,EAAO5U,OAAS,EAChB6I,EAAS,QACFiM,EAAS9U,OAAS,IACzB6I,EAAS,WAGN,CACHA,SACAvK,OAAQM,MAAKN,EACb2Q,MAAOrQ,MAAKqQ,EACZ9F,YACA4L,eACA5F,gBAAiB6F,EACjBjB,OAAQnV,KAAKmV,OACba,SACAE,WACAD,cAER"}