{"version":3,"file":"retry.min.js","sources":["../../src/common/utils.js","../../src/plugins/retry.js","../../src/common/errors.js"],"sourcesContent":["/**\n * @fileoverview Utility functions shared across modules.\n * @module common/utils\n */\n\n/**\n * Generates a UUID v4.\n * Uses crypto.randomUUID() when available, falls back to manual generation.\n * \n * @returns {string} UUID v4 string.\n */\nexport function uuid() {\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback for older browsers\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n\n/**\n * Checks if data can be structured cloned.\n * \n * @param {*} data - Data to check.\n * @returns {boolean} True if cloneable.\n */\nexport function isCloneable(data) {\n    if (data === null || data === undefined) return true;\n\n    const type = typeof data;\n\n    // Primitives are always cloneable\n    if (type === 'boolean' || type === 'number' || type === 'string') {\n        return true;\n    }\n\n    // Functions and symbols are not cloneable\n    if (type === 'function' || type === 'symbol') {\n        return false;\n    }\n\n    // Check for DOM nodes\n    if (typeof Node !== 'undefined' && data instanceof Node) {\n        return false;\n    }\n\n    // Check for WeakMap/WeakSet\n    if (data instanceof WeakMap || data instanceof WeakSet) {\n        return false;\n    }\n\n    // For objects/arrays, we'd need to recursively check\n    // For performance, we assume they're cloneable and let postMessage fail\n    return true;\n}\n\n/**\n * Creates a deferred promise (Promise.withResolvers polyfill).\n * Uses native Promise.withResolvers() when available (ES2024+).\n * \n * @template T\n * @returns {{promise: Promise<T>, resolve: (value: T) => void, reject: (reason: any) => void}}\n */\nexport function deferred() {\n    // Use native Promise.withResolvers if available (ES2024+, ~10x faster)\n    // @ts-ignore\n    if (typeof Promise.withResolvers === 'function') {\n        // @ts-ignore\n        return Promise.withResolvers();\n    }\n    // Fallback for older engines\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    // @ts-ignore\n    return { promise, resolve, reject };\n}\n\n/**\n * Creates a promise that resolves after a timeout.\n * \n * @param {number} ms - Timeout in milliseconds.\n * @param {AbortSignal} [signal] - Optional abort signal.\n * @returns {Promise<void>}\n */\nexport function sleep(ms, signal) {\n    return new Promise((resolve, reject) => {\n        if (signal?.aborted) {\n            reject(signal.reason ?? new Error('Aborted'));\n            return;\n        }\n\n        const timeoutId = setTimeout(resolve, ms);\n\n        if (signal) {\n            signal.addEventListener('abort', () => {\n                clearTimeout(timeoutId);\n                reject(signal.reason ?? new Error('Aborted'));\n            }, { once: true });\n        }\n    });\n}\n\n/**\n * Creates a promise that rejects after a timeout.\n * \n * @template T\n * @param {Promise<T>} promise - Promise to race against.\n * @param {number} ms - Timeout in milliseconds.\n * @param {string} [message='Operation timed out'] - Timeout error message.\n * @returns {Promise<T>}\n */\nexport function withTimeout(promise, ms, message = 'Operation timed out') {\n    return Promise.race([\n        promise,\n        new Promise((_, reject) => {\n            setTimeout(() => reject(new Error(message)), ms);\n        })\n    ]);\n}\n\n\n\n/**\n * Detects the type of a peer target.\n * \n * @param {*} target - Target to check.\n * @returns {'iframe'|'worker'|'sw'|'window'|'port'|'unknown'}\n */\nexport function detectPeerType(target) {\n    // MessagePort\n    if (target instanceof MessagePort) {\n        return 'port';\n    }\n\n    // Worker\n    if (typeof Worker !== 'undefined' && target instanceof Worker) {\n        return 'worker';\n    }\n\n    // ServiceWorker\n    if (typeof ServiceWorker !== 'undefined' && target instanceof ServiceWorker) {\n        return 'sw';\n    }\n\n    // Window (iframe or popup)\n    if (typeof Window !== 'undefined' && target instanceof Window) {\n        return 'window';\n    }\n\n    // HTMLIFrameElement\n    if (typeof HTMLIFrameElement !== 'undefined' && target instanceof HTMLIFrameElement) {\n        return 'iframe';\n    }\n\n    // DedicatedWorkerGlobalScope (inside worker)\n    if (typeof DedicatedWorkerGlobalScope !== 'undefined' &&\n        target instanceof DedicatedWorkerGlobalScope) {\n        return 'worker';\n    }\n\n    return 'unknown';\n}\n\n\n\n/**\n * Creates a frozen timestamp object.\n * \n * @returns {{timestamp: number, iso: string}}\n */\nexport function timestamp() {\n    const ts = Date.now();\n    return Object.freeze({\n        timestamp: ts,\n        iso: new Date(ts).toISOString()\n    });\n}\n\n\n","/**\n * @fileoverview Retry plugin with exponential backoff for CrossBus.\n * Provides automatic retry logic for failed requests.\n * @module plugins/retry\n */\n\nimport { CrossBusError, ErrorCode, isRetryable } from '../common/errors.js';\nimport { sleep } from '../common/utils.js';\n\n/**\n * @typedef {Object} RetryOptions\n * @property {number} [maxAttempts=3] - Maximum number of retry attempts.\n * @property {number} [baseDelay=100] - Base delay in ms.\n * @property {number} [maxDelay=5000] - Maximum delay in ms.\n * @property {number} [factor=2] - Exponential factor.\n * @property {boolean} [jitter=true] - Add randomness to delay.\n * @property {Function} [shouldRetry] - Custom retry condition.\n * @property {Function|null} [onRetry] - Callback on each retry.\n */\n\n/**\n * Default retry options.\n */\nexport const DEFAULT_RETRY_OPTIONS = {\n    maxAttempts: 3,\n    baseDelay: 100,\n    maxDelay: 5000,\n    factor: 2,\n    jitter: true,\n    shouldRetry: (error) => isRetryable(error),\n    onRetry: null\n};\n\n/**\n * Calculates delay for a specific attempt using exponential backoff.\n * \n * @param {number} attempt - Current attempt number (0-indexed).\n * @param {RetryOptions} options - Retry options.\n * @returns {number} Delay in ms.\n * \n * @example\n * getDelay(0, { baseDelay: 100, factor: 2 }); // 100\n * getDelay(1, { baseDelay: 100, factor: 2 }); // 200\n * getDelay(2, { baseDelay: 100, factor: 2 }); // 400\n */\nexport function getDelay(attempt, options) {\n    const { baseDelay, maxDelay, factor, jitter } = {\n        ...DEFAULT_RETRY_OPTIONS,\n        ...options\n    };\n\n    // Exponential backoff\n    let delay = (baseDelay || 100) * Math.pow(factor || 2, attempt);\n\n    // Cap at maxDelay\n    delay = Math.min(delay, maxDelay || 5000);\n\n    // Add jitter (Â±25%)\n    if (jitter) {\n        const jitterRange = delay * 0.25;\n        delay = delay + (Math.random() * jitterRange * 2 - jitterRange);\n    }\n\n    return Math.round(delay);\n}\n\n/**\n * Wraps a function with retry logic.\n * \n * @template T\n * @param {() => Promise<T>} fn - Function to retry.\n * @param {RetryOptions} [options={}] - Retry options.\n * @returns {Promise<T>}\n * \n * @example\n * const result = await withRetry(\n *   () => bus.request('widget', 'getData'),\n *   { maxAttempts: 3, baseDelay: 200 }\n * );\n */\nexport async function withRetry(fn, options = {}) {\n    const opts = { ...DEFAULT_RETRY_OPTIONS, ...options };\n\n    let lastError;\n\n    for (let attempt = 0; attempt < (opts.maxAttempts || 3); attempt++) {\n        try {\n            return await fn();\n        } catch (error) {\n            lastError = error;\n\n            // Check if we should retry\n            if (opts.shouldRetry && !opts.shouldRetry(error)) {\n                throw error;\n            }\n\n            // Check if we have more attempts\n            if (attempt + 1 >= (opts.maxAttempts || 3)) {\n                throw error;\n            }\n\n            // Calculate and wait for delay\n            const delay = getDelay(attempt, opts);\n\n            // Call onRetry callback\n            if (opts.onRetry) {\n                opts.onRetry({\n                    attempt: attempt + 1,\n                    delay,\n                    error,\n                    nextAttempt: attempt + 2,\n                    maxAttempts: opts.maxAttempts\n                });\n            }\n\n            await sleep(delay);\n        }\n    }\n\n    throw lastError;\n}\n\n/**\n * Creates a retry wrapper for CrossBus requests.\n * \n * @param {import(\"../core/cross-bus.js\").CrossBus} bus - CrossBus instance.\n * @param {RetryOptions} [defaultOptions={}] - Default options for all retries.\n * @returns {Object} Retry-wrapped methods.\n * \n * @example\n * const retry = createRetryWrapper(bus, { maxAttempts: 3 });\n * \n * const result = await retry.request('widget', 'getData', { id: 5 });\n * \n * const responses = await retry.broadcastRequest('getStatus');\n */\nexport function createRetryWrapper(bus, defaultOptions = {}) {\n    const opts = { ...DEFAULT_RETRY_OPTIONS, ...defaultOptions };\n\n    return {\n        /**\n         * Request with retry.\n         * \n         * @param {string} peerId - Target peer ID.\n         * @param {string} handlerName - Handler name.\n         * @param {*} [payload] - Request payload.\n         * @param {Object} [requestOptions] - Request and retry options.\n         * @returns {Promise<*>}\n         */\n        request: (peerId, handlerName, payload, requestOptions = {}) => {\n            const retryOpts = { ...opts, ...requestOptions };\n            return withRetry(\n                () => bus.request(peerId, handlerName, payload, requestOptions),\n                retryOpts\n            );\n        },\n\n        /**\n         * Broadcast request with retry (per-peer).\n         * Note: Each peer request is retried independently.\n         * \n         * @param {string} handlerName - Handler name.\n         * @param {*} [payload] - Request payload.\n         * @param {Object} [broadcastOptions] - Broadcast and retry options.\n         * @returns {Promise<Map<string, *>>}\n         */\n        broadcastRequest: (handlerName, payload, broadcastOptions = {}) => {\n            // For broadcast, we don't retry the whole operation\n            // but individual peer failures are ignored by default\n            return bus.broadcastRequest(handlerName, payload, broadcastOptions);\n        }\n    };\n}\n\n/**\n * Retry strategies presets.\n */\nexport const RetryStrategies = {\n    /** Fast retry for quick failures */\n    FAST: {\n        maxAttempts: 3,\n        baseDelay: 50,\n        maxDelay: 500,\n        factor: 1.5\n    },\n\n    /** Standard retry with moderate backoff */\n    STANDARD: {\n        maxAttempts: 3,\n        baseDelay: 100,\n        maxDelay: 3000,\n        factor: 2\n    },\n\n    /** Aggressive retry for critical operations */\n    AGGRESSIVE: {\n        maxAttempts: 5,\n        baseDelay: 200,\n        maxDelay: 10000,\n        factor: 2\n    },\n\n    /** Single immediate retry */\n    ONCE: {\n        maxAttempts: 2,\n        baseDelay: 0,\n        factor: 1\n    }\n};\n","/**\n * @fileoverview Centralized error handling for CrossBus.\n * @module common/errors\n */\n\n/**\n * Error codes for CrossBus.\n * @readonly\n * @enum {string}\n */\nexport const ErrorCode = Object.freeze({\n    // Connection errors\n    HANDSHAKE_TIMEOUT: 'ERR_HANDSHAKE_TIMEOUT',\n    HANDSHAKE_REJECTED: 'ERR_HANDSHAKE_REJECTED',\n    ORIGIN_FORBIDDEN: 'ERR_ORIGIN_FORBIDDEN',\n    PEER_EXISTS: 'ERR_PEER_EXISTS',\n    PEER_NOT_FOUND: 'ERR_PEER_NOT_FOUND',\n    PEER_DISCONNECTED: 'ERR_PEER_DISCONNECTED',\n    RECONNECT_FAILED: 'ERR_RECONNECT_FAILED',\n    UNSUPPORTED: 'ERR_UNSUPPORTED',\n    NOT_CONNECTED: 'ERR_NOT_CONNECTED',\n\n    // Message errors\n    ACK_TIMEOUT: 'ERR_ACK_TIMEOUT',\n    RESPONSE_TIMEOUT: 'ERR_RESPONSE_TIMEOUT',\n    QUEUE_FULL: 'ERR_QUEUE_FULL',\n    INVALID_MESSAGE: 'ERR_INVALID_MESSAGE',\n    VERSION_MISMATCH: 'ERR_VERSION_MISMATCH',\n    CLONE_ERROR: 'ERR_CLONE_ERROR',\n    TRANSFER_ERROR: 'ERR_TRANSFER_ERROR',\n    MESSAGE_TOO_LARGE: 'ERR_MESSAGE_TOO_LARGE',\n\n    // Routing errors\n    UNREACHABLE: 'ERR_UNREACHABLE',\n    TTL_EXCEEDED: 'ERR_TTL_EXCEEDED',\n    NO_ROUTE: 'ERR_NO_ROUTE',\n\n    // Handler errors\n    NO_HANDLER: 'ERR_NO_HANDLER',\n    HANDLER_ERROR: 'ERR_HANDLER_ERROR',\n    HANDLER_TIMEOUT: 'ERR_HANDLER_TIMEOUT',\n    HANDLER_EXISTS: 'ERR_HANDLER_EXISTS',\n    SEND_FAILED: 'ERR_SEND_FAILED',\n\n    // Channel errors\n    CHANNEL_FAILED: 'ERR_CHANNEL_FAILED',\n    CHANNEL_CLOSED: 'ERR_CHANNEL_CLOSED',\n\n    // Resource errors\n    MAX_PEERS: 'ERR_MAX_PEERS',\n    MAX_PENDING: 'ERR_MAX_PENDING',\n    DESTROYED: 'ERR_DESTROYED',\n\n    // Circuit Breaker\n    CIRCUIT_OPEN: 'ERR_CIRCUIT_OPEN',\n\n    // Security errors\n    PAYLOAD_TOO_LARGE: 'ERR_PAYLOAD_TOO_LARGE',\n    RATE_LIMITED: 'ERR_RATE_LIMITED',\n    UNAUTHORIZED: 'ERR_UNAUTHORIZED',\n    INVALID_PAYLOAD: 'ERR_INVALID_PAYLOAD'\n});\n\n/**\n * Error metadata including default messages, retryability, and AI-friendly suggestions.\n * @type {Object<ErrorCode, {message: string, retryable: boolean, suggestion: string}>}\n */\nconst ERROR_META = Object.freeze({\n    [ErrorCode.HANDSHAKE_TIMEOUT]: {\n        message: 'Handshake timed out',\n        retryable: true,\n        suggestion: 'Increase timeout or check if target is loaded. Use iframe.onload before connecting.'\n    },\n    [ErrorCode.HANDSHAKE_REJECTED]: {\n        message: 'Handshake rejected by peer',\n        retryable: false,\n        suggestion: 'Check targetOrigin matches the peer\\'s origin. Verify peer allows your origin.'\n    },\n    [ErrorCode.ORIGIN_FORBIDDEN]: {\n        message: 'Origin not in allowed origins list',\n        retryable: false,\n        suggestion: 'Add your origin to allowedOrigins option or use targetOrigin: \"*\" for development.'\n    },\n    [ErrorCode.PEER_EXISTS]: {\n        message: 'Peer with this ID already exists',\n        retryable: false,\n        suggestion: 'Use unique peerId for each context. Try: peerId: `agent-${Date.now()}`'\n    },\n    [ErrorCode.PEER_NOT_FOUND]: {\n        message: 'Peer not found',\n        retryable: false,\n        suggestion: 'Check if peer is connected using bus.peers. Wait for peer connection before request.'\n    },\n    [ErrorCode.PEER_DISCONNECTED]: {\n        message: 'Peer is disconnected',\n        retryable: true,\n        suggestion: 'Wait for peer to reconnect. Listen for \"peer:join\" event before retry.'\n    },\n    [ErrorCode.RECONNECT_FAILED]: {\n        message: 'Max reconnection attempts reached',\n        retryable: false,\n        suggestion: 'Check network connectivity. Consider increasing maxRetries option.'\n    },\n    [ErrorCode.UNSUPPORTED]: {\n        message: 'Operation not supported by this environment',\n        retryable: false,\n        suggestion: 'This feature requires a browser environment. Check for feature availability first.'\n    },\n    [ErrorCode.NOT_CONNECTED]: {\n        message: 'Transport is not connected',\n        retryable: true,\n        suggestion: 'Call addTransport() and wait for connection before sending messages.'\n    },\n    [ErrorCode.ACK_TIMEOUT]: {\n        message: 'ACK not received within timeout',\n        retryable: true,\n        suggestion: 'Increase ackTimeout option or check peer availability.'\n    },\n    [ErrorCode.RESPONSE_TIMEOUT]: {\n        message: 'Response not received within timeout',\n        retryable: true,\n        suggestion: 'Increase timeout in request options: { timeout: 10000 }. Check if handler exists on peer.'\n    },\n    [ErrorCode.QUEUE_FULL]: {\n        message: 'Message queue is full',\n        retryable: false,\n        suggestion: 'Increase maxQueueSize or wait for queue to drain. Consider using batching plugin.'\n    },\n    [ErrorCode.INVALID_MESSAGE]: {\n        message: 'Invalid message format',\n        retryable: false,\n        suggestion: 'Ensure message data is JSON-serializable. Avoid DOM nodes and functions.'\n    },\n    [ErrorCode.VERSION_MISMATCH]: {\n        message: 'Protocol version mismatch',\n        retryable: false,\n        suggestion: 'Update CrossBus to same version on both sides.'\n    },\n    [ErrorCode.CLONE_ERROR]: {\n        message: 'Data cannot be cloned (contains functions or DOM nodes)',\n        retryable: false,\n        suggestion: 'Remove functions, DOM nodes, and circular references from message data.'\n    },\n    [ErrorCode.TRANSFER_ERROR]: {\n        message: 'Failed to transfer object ownership',\n        retryable: false,\n        suggestion: 'Ensure ArrayBuffers are not detached. Each buffer can only be transferred once.'\n    },\n    [ErrorCode.MESSAGE_TOO_LARGE]: {\n        message: 'Message exceeds maximum size',\n        retryable: false,\n        suggestion: 'Use streaming for large payloads or increase maxMessageSize option.'\n    },\n    [ErrorCode.UNREACHABLE]: {\n        message: 'Destination peer is unreachable',\n        retryable: true,\n        suggestion: 'Check if peer is still connected. Use bus.peers to list available peers.'\n    },\n    [ErrorCode.TTL_EXCEEDED]: {\n        message: 'Message TTL exceeded (possible routing loop)',\n        retryable: false,\n        suggestion: 'Check for circular transport configurations. Increase maxTTL if needed.'\n    },\n    [ErrorCode.NO_ROUTE]: {\n        message: 'No route to destination',\n        retryable: false,\n        suggestion: 'Add transport connecting to target peer. Set isHub: true on orchestrator.'\n    },\n    [ErrorCode.NO_HANDLER]: {\n        message: 'No handler registered for this request',\n        retryable: false,\n        suggestion: 'Register handler on target: bus.handle(\"handlerName\", fn). Check handler name spelling.'\n    },\n    [ErrorCode.HANDLER_ERROR]: {\n        message: 'Handler threw an exception',\n        retryable: false,\n        suggestion: 'Check target peer logs for error. Wrap handler in try/catch.'\n    },\n    [ErrorCode.HANDLER_TIMEOUT]: {\n        message: 'Handler did not respond within timeout',\n        retryable: true,\n        suggestion: 'Handler is slow. Increase timeout or optimize handler performance.'\n    },\n    [ErrorCode.HANDLER_EXISTS]: {\n        message: 'Handler already registered with this name',\n        retryable: false,\n        suggestion: 'Use different handler name or call bus.removeHandler() first.'\n    },\n    [ErrorCode.SEND_FAILED]: {\n        message: 'Failed to send message to peer',\n        retryable: true,\n        suggestion: 'Check transport status. Target window may be closed or blocked.'\n    },\n    [ErrorCode.CHANNEL_FAILED]: {\n        message: 'Failed to create direct channel',\n        retryable: true,\n        suggestion: 'Check browser support for MessageChannel. Retry after short delay.'\n    },\n    [ErrorCode.CHANNEL_CLOSED]: {\n        message: 'Channel was closed unexpectedly',\n        retryable: false,\n        suggestion: 'Target context was destroyed. Check if iframe/worker still exists.'\n    },\n    [ErrorCode.MAX_PEERS]: {\n        message: 'Maximum number of peers reached',\n        retryable: false,\n        suggestion: 'Increase maxPeers option or disconnect unused peers first.'\n    },\n    [ErrorCode.MAX_PENDING]: {\n        message: 'Maximum pending requests reached',\n        retryable: false,\n        suggestion: 'Wait for pending requests to complete. Increase maxPendingRequests option.'\n    },\n    [ErrorCode.DESTROYED]: {\n        message: 'CrossBus instance has been destroyed',\n        retryable: false,\n        suggestion: 'Create new CrossBus instance. Do not use bus after calling destroy().'\n    },\n    [ErrorCode.CIRCUIT_OPEN]: {\n        message: 'Circuit breaker is open',\n        retryable: false,\n        suggestion: 'Too many failures. Wait for circuit to reset or call circuit.reset().'\n    },\n    [ErrorCode.PAYLOAD_TOO_LARGE]: {\n        message: 'Payload exceeds maximum allowed size',\n        retryable: false,\n        suggestion: 'Reduce payload size or increase maxPayloadSize option. Consider using streaming for large data.'\n    },\n    [ErrorCode.RATE_LIMITED]: {\n        message: 'Request rate limit exceeded',\n        retryable: true,\n        suggestion: 'Wait before retrying. Consider adding delay or using exponential backoff.'\n    },\n    [ErrorCode.UNAUTHORIZED]: {\n        message: 'Peer is not authorized to call this handler',\n        retryable: false,\n        suggestion: 'Add peer to handler allowedPeers list or remove peer restrictions.'\n    },\n    [ErrorCode.INVALID_PAYLOAD]: {\n        message: 'Payload validation failed',\n        retryable: false,\n        suggestion: 'Check payload structure against handler requirements.'\n    }\n});\n\n/**\n * Custom error class for CrossBus.\n * \n * @extends Error\n * \n * @example\n * try {\n *   await bus.emit('msg', data, 'unknown-peer');\n * } catch (err) {\n *   if (err instanceof CrossBusError) {\n *     console.log(err.code);      // 'ERR_PEER_NOT_FOUND'\n *     console.log(err.message);   // 'Peer not found'\n *     console.log(err.details);   // { peerId: 'unknown-peer' }\n *     console.log(err.retryable); // false\n *   }\n * }\n */\nexport class CrossBusError extends Error {\n    /**\n     * Error code.\n     * @type {ErrorCode}\n     */\n    code;\n\n    /**\n     * Additional error context.\n     * @type {Object}\n     */\n    details;\n\n    /**\n     * Whether the operation can be retried.\n     * @type {boolean}\n     */\n    retryable;\n\n    /**\n     * Original error that caused this error.\n     * @type {Error|undefined}\n     */\n    cause;\n\n    /**\n     * Timestamp when error occurred.\n     * @type {number}\n     */\n    timestamp;\n\n    /**\n     * Creates a new CrossBusError.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {string} [message] - Custom message (uses default if omitted).\n     * @param {Object} [options] - Additional options.\n     * @param {Object} [options.details={}] - Error context.\n     * @param {boolean} [options.retryable] - Override default retryable.\n     * @param {Error} [options.cause] - Original error.\n     */\n    constructor(code, message, options = {}) {\n        const meta = ERROR_META[code] ?? { message: 'Unknown error', retryable: false };\n        super(message ?? meta.message);\n\n        this.name = 'CrossBusError';\n        this.code = code;\n        this.details = options.details ?? {};\n        this.retryable = options.retryable ?? meta.retryable;\n        this.cause = options.cause;\n        this.timestamp = Date.now();\n\n        // Maintain proper stack trace in V8\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CrossBusError);\n        }\n    }\n\n    /**\n     * Creates error from code with default message.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {Object} [details] - Error context.\n     * @returns {CrossBusError}\n     */\n    static from(code, details = {}) {\n        return new CrossBusError(code, undefined, { details });\n    }\n\n    /**\n     * Creates error from another error.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {Error} cause - Original error.\n     * @param {Object} [details] - Additional context.\n     * @returns {CrossBusError}\n     */\n    static wrap(code, cause, details = {}) {\n        return new CrossBusError(code, cause.message, { cause, details });\n    }\n\n    /**\n     * Converts error to JSON-serializable object.\n     * @returns {Object}\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            code: this.code,\n            message: this.message,\n            details: this.details,\n            retryable: this.retryable,\n            timestamp: this.timestamp\n        };\n    }\n\n    /**\n     * String representation.\n     * @returns {string}\n     */\n    toString() {\n        return `${this.name} [${this.code}]: ${this.message}`;\n    }\n}\n\n/**\n * Checks if an error is a CrossBusError.\n * \n * @param {*} err - Value to check.\n * @returns {boolean}\n */\nexport function isCrossBusError(err) {\n    return err instanceof CrossBusError;\n}\n\n/**\n * Checks if an error is retryable.\n * \n * @param {Error} err - Error to check.\n * @returns {boolean}\n */\nexport function isRetryable(err) {\n    if (err instanceof CrossBusError) {\n        return err.retryable;\n    }\n    return false;\n}\n"],"names":["sleep","ms","Promise","resolve","setTimeout","getDelay","attempt","options","baseDelay","maxDelay","factor","jitter","DEFAULT_RETRY_OPTIONS","delay","Math","pow","min","jitterRange","random","round","async","withRetry","fn","opts","lastError","maxAttempts","error","shouldRetry","onRetry","nextAttempt","createRetryWrapper","bus","defaultOptions","peerId","handlerName","payload","requestOptions","request","broadcastOptions","broadcastRequest","ErrorCode","Object","freeze","HANDSHAKE_TIMEOUT","HANDSHAKE_REJECTED","ORIGIN_FORBIDDEN","PEER_EXISTS","PEER_NOT_FOUND","PEER_DISCONNECTED","RECONNECT_FAILED","UNSUPPORTED","NOT_CONNECTED","ACK_TIMEOUT","RESPONSE_TIMEOUT","QUEUE_FULL","INVALID_MESSAGE","VERSION_MISMATCH","CLONE_ERROR","TRANSFER_ERROR","MESSAGE_TOO_LARGE","UNREACHABLE","TTL_EXCEEDED","NO_ROUTE","NO_HANDLER","HANDLER_ERROR","HANDLER_TIMEOUT","HANDLER_EXISTS","SEND_FAILED","CHANNEL_FAILED","CHANNEL_CLOSED","MAX_PEERS","MAX_PENDING","DESTROYED","CIRCUIT_OPEN","PAYLOAD_TOO_LARGE","RATE_LIMITED","UNAUTHORIZED","INVALID_PAYLOAD","ERROR_META","message","retryable","suggestion","CrossBusError","Error","code","details","cause","timestamp","constructor","meta","super","this","name","Date","now","captureStackTrace","from","undefined","wrap","toJSON","toString","isRetryable","err","RetryStrategies","FAST","STANDARD","AGGRESSIVE","ONCE"],"mappings":"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"}