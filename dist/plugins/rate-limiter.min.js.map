{"version":3,"file":"rate-limiter.min.js","sources":["../../src/plugins/rate-limiter.js"],"sourcesContent":["/**\n * @fileoverview Rate Limiter plugin for CrossBus.\n * Prevents message flooding with configurable rate limits.\n * \n * @module plugins/rate-limiter\n */\n\n/**\n * @typedef {Object} RateLimiterOptions\n * @property {number} [maxRequests=100] - Maximum requests per window\n * @property {number} [windowMs=1000] - Time window in milliseconds\n * @property {string} [strategy='sliding'] - 'sliding' or 'fixed' window\n * @property {Function|null} [onLimitExceeded] - Called when limit exceeded\n */\n\n/**\n * Custom error for rate limiting\n * @extends Error\n */\nclass RateLimitError extends Error {\n    /** @type {string} */\n    code;\n    /** @type {number} */\n    retryAfter;\n\n    /**\n     * @param {string} message \n     * @param {number} retryAfter \n     */\n    constructor(message, retryAfter) {\n        super(message);\n        this.code = 'ERR_RATE_LIMITED';\n        this.retryAfter = retryAfter;\n    }\n}\n\n/**\n * Rate limiter using token bucket algorithm.\n * \n * @example\n * import { RateLimiter } from 'crossbus/plugins/rate-limiter';\n * \n * const limiter = new RateLimiter({\n *   maxRequests: 100,\n *   windowMs: 1000 // 100 requests per second\n * });\n * \n * // Check before sending\n * if (limiter.tryAcquire()) {\n *   await bus.emit('event', data);\n * } else {\n *   console.log('Rate limited!');\n * }\n * \n * // Or use as hook\n * bus.addOutboundHook(limiter.createHook());\n */\nexport class RateLimiter {\n    /** @type {number} */\n    #maxTokens;\n\n    /** @type {number} */\n    #tokens;\n\n    /** @type {number} */\n    #windowMs;\n\n    /** @type {number} */\n    #lastRefill;\n\n    /** @type {Function|null} */\n    #onLimitExceeded;\n\n    /** @type {Map<string, RateLimiter>} */\n    #perPeerLimiters = new Map();\n\n    /**\n     * Creates a new rate limiter.\n     * \n     * @param {RateLimiterOptions} [options={}]\n     */\n    constructor(options = {}) {\n        this.#maxTokens = options.maxRequests ?? 100;\n        this.#tokens = this.#maxTokens;\n        this.#windowMs = options.windowMs ?? 1000;\n        this.#lastRefill = Date.now();\n        this.#onLimitExceeded = options.onLimitExceeded ?? null;\n    }\n\n    /**\n     * Attempts to acquire a token.\n     * \n     * @returns {boolean} True if request allowed, false if rate limited\n     */\n    tryAcquire() {\n        this.#refill();\n\n        if (this.#tokens > 0) {\n            this.#tokens--;\n            return true;\n        }\n\n        if (this.#onLimitExceeded) {\n            this.#onLimitExceeded();\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets remaining tokens.\n     * @returns {number}\n     */\n    get remaining() {\n        this.#refill();\n        return this.#tokens;\n    }\n\n    /**\n     * Gets time until next token is available.\n     * @returns {number} Milliseconds until next refill\n     */\n    get retryAfter() {\n        const now = Date.now();\n        const elapsed = now - this.#lastRefill;\n        return Math.max(0, this.#windowMs - elapsed);\n    }\n\n    /**\n     * Resets the rate limiter.\n     */\n    reset() {\n        this.#tokens = this.#maxTokens;\n        this.#lastRefill = Date.now();\n    }\n\n    /**\n     * Creates a per-peer rate limiter.\n     * Each peer gets its own token bucket.\n     * \n     * @param {string} peerId - Peer identifier\n     * @returns {RateLimiter}\n     */\n    forPeer(peerId) {\n        if (!this.#perPeerLimiters.has(peerId)) {\n            this.#perPeerLimiters.set(peerId, new RateLimiter({\n                maxRequests: this.#maxTokens,\n                windowMs: this.#windowMs,\n                onLimitExceeded: this.#onLimitExceeded\n            }));\n        }\n        return /** @type {RateLimiter} */ (this.#perPeerLimiters.get(peerId));\n    }\n\n    /**\n     * Creates a hook function for automatic rate limiting.\n     * \n     * @param {{ perPeer?: boolean, throwOnLimit?: boolean }} [options={}]\n     * @returns {import('../core/cross-bus.js').MessageHook} Hook function\n     * \n     * @example\n     * bus.addOutboundHook(limiter.createHook({ perPeer: true }));\n     */\n    createHook(options = {}) {\n        const { perPeer = false, throwOnLimit = true } = options;\n\n        return (payload, context) => {\n            const limiter = perPeer && context.peerId\n                ? this.forPeer(context.peerId)\n                : this;\n\n            if (!limiter.tryAcquire()) {\n                if (throwOnLimit) {\n                    throw new RateLimitError('Rate limit exceeded', limiter.retryAfter);\n                }\n                return null; // Drop message\n            }\n\n            return payload;\n        };\n    }\n\n    /**\n     * Cleans up per-peer limiters for disconnected peers.\n     * \n     * @param {string[]} activePeers - List of currently active peer IDs\n     */\n    cleanup(activePeers) {\n        const activeSet = new Set(activePeers);\n        for (const peerId of this.#perPeerLimiters.keys()) {\n            if (!activeSet.has(peerId)) {\n                this.#perPeerLimiters.delete(peerId);\n            }\n        }\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Private methods\n    // ─────────────────────────────────────────────────────────────────\n\n    #refill() {\n        const now = Date.now();\n        const elapsed = now - this.#lastRefill;\n\n        if (elapsed >= this.#windowMs) {\n            // Full refill\n            this.#tokens = this.#maxTokens;\n            this.#lastRefill = now;\n        } else {\n            // Sliding window: proportional refill\n            const tokensToAdd = Math.floor((elapsed / this.#windowMs) * this.#maxTokens);\n            if (tokensToAdd > 0) {\n                this.#tokens = Math.min(this.#maxTokens, this.#tokens + tokensToAdd);\n                this.#lastRefill = now;\n            }\n        }\n    }\n}\n\n/**\n * Helper to rate limit a CrossBus instance.\n * \n * @param {import(\"../core/cross-bus.js\").CrossBus} bus - CrossBus instance\n * @param {RateLimiterOptions} options - Rate limiter options\n * @returns {RateLimiter} The rate limiter (for inspection)\n * \n * @example\n * const limiter = withRateLimiter(bus, { \n *   maxRequests: 50, \n *   windowMs: 1000 \n * });\n */\nexport function withRateLimiter(bus, options = {}) {\n    const limiter = new RateLimiter(options);\n    bus.addOutboundHook(limiter.createHook({ perPeer: true }));\n    return limiter;\n}\n"],"names":["withRateLimiter","bus","options","limiter","RateLimiter","addOutboundHook","createHook","perPeer","RateLimitError","Error","code","retryAfter","constructor","message","super","this","maxTokens","tokens","windowMs","lastRefill","onLimitExceeded","perPeerLimiters","Map","maxRequests","Date","now","tryAcquire","refill","remaining","elapsed","Math","max","reset","forPeer","peerId","has","set","get","throwOnLimit","payload","context","cleanup","activePeers","activeSet","Set","keys","delete","tokensToAdd","floor","min"],"mappings":"AAwOO,SAASA,EAAgBC,EAAKC,EAAU,IAC3C,MAAMC,EAAU,IAAIC,EAAYF,GAEhC,OADAD,EAAII,gBAAgBF,EAAQG,WAAW,CAAEC,SAAS,KAC3CJ,CACX,CAzNA,MAAMK,UAAuBC,MAEzBC,KAEAC,WAMA,WAAAC,CAAYC,EAASF,GACjBG,MAAMD,GACNE,KAAKL,KAAO,mBACZK,KAAKJ,WAAaA,CACtB,EAwBG,MAAMP,EAETY,GAGAC,GAGAC,GAGAC,GAGAC,GAGAC,GAAmB,IAAIC,IAOvB,WAAAV,CAAYV,EAAU,IAClBa,MAAKC,EAAad,EAAQqB,aAAe,IACzCR,MAAKE,EAAUF,MAAKC,EACpBD,MAAKG,EAAYhB,EAAQgB,UAAY,IACrCH,MAAKI,EAAcK,KAAKC,MACxBV,MAAKK,EAAmBlB,EAAQkB,iBAAmB,IACvD,CAOA,UAAAM,GAGI,OAFAX,MAAKY,IAEDZ,MAAKE,EAAU,GACfF,MAAKE,KACE,IAGPF,MAAKK,GACLL,MAAKK,KAGF,EACX,CAMA,aAAIQ,GAEA,OADAb,MAAKY,IACEZ,MAAKE,CAChB,CAMA,cAAIN,GACA,MACMkB,EADML,KAAKC,MACKV,MAAKI,EAC3B,OAAOW,KAAKC,IAAI,EAAGhB,MAAKG,EAAYW,EACxC,CAKA,KAAAG,GACIjB,MAAKE,EAAUF,MAAKC,EACpBD,MAAKI,EAAcK,KAAKC,KAC5B,CASA,OAAAQ,CAAQC,GAQJ,OAPKnB,MAAKM,EAAiBc,IAAID,IAC3BnB,MAAKM,EAAiBe,IAAIF,EAAQ,IAAI9B,EAAY,CAC9CmB,YAAaR,MAAKC,EAClBE,SAAUH,MAAKG,EACfE,gBAAiBL,MAAKK,KAGKL,MAAKM,EAAiBgB,IAAIH,EACjE,CAWA,UAAA5B,CAAWJ,EAAU,IACjB,MAAMK,QAAEA,GAAU,EAAK+B,aAAEA,GAAe,GAASpC,EAEjD,MAAO,CAACqC,EAASC,KACb,MAAMrC,EAAUI,GAAWiC,EAAQN,OAC7BnB,KAAKkB,QAAQO,EAAQN,QACrBnB,KAEN,IAAKZ,EAAQuB,aAAc,CACvB,GAAIY,EACA,MAAM,IAAI9B,EAAe,sBAAuBL,EAAQQ,YAE5D,OAAO,IACX,CAEA,OAAO4B,EAEf,CAOA,OAAAE,CAAQC,GACJ,MAAMC,EAAY,IAAIC,IAAIF,GAC1B,IAAK,MAAMR,KAAUnB,MAAKM,EAAiBwB,OAClCF,EAAUR,IAAID,IACfnB,MAAKM,EAAiByB,OAAOZ,EAGzC,CAMA,EAAAP,GACI,MAAMF,EAAMD,KAAKC,MACXI,EAAUJ,EAAMV,MAAKI,EAE3B,GAAIU,GAAWd,MAAKG,EAEhBH,MAAKE,EAAUF,MAAKC,EACpBD,MAAKI,EAAcM,MAChB,CAEH,MAAMsB,EAAcjB,KAAKkB,MAAOnB,EAAUd,MAAKG,EAAaH,MAAKC,GAC7D+B,EAAc,IACdhC,MAAKE,EAAUa,KAAKmB,IAAIlC,MAAKC,EAAYD,MAAKE,EAAU8B,GACxDhC,MAAKI,EAAcM,EAE3B,CACJ"}