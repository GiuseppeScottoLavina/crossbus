function t(t,r){const{encryptHook:a,decryptHook:n}=e.createEncryptedHooks(r);return t.addOutboundHook(a),t.addInboundHook(n),t}class e{static ALGORITHM="AES-GCM";static KEY_LENGTH=256;static IV_LENGTH=12;static async generateKey(){return await crypto.subtle.generateKey({name:this.ALGORITHM,length:this.KEY_LENGTH},!0,["encrypt","decrypt"])}static async deriveKey(t,e,r=1e5){const a=new TextEncoder,n=await crypto.subtle.importKey("raw",a.encode(t),"PBKDF2",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:a.encode(e),iterations:r,hash:"SHA-256"},n,{name:this.ALGORITHM,length:this.KEY_LENGTH},!0,["encrypt","decrypt"])}static async exportKey(t){const e=await crypto.subtle.exportKey("raw",t);return this.#t(e)}static async importKey(t){const e=this.#e(t);return await crypto.subtle.importKey("raw",e,{name:this.ALGORITHM,length:this.KEY_LENGTH},!0,["encrypt","decrypt"])}static async encrypt(t,e){const r={data:t,t:Date.now()},a=(new TextEncoder).encode(JSON.stringify(r)),n=crypto.getRandomValues(new Uint8Array(this.IV_LENGTH)),c=await crypto.subtle.encrypt({name:this.ALGORITHM,iv:n},e,a);return{i:!0,ciphertext:this.#t(c),iv:this.#t(n)}}static async decrypt(t,e,r={}){const a=this.#e(t.ciphertext),n=this.#e(t.iv),c=await crypto.subtle.decrypt({name:this.ALGORITHM,iv:n},e,a),s=new TextDecoder,i=JSON.parse(s.decode(c)),o=i.t?i.data:i,y=i.t;if(y){const t=r.ttl??6e4,e=Date.now();if(e-y>t)throw new Error(`Message expired (replay attack detected). Age: ${e-y}ms, TTL: ${t}ms`)}return o}static createEncryptedHooks(t){return{encryptHook:async e=>e&&e.i?e:await this.encrypt(e,t),decryptHook:async e=>e&&e.i?await this.decrypt(e,t):e}}static#t(t){const e=new Uint8Array(t);let r="";for(let t=0;t<e.length;t++)r+=String.fromCharCode(e[t]);return btoa(r)}static#e(t){const e=atob(t),r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r.buffer}}export{e as Encryption,t as withEncryption};
//# sourceMappingURL=encryption.min.js.map
