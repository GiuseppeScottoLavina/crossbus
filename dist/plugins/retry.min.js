function e(e){return new Promise(t=>{setTimeout(t,e)})}function t(e,t){const{baseDelay:s,maxDelay:r,factor:a,jitter:n}={...i,...t};let o=(s||100)*Math.pow(a||2,e);if(o=Math.min(o,r||5e3),n){const e=.25*o;o+=Math.random()*e*2-e}return Math.round(o)}async function s(s,r={}){const a={...i,...r};let n;for(let r=0;r<(a.maxAttempts||3);r++)try{return await s()}catch(s){if(n=s,a.shouldRetry&&!a.shouldRetry(s))throw s;if(r+1>=(a.maxAttempts||3))throw s;const o=t(r,a);a.onRetry&&a.onRetry({attempt:r+1,delay:o,error:s,nextAttempt:r+2,maxAttempts:a.maxAttempts}),await e(o)}throw n}function r(e,t={}){const r={...i,...t};return{request(t,a,n,o={}){return s(()=>e.request(t,a,n,o),{...r,...o})},broadcastRequest(t,s,r={}){return e.broadcastRequest(t,s,r)}}}const a=Object.freeze({HANDSHAKE_TIMEOUT:"ERR_HANDSHAKE_TIMEOUT",HANDSHAKE_REJECTED:"ERR_HANDSHAKE_REJECTED",ORIGIN_FORBIDDEN:"ERR_ORIGIN_FORBIDDEN",PEER_EXISTS:"ERR_PEER_EXISTS",PEER_NOT_FOUND:"ERR_PEER_NOT_FOUND",PEER_DISCONNECTED:"ERR_PEER_DISCONNECTED",RECONNECT_FAILED:"ERR_RECONNECT_FAILED",UNSUPPORTED:"ERR_UNSUPPORTED",NOT_CONNECTED:"ERR_NOT_CONNECTED",ACK_TIMEOUT:"ERR_ACK_TIMEOUT",RESPONSE_TIMEOUT:"ERR_RESPONSE_TIMEOUT",QUEUE_FULL:"ERR_QUEUE_FULL",INVALID_MESSAGE:"ERR_INVALID_MESSAGE",VERSION_MISMATCH:"ERR_VERSION_MISMATCH",CLONE_ERROR:"ERR_CLONE_ERROR",TRANSFER_ERROR:"ERR_TRANSFER_ERROR",MESSAGE_TOO_LARGE:"ERR_MESSAGE_TOO_LARGE",UNREACHABLE:"ERR_UNREACHABLE",TTL_EXCEEDED:"ERR_TTL_EXCEEDED",NO_ROUTE:"ERR_NO_ROUTE",NO_HANDLER:"ERR_NO_HANDLER",HANDLER_ERROR:"ERR_HANDLER_ERROR",HANDLER_TIMEOUT:"ERR_HANDLER_TIMEOUT",HANDLER_EXISTS:"ERR_HANDLER_EXISTS",SEND_FAILED:"ERR_SEND_FAILED",CHANNEL_FAILED:"ERR_CHANNEL_FAILED",CHANNEL_CLOSED:"ERR_CHANNEL_CLOSED",MAX_PEERS:"ERR_MAX_PEERS",MAX_PENDING:"ERR_MAX_PENDING",DESTROYED:"ERR_DESTROYED",CIRCUIT_OPEN:"ERR_CIRCUIT_OPEN",PAYLOAD_TOO_LARGE:"ERR_PAYLOAD_TOO_LARGE",RATE_LIMITED:"ERR_RATE_LIMITED",UNAUTHORIZED:"ERR_UNAUTHORIZED",INVALID_PAYLOAD:"ERR_INVALID_PAYLOAD"}),n=Object.freeze({[a.HANDSHAKE_TIMEOUT]:{message:"Handshake timed out",retryable:!0,suggestion:"Increase timeout or check if target is loaded. Use iframe.onload before connecting."},[a.HANDSHAKE_REJECTED]:{message:"Handshake rejected by peer",retryable:!1,suggestion:"Check targetOrigin matches the peer's origin. Verify peer allows your origin."},[a.ORIGIN_FORBIDDEN]:{message:"Origin not in allowed origins list",retryable:!1,suggestion:'Add your origin to allowedOrigins option or use targetOrigin: "*" for development.'},[a.PEER_EXISTS]:{message:"Peer with this ID already exists",retryable:!1,suggestion:"Use unique peerId for each context. Try: peerId: `agent-${Date.now()}`"},[a.PEER_NOT_FOUND]:{message:"Peer not found",retryable:!1,suggestion:"Check if peer is connected using bus.peers. Wait for peer connection before request."},[a.PEER_DISCONNECTED]:{message:"Peer is disconnected",retryable:!0,suggestion:'Wait for peer to reconnect. Listen for "peer:join" event before retry.'},[a.RECONNECT_FAILED]:{message:"Max reconnection attempts reached",retryable:!1,suggestion:"Check network connectivity. Consider increasing maxRetries option."},[a.UNSUPPORTED]:{message:"Operation not supported by this environment",retryable:!1,suggestion:"This feature requires a browser environment. Check for feature availability first."},[a.NOT_CONNECTED]:{message:"Transport is not connected",retryable:!0,suggestion:"Call addTransport() and wait for connection before sending messages."},[a.ACK_TIMEOUT]:{message:"ACK not received within timeout",retryable:!0,suggestion:"Increase ackTimeout option or check peer availability."},[a.RESPONSE_TIMEOUT]:{message:"Response not received within timeout",retryable:!0,suggestion:"Increase timeout in request options: { timeout: 10000 }. Check if handler exists on peer."},[a.QUEUE_FULL]:{message:"Message queue is full",retryable:!1,suggestion:"Increase maxQueueSize or wait for queue to drain. Consider using batching plugin."},[a.INVALID_MESSAGE]:{message:"Invalid message format",retryable:!1,suggestion:"Ensure message data is JSON-serializable. Avoid DOM nodes and functions."},[a.VERSION_MISMATCH]:{message:"Protocol version mismatch",retryable:!1,suggestion:"Update CrossBus to same version on both sides."},[a.CLONE_ERROR]:{message:"Data cannot be cloned (contains functions or DOM nodes)",retryable:!1,suggestion:"Remove functions, DOM nodes, and circular references from message data."},[a.TRANSFER_ERROR]:{message:"Failed to transfer object ownership",retryable:!1,suggestion:"Ensure ArrayBuffers are not detached. Each buffer can only be transferred once."},[a.MESSAGE_TOO_LARGE]:{message:"Message exceeds maximum size",retryable:!1,suggestion:"Use streaming for large payloads or increase maxMessageSize option."},[a.UNREACHABLE]:{message:"Destination peer is unreachable",retryable:!0,suggestion:"Check if peer is still connected. Use bus.peers to list available peers."},[a.TTL_EXCEEDED]:{message:"Message TTL exceeded (possible routing loop)",retryable:!1,suggestion:"Check for circular transport configurations. Increase maxTTL if needed."},[a.NO_ROUTE]:{message:"No route to destination",retryable:!1,suggestion:"Add transport connecting to target peer. Set isHub: true on orchestrator."},[a.NO_HANDLER]:{message:"No handler registered for this request",retryable:!1,suggestion:'Register handler on target: bus.handle("handlerName", fn). Check handler name spelling.'},[a.HANDLER_ERROR]:{message:"Handler threw an exception",retryable:!1,suggestion:"Check target peer logs for error. Wrap handler in try/catch."},[a.HANDLER_TIMEOUT]:{message:"Handler did not respond within timeout",retryable:!0,suggestion:"Handler is slow. Increase timeout or optimize handler performance."},[a.HANDLER_EXISTS]:{message:"Handler already registered with this name",retryable:!1,suggestion:"Use different handler name or call bus.removeHandler() first."},[a.SEND_FAILED]:{message:"Failed to send message to peer",retryable:!0,suggestion:"Check transport status. Target window may be closed or blocked."},[a.CHANNEL_FAILED]:{message:"Failed to create direct channel",retryable:!0,suggestion:"Check browser support for MessageChannel. Retry after short delay."},[a.CHANNEL_CLOSED]:{message:"Channel was closed unexpectedly",retryable:!1,suggestion:"Target context was destroyed. Check if iframe/worker still exists."},[a.MAX_PEERS]:{message:"Maximum number of peers reached",retryable:!1,suggestion:"Increase maxPeers option or disconnect unused peers first."},[a.MAX_PENDING]:{message:"Maximum pending requests reached",retryable:!1,suggestion:"Wait for pending requests to complete. Increase maxPendingRequests option."},[a.DESTROYED]:{message:"CrossBus instance has been destroyed",retryable:!1,suggestion:"Create new CrossBus instance. Do not use bus after calling destroy()."},[a.CIRCUIT_OPEN]:{message:"Circuit breaker is open",retryable:!1,suggestion:"Too many failures. Wait for circuit to reset or call circuit.reset()."},[a.PAYLOAD_TOO_LARGE]:{message:"Payload exceeds maximum allowed size",retryable:!1,suggestion:"Reduce payload size or increase maxPayloadSize option. Consider using streaming for large data."},[a.RATE_LIMITED]:{message:"Request rate limit exceeded",retryable:!0,suggestion:"Wait before retrying. Consider adding delay or using exponential backoff."},[a.UNAUTHORIZED]:{message:"Peer is not authorized to call this handler",retryable:!1,suggestion:"Add peer to handler allowedPeers list or remove peer restrictions."},[a.INVALID_PAYLOAD]:{message:"Payload validation failed",retryable:!1,suggestion:"Check payload structure against handler requirements."}});class o extends Error{code;details;retryable;cause;timestamp;constructor(e,t,s={}){const r=n[e]??{message:"Unknown error",retryable:!1};super(t??r.message),this.name="CrossBusError",this.code=e,this.details=s.details??{},this.retryable=s.retryable??r.retryable,this.cause=s.cause,this.timestamp=Date.now(),Error.captureStackTrace&&Error.captureStackTrace(this,o)}static from(e,t={}){return new o(e,void 0,{details:t})}static wrap(e,t,s={}){return new o(e,t.message,{cause:t,details:s})}toJSON(){return{name:this.name,code:this.code,message:this.message,details:this.details,retryable:this.retryable,timestamp:this.timestamp}}toString(){return`${this.name} [${this.code}]: ${this.message}`}}const i={maxAttempts:3,baseDelay:100,maxDelay:5e3,factor:2,jitter:!0,shouldRetry(e){return(t=e)instanceof o&&t.retryable;var t},onRetry:null},E={FAST:{maxAttempts:3,baseDelay:50,maxDelay:500,factor:1.5},STANDARD:{maxAttempts:3,baseDelay:100,maxDelay:3e3,factor:2},AGGRESSIVE:{maxAttempts:5,baseDelay:200,maxDelay:1e4,factor:2},ONCE:{maxAttempts:2,baseDelay:0,factor:1}};export{i as DEFAULT_RETRY_OPTIONS,E as RetryStrategies,r as createRetryWrapper,t as getDelay,s as withRetry};
//# sourceMappingURL=retry.min.js.map
