function e(e,s,t={}){const r=new n(t);return{breaker:r,request(t,i,a={}){return r.execute(()=>e.request(s,t,i,a))}}}const s=Object.freeze({HANDSHAKE_TIMEOUT:"ERR_HANDSHAKE_TIMEOUT",HANDSHAKE_REJECTED:"ERR_HANDSHAKE_REJECTED",ORIGIN_FORBIDDEN:"ERR_ORIGIN_FORBIDDEN",PEER_EXISTS:"ERR_PEER_EXISTS",PEER_NOT_FOUND:"ERR_PEER_NOT_FOUND",PEER_DISCONNECTED:"ERR_PEER_DISCONNECTED",RECONNECT_FAILED:"ERR_RECONNECT_FAILED",UNSUPPORTED:"ERR_UNSUPPORTED",NOT_CONNECTED:"ERR_NOT_CONNECTED",ACK_TIMEOUT:"ERR_ACK_TIMEOUT",RESPONSE_TIMEOUT:"ERR_RESPONSE_TIMEOUT",QUEUE_FULL:"ERR_QUEUE_FULL",INVALID_MESSAGE:"ERR_INVALID_MESSAGE",VERSION_MISMATCH:"ERR_VERSION_MISMATCH",CLONE_ERROR:"ERR_CLONE_ERROR",TRANSFER_ERROR:"ERR_TRANSFER_ERROR",MESSAGE_TOO_LARGE:"ERR_MESSAGE_TOO_LARGE",UNREACHABLE:"ERR_UNREACHABLE",TTL_EXCEEDED:"ERR_TTL_EXCEEDED",NO_ROUTE:"ERR_NO_ROUTE",NO_HANDLER:"ERR_NO_HANDLER",HANDLER_ERROR:"ERR_HANDLER_ERROR",HANDLER_TIMEOUT:"ERR_HANDLER_TIMEOUT",HANDLER_EXISTS:"ERR_HANDLER_EXISTS",SEND_FAILED:"ERR_SEND_FAILED",CHANNEL_FAILED:"ERR_CHANNEL_FAILED",CHANNEL_CLOSED:"ERR_CHANNEL_CLOSED",MAX_PEERS:"ERR_MAX_PEERS",MAX_PENDING:"ERR_MAX_PENDING",DESTROYED:"ERR_DESTROYED",CIRCUIT_OPEN:"ERR_CIRCUIT_OPEN",PAYLOAD_TOO_LARGE:"ERR_PAYLOAD_TOO_LARGE",RATE_LIMITED:"ERR_RATE_LIMITED",UNAUTHORIZED:"ERR_UNAUTHORIZED",INVALID_PAYLOAD:"ERR_INVALID_PAYLOAD"}),t=Object.freeze({[s.HANDSHAKE_TIMEOUT]:{message:"Handshake timed out",retryable:!0,suggestion:"Increase timeout or check if target is loaded. Use iframe.onload before connecting."},[s.HANDSHAKE_REJECTED]:{message:"Handshake rejected by peer",retryable:!1,suggestion:"Check targetOrigin matches the peer's origin. Verify peer allows your origin."},[s.ORIGIN_FORBIDDEN]:{message:"Origin not in allowed origins list",retryable:!1,suggestion:'Add your origin to allowedOrigins option or use targetOrigin: "*" for development.'},[s.PEER_EXISTS]:{message:"Peer with this ID already exists",retryable:!1,suggestion:"Use unique peerId for each context. Try: peerId: `agent-${Date.now()}`"},[s.PEER_NOT_FOUND]:{message:"Peer not found",retryable:!1,suggestion:"Check if peer is connected using bus.peers. Wait for peer connection before request."},[s.PEER_DISCONNECTED]:{message:"Peer is disconnected",retryable:!0,suggestion:'Wait for peer to reconnect. Listen for "peer:join" event before retry.'},[s.RECONNECT_FAILED]:{message:"Max reconnection attempts reached",retryable:!1,suggestion:"Check network connectivity. Consider increasing maxRetries option."},[s.UNSUPPORTED]:{message:"Operation not supported by this environment",retryable:!1,suggestion:"This feature requires a browser environment. Check for feature availability first."},[s.NOT_CONNECTED]:{message:"Transport is not connected",retryable:!0,suggestion:"Call addTransport() and wait for connection before sending messages."},[s.ACK_TIMEOUT]:{message:"ACK not received within timeout",retryable:!0,suggestion:"Increase ackTimeout option or check peer availability."},[s.RESPONSE_TIMEOUT]:{message:"Response not received within timeout",retryable:!0,suggestion:"Increase timeout in request options: { timeout: 10000 }. Check if handler exists on peer."},[s.QUEUE_FULL]:{message:"Message queue is full",retryable:!1,suggestion:"Increase maxQueueSize or wait for queue to drain. Consider using batching plugin."},[s.INVALID_MESSAGE]:{message:"Invalid message format",retryable:!1,suggestion:"Ensure message data is JSON-serializable. Avoid DOM nodes and functions."},[s.VERSION_MISMATCH]:{message:"Protocol version mismatch",retryable:!1,suggestion:"Update CrossBus to same version on both sides."},[s.CLONE_ERROR]:{message:"Data cannot be cloned (contains functions or DOM nodes)",retryable:!1,suggestion:"Remove functions, DOM nodes, and circular references from message data."},[s.TRANSFER_ERROR]:{message:"Failed to transfer object ownership",retryable:!1,suggestion:"Ensure ArrayBuffers are not detached. Each buffer can only be transferred once."},[s.MESSAGE_TOO_LARGE]:{message:"Message exceeds maximum size",retryable:!1,suggestion:"Use streaming for large payloads or increase maxMessageSize option."},[s.UNREACHABLE]:{message:"Destination peer is unreachable",retryable:!0,suggestion:"Check if peer is still connected. Use bus.peers to list available peers."},[s.TTL_EXCEEDED]:{message:"Message TTL exceeded (possible routing loop)",retryable:!1,suggestion:"Check for circular transport configurations. Increase maxTTL if needed."},[s.NO_ROUTE]:{message:"No route to destination",retryable:!1,suggestion:"Add transport connecting to target peer. Set isHub: true on orchestrator."},[s.NO_HANDLER]:{message:"No handler registered for this request",retryable:!1,suggestion:'Register handler on target: bus.handle("handlerName", fn). Check handler name spelling.'},[s.HANDLER_ERROR]:{message:"Handler threw an exception",retryable:!1,suggestion:"Check target peer logs for error. Wrap handler in try/catch."},[s.HANDLER_TIMEOUT]:{message:"Handler did not respond within timeout",retryable:!0,suggestion:"Handler is slow. Increase timeout or optimize handler performance."},[s.HANDLER_EXISTS]:{message:"Handler already registered with this name",retryable:!1,suggestion:"Use different handler name or call bus.removeHandler() first."},[s.SEND_FAILED]:{message:"Failed to send message to peer",retryable:!0,suggestion:"Check transport status. Target window may be closed or blocked."},[s.CHANNEL_FAILED]:{message:"Failed to create direct channel",retryable:!0,suggestion:"Check browser support for MessageChannel. Retry after short delay."},[s.CHANNEL_CLOSED]:{message:"Channel was closed unexpectedly",retryable:!1,suggestion:"Target context was destroyed. Check if iframe/worker still exists."},[s.MAX_PEERS]:{message:"Maximum number of peers reached",retryable:!1,suggestion:"Increase maxPeers option or disconnect unused peers first."},[s.MAX_PENDING]:{message:"Maximum pending requests reached",retryable:!1,suggestion:"Wait for pending requests to complete. Increase maxPendingRequests option."},[s.DESTROYED]:{message:"CrossBus instance has been destroyed",retryable:!1,suggestion:"Create new CrossBus instance. Do not use bus after calling destroy()."},[s.CIRCUIT_OPEN]:{message:"Circuit breaker is open",retryable:!1,suggestion:"Too many failures. Wait for circuit to reset or call circuit.reset()."},[s.PAYLOAD_TOO_LARGE]:{message:"Payload exceeds maximum allowed size",retryable:!1,suggestion:"Reduce payload size or increase maxPayloadSize option. Consider using streaming for large data."},[s.RATE_LIMITED]:{message:"Request rate limit exceeded",retryable:!0,suggestion:"Wait before retrying. Consider adding delay or using exponential backoff."},[s.UNAUTHORIZED]:{message:"Peer is not authorized to call this handler",retryable:!1,suggestion:"Add peer to handler allowedPeers list or remove peer restrictions."},[s.INVALID_PAYLOAD]:{message:"Payload validation failed",retryable:!1,suggestion:"Check payload structure against handler requirements."}});class r extends Error{code;details;retryable;cause;timestamp;constructor(e,s,i={}){const a=t[e]??{message:"Unknown error",retryable:!1};super(s??a.message),this.name="CrossBusError",this.code=e,this.details=i.details??{},this.retryable=i.retryable??a.retryable,this.cause=i.cause,this.timestamp=Date.now(),Error.captureStackTrace&&Error.captureStackTrace(this,r)}static from(e,s={}){return new r(e,void 0,{details:s})}static wrap(e,s,t={}){return new r(e,s.message,{cause:s,details:t})}toJSON(){return{name:this.name,code:this.code,message:this.message,details:this.details,retryable:this.retryable,timestamp:this.timestamp}}toString(){return`${this.name} [${this.code}]: ${this.message}`}}const i=Object.freeze({CLOSED:"closed",OPEN:"open",HALF_OPEN:"half_open"}),a={failureThreshold:5,successThreshold:2,resetTimeout:3e4,onStateChange:null,isFailure(){return!0}};class n{#e=i.CLOSED;#s=0;#t=0;#r=null;#i=null;#a;#n=0;#o=0;#E=0;constructor(e={}){this.#a={...a,...e}}get state(){return this.#l(),this.#e}get failures(){return this.#s}get stats(){return{state:this.state,failures:this.#s,successes:this.#t,totalRequests:this.#n,totalFailures:this.#o,totalSuccesses:this.#E,lastFailureTime:this.#r,openedAt:this.#i}}get isOpen(){return this.state===i.OPEN}get isClosed(){return this.state===i.CLOSED}async execute(e){if(this.#n++,this.state===i.OPEN)throw r.from(s.CIRCUIT_OPEN,{state:this.#e,openedAt:this.#i,failures:this.#s});try{const s=await e();return this.#g(),s}catch(e){throw this.#a.isFailure&&this.#a.isFailure(e)&&this.#u(),e}}reset(){const e=this.#e;this.#e=i.CLOSED,this.#s=0,this.#t=0,this.#i=null,e!==i.CLOSED&&this.#c(e,i.CLOSED)}trip(){const e=this.#e;e!==i.OPEN&&(this.#e=i.OPEN,this.#i=Date.now(),this.#c(e,i.OPEN))}#g(){if(this.#E++,this.#e===i.HALF_OPEN){if(this.#t++,this.#t>=(this.#a.successThreshold||2)){const e=this.#e;this.#e=i.CLOSED,this.#s=0,this.#t=0,this.#i=null,this.#c(e,i.CLOSED)}}else this.#e===i.CLOSED&&(this.#s=0)}#u(){if(this.#o++,this.#r=Date.now(),this.#s++,this.#e===i.HALF_OPEN){const e=this.#e;this.#e=i.OPEN,this.#i=Date.now(),this.#t=0,this.#c(e,i.OPEN)}else if(this.#e===i.CLOSED&&this.#s>=(this.#a.failureThreshold||5)){const e=this.#e;this.#e=i.OPEN,this.#i=Date.now(),this.#c(e,i.OPEN)}}#l(){if(this.#e===i.OPEN&&this.#i&&Date.now()-this.#i>=(this.#a.resetTimeout||3e4)){const e=this.#e;this.#e=i.HALF_OPEN,this.#t=0,this.#c(e,i.HALF_OPEN)}}#c(e,s){this.#a.onStateChange&&this.#a.onStateChange({from:e,to:s,timestamp:Date.now()})}}export{n as CircuitBreaker,i as CircuitState,a as DEFAULT_CIRCUIT_OPTIONS,e as createPeerCircuitBreaker};
//# sourceMappingURL=circuit-breaker.min.js.map
