function t(t,o={}){const{compressHook:s,decompressHook:r}=e.createCompressedHooks(o);return t.addOutboundHook(s),t.addInboundHook(r),t}class e{static DEFAULT_ALGORITHM="gzip";static isSupported(){return"undefined"!=typeof CompressionStream&&"undefined"!=typeof DecompressionStream}static estimateSize(t){const e=JSON.stringify(t);return(new TextEncoder).encode(e).length}static async compress(t,e={}){const o=e.algorithm??this.DEFAULT_ALGORITHM,s=(new TextEncoder).encode(JSON.stringify(t)),r=new CompressionStream(o),n=r.writable.getWriter(),a=r.readable.getReader();n.write(s),n.close();const c=[];for(;;){const{done:t,value:e}=await a.read();if(t)break;c.push(e)}const i=new Uint8Array(c.reduce((t,e)=>t+e.length,0));let m=0;for(const t of c)i.set(t,m),m+=t.length;return{t:!0,data:this.#t(i.buffer),algorithm:o}}static async decompress(t){const e=t.algorithm??this.DEFAULT_ALGORITHM,o=this.#e(t.data),s=new DecompressionStream(e),r=s.writable.getWriter(),n=s.readable.getReader();r.write(new Uint8Array(o)),r.close();const a=[];for(;;){const{done:t,value:e}=await n.read();if(t)break;a.push(e)}const c=new Uint8Array(a.reduce((t,e)=>t+e.length,0));let i=0;for(const t of a)c.set(t,i),i+=t.length;const m=new TextDecoder;return JSON.parse(m.decode(c))}static createCompressedHooks(t={}){const{threshold:e=0,algorithm:o=this.DEFAULT_ALGORITHM}=t;return{compressHook:async t=>t&&t.t||e>0&&this.estimateSize(t)<e?t:await this.compress(t,{algorithm:o}),decompressHook:async t=>t&&t.t?await this.decompress(t):t}}static#t(t){const e=new Uint8Array(t);let o="";for(let t=0;t<e.length;t++)o+=String.fromCharCode(e[t]);return btoa(o)}static#e(t){const e=atob(t),o=new Uint8Array(e.length);for(let t=0;t<e.length;t++)o[t]=e.charCodeAt(t);return o.buffer}}export{e as Compression,t as withCompression};
//# sourceMappingURL=compression.min.js.map
