{"version":3,"file":"encryption.min.js","sources":["../../src/plugins/encryption.js"],"sourcesContent":["/**\n * @fileoverview Encryption plugin for CrossBus.\n * Provides AES-GCM encryption for message payloads using Web Crypto API.\n * \n * @module plugins/encryption\n */\n\n/**\n * @typedef {Object} EncryptedPayload\n * @property {boolean} _encrypted - Marker indicating encrypted content\n * @property {string} ciphertext - Base64-encoded encrypted data\n * @property {string} iv - Base64-encoded initialization vector\n */\n\n/**\n * @typedef {Object} EncryptionOptions\n * @property {boolean} [enabled=true] - Whether encryption is enabled\n */\n\n/**\n * Encryption utilities for CrossBus messages.\n * Uses AES-256-GCM for authenticated encryption.\n * \n * @example\n * import { Encryption } from 'crossbus/plugins/encryption';\n * \n * // Generate or derive a key\n * const key = await Encryption.generateKey();\n * // or: const key = await Encryption.deriveKey('password', 'salt');\n * \n * // Use with CrossBus hooks\n * const { encryptHook, decryptHook } = Encryption.createEncryptedHooks(key);\n * bus.addOutboundHook(encryptHook);\n * bus.addInboundHook(decryptHook);\n * \n * // Now all messages are automatically encrypted!\n */\nexport class Encryption {\n    static ALGORITHM = 'AES-GCM';\n    static KEY_LENGTH = 256;\n    static IV_LENGTH = 12; // 96 bits recommended for GCM\n\n    /**\n     * Generates a new random AES-256 key.\n     * \n     * @returns {Promise<CryptoKey>} Generated key\n     */\n    static async generateKey() {\n        return await crypto.subtle.generateKey(\n            {\n                name: this.ALGORITHM,\n                length: this.KEY_LENGTH\n            },\n            true, // extractable\n            ['encrypt', 'decrypt']\n        );\n    }\n\n    /**\n     * Derives a key from a password using PBKDF2.\n     * \n     * @param {string} password - User password\n     * @param {string} salt - Salt for key derivation (should be unique per user/session)\n     * @param {number} [iterations=100000] - PBKDF2 iterations\n     * @returns {Promise<CryptoKey>} Derived key\n     */\n    static async deriveKey(password, salt, iterations = 100000) {\n        const encoder = new TextEncoder();\n\n        // Import password as key material\n        const keyMaterial = await crypto.subtle.importKey(\n            'raw',\n            encoder.encode(password),\n            'PBKDF2',\n            false,\n            ['deriveKey']\n        );\n\n        // Derive AES key\n        return await crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt: encoder.encode(salt),\n                iterations,\n                hash: 'SHA-256'\n            },\n            keyMaterial,\n            {\n                name: this.ALGORITHM,\n                length: this.KEY_LENGTH\n            },\n            true,\n            ['encrypt', 'decrypt']\n        );\n    }\n\n    /**\n     * Exports a CryptoKey to base64 string for storage.\n     * \n     * @param {CryptoKey} key - Key to export\n     * @returns {Promise<string>} Base64-encoded key\n     */\n    static async exportKey(key) {\n        const exported = await crypto.subtle.exportKey('raw', key);\n        return this.#arrayBufferToBase64(exported);\n    }\n\n    /**\n     * Imports a key from base64 string.\n     * \n     * @param {string} keyStr - Base64-encoded key\n     * @returns {Promise<CryptoKey>} Imported key\n     */\n    static async importKey(keyStr) {\n        const keyData = this.#base64ToArrayBuffer(keyStr);\n        return await crypto.subtle.importKey(\n            'raw',\n            keyData,\n            {\n                name: this.ALGORITHM,\n                length: this.KEY_LENGTH\n            },\n            true,\n            ['encrypt', 'decrypt']\n        );\n    }\n\n    /**\n     * Encrypts a payload.\n     * \n     * @param {any} payload - Data to encrypt (will be JSON serialized)\n     * @param {CryptoKey} key - Encryption key\n     * @returns {Promise<EncryptedPayload>} Encrypted payload\n     */\n    static async encrypt(payload, key) {\n        // Wrap payload with timestamp for replay protection\n        const wrapped = {\n            data: payload,\n            _ts: Date.now()\n        };\n\n        const encoder = new TextEncoder();\n        const data = encoder.encode(JSON.stringify(wrapped));\n\n        // Generate random IV\n        const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));\n\n        // Encrypt\n        const ciphertext = await crypto.subtle.encrypt(\n            {\n                name: this.ALGORITHM,\n                iv\n            },\n            key,\n            data\n        );\n\n        return {\n            _encrypted: true,\n            ciphertext: this.#arrayBufferToBase64(ciphertext),\n            iv: this.#arrayBufferToBase64(iv)\n        };\n    }\n\n    /**\n     * Decrypts an encrypted payload.\n     * \n     * @param {EncryptedPayload} encrypted - Encrypted payload\n     * @param {CryptoKey} key - Decryption key\n     * @param {Object} [options={}] - Decryption options\n     * @param {number} [options.ttl=60000] - Time-to-live window in ms (replay protection)\n     * @returns {Promise<any>} Decrypted payload\n     * @throws {Error} If message is expired (replay attack)\n     */\n    static async decrypt(encrypted, key, options = {}) {\n        const ciphertext = this.#base64ToArrayBuffer(encrypted.ciphertext);\n        const iv = this.#base64ToArrayBuffer(encrypted.iv);\n\n        const decrypted = await crypto.subtle.decrypt(\n            {\n                name: this.ALGORITHM,\n                iv\n            },\n            key,\n            ciphertext\n        );\n\n        const decoder = new TextDecoder();\n        const unwrapped = JSON.parse(decoder.decode(decrypted));\n\n        // Handle legacy payloads (no timestamp) vs new wrapped payloads\n        const payload = unwrapped._ts ? unwrapped.data : unwrapped;\n        const timestamp = unwrapped._ts;\n\n        // Replay protection check\n        if (timestamp) {\n            const ttl = options.ttl ?? 60000;\n            const now = Date.now();\n\n            // Check if expired\n            if (now - timestamp > ttl) {\n                throw new Error(`Message expired (replay attack detected). Age: ${now - timestamp}ms, TTL: ${ttl}ms`);\n            }\n\n            // Check for future timestamps (clock skew/manipulation)\n            if (timestamp > now + 5000) { // Allow 5s slack\n                console.warn('[CrossBus] Detected future timestamp in encrypted message (clock skew?)');\n            }\n        }\n\n        return payload;\n    }\n\n    /**\n     * Creates hook functions for automatic encryption/decryption.\n     * \n     * @param {CryptoKey} key - Encryption key\n     * @returns {{ encryptHook: import('../core/cross-bus.js').MessageHook, decryptHook: import('../core/cross-bus.js').MessageHook }}\n     * \n     * @example\n     * const { encryptHook, decryptHook } = Encryption.createEncryptedHooks(key);\n     * bus.addOutboundHook(encryptHook);\n     * bus.addInboundHook(decryptHook);\n     */\n    static createEncryptedHooks(key) {\n        return {\n            encryptHook: async (payload, context) => {\n                // Skip if already encrypted\n                if (payload && payload._encrypted) return payload;\n                return await this.encrypt(payload, key);\n            },\n\n            decryptHook: async (payload, context) => {\n                // Skip if not encrypted\n                if (!payload || !payload._encrypted) return payload;\n                return await this.decrypt(payload, key);\n            }\n        };\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Private helpers\n    // ─────────────────────────────────────────────────────────────────\n\n    static #arrayBufferToBase64(buffer) {\n        const bytes = new Uint8Array(buffer);\n        let binary = '';\n        for (let i = 0; i < bytes.length; i++) {\n            binary += String.fromCharCode(bytes[i]);\n        }\n        return btoa(binary);\n    }\n\n    static #base64ToArrayBuffer(base64) {\n        const binary = atob(base64);\n        const bytes = new Uint8Array(binary.length);\n        for (let i = 0; i < binary.length; i++) {\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes.buffer;\n    }\n}\n\n/**\n * Helper to create an encrypted CrossBus instance.\n * \n * @param {import(\"../core/cross-bus.js\").CrossBus} bus - CrossBus instance\n * @param {CryptoKey} key - Encryption key\n * @returns {import(\"../core/cross-bus.js\").CrossBus} Same bus with encryption hooks installed\n * \n * @example\n * const bus = new CrossBus({ peerId: 'secure-agent' });\n * const key = await Encryption.deriveKey('password', 'salt');\n * withEncryption(bus, key);\n * // All messages now encrypted automatically\n */\nexport function withEncryption(bus, key) {\n    const { encryptHook, decryptHook } = Encryption.createEncryptedHooks(key);\n    bus.addOutboundHook(encryptHook);\n    bus.addInboundHook(decryptHook);\n    return bus;\n}\n"],"names":["withEncryption","bus","key","encryptHook","decryptHook","Encryption","createEncryptedHooks","addOutboundHook","addInboundHook","static","generateKey","crypto","subtle","name","this","ALGORITHM","length","KEY_LENGTH","deriveKey","password","salt","iterations","encoder","TextEncoder","keyMaterial","importKey","encode","hash","exportKey","exported","arrayBufferToBase64","keyStr","keyData","base64ToArrayBuffer","encrypt","payload","wrapped","data","_ts","Date","now","JSON","stringify","iv","getRandomValues","Uint8Array","IV_LENGTH","ciphertext","_encrypted","decrypt","encrypted","options","decrypted","decoder","TextDecoder","unwrapped","parse","decode","timestamp","ttl","Error","async","buffer","bytes","binary","i","String","fromCharCode","btoa","base64","atob","charCodeAt"],"mappings":"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"}