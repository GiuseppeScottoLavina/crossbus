{"version":3,"file":"compression.min.js","sources":["../../src/plugins/compression.js"],"sourcesContent":["/**\n * @fileoverview Compression plugin for CrossBus.\n * Compresses message payloads using CompressionStream API.\n * \n * @module plugins/compression\n */\n\n/**\n * @typedef {Object} CompressedPayload\n * @property {boolean} _compressed - Marker indicating compressed content\n * @property {string} data - Base64-encoded compressed data\n * @property {string} algorithm - Compression algorithm used\n */\n\n/**\n * @typedef {Object} CompressionOptions\n * @property {'gzip' | 'deflate' | 'deflate-raw'} [algorithm='gzip'] - Compression algorithm\n * @property {number} [threshold=0] - Minimum payload size to compress (bytes)\n */\n\n/**\n * @typedef {Object} CompressionStream\n * @property {WritableStream} writable\n * @property {ReadableStream} readable\n */\n\n/**\n * @typedef {Object} DecompressionStream\n * @property {WritableStream} writable\n * @property {ReadableStream} readable\n */\n\n/**\n * @typedef {'gzip' | 'deflate' | 'deflate-raw'} CompressionFormat\n */\n\n/**\n * Compression utilities for CrossBus messages.\n * Uses native CompressionStream API for efficiency.\n * \n * @example\n * import { Compression } from 'crossbus/plugins/compression';\n * \n * // Use with CrossBus hooks\n * const { compressHook, decompressHook } = Compression.createCompressedHooks();\n * bus.addOutboundHook(compressHook);\n * bus.addInboundHook(decompressHook);\n * \n * // Now large messages are automatically compressed!\n */\nexport class Compression {\n    static DEFAULT_ALGORITHM = 'gzip';\n\n    /**\n     * Checks if CompressionStream API is supported.\n     * \n     * @returns {boolean}\n     */\n    static isSupported() {\n        return typeof CompressionStream !== 'undefined' &&\n            typeof DecompressionStream !== 'undefined';\n    }\n\n    /**\n     * Estimates the size of a payload in bytes.\n     * \n     * @param {any} payload - Payload to estimate\n     * @returns {number} Estimated size in bytes\n     */\n    static estimateSize(payload) {\n        const json = JSON.stringify(payload);\n        return new TextEncoder().encode(json).length;\n    }\n\n    /**\n     * Compresses a payload.\n     * \n     * @param {any} payload - Data to compress (will be JSON serialized)\n     * @param {CompressionOptions} [options={}] - Compression options\n     * @returns {Promise<CompressedPayload>} Compressed payload\n     */\n    static async compress(payload, options = {}) {\n        const algorithm = options.algorithm ?? this.DEFAULT_ALGORITHM;\n\n        const encoder = new TextEncoder();\n        const data = encoder.encode(JSON.stringify(payload));\n\n        // Create compression stream\n        // @ts-ignore - Types not yet in all TS libs\n        const cs = new CompressionStream(/** @type {any} */(algorithm));\n        const writer = cs.writable.getWriter();\n        const reader = cs.readable.getReader();\n\n        // Write data\n        writer.write(data);\n        writer.close();\n\n        // Read compressed chunks\n        const chunks = [];\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n            chunks.push(value);\n        }\n\n        // Combine chunks\n        const compressed = new Uint8Array(\n            chunks.reduce((acc, chunk) => acc + chunk.length, 0)\n        );\n        let offset = 0;\n        for (const chunk of chunks) {\n            compressed.set(chunk, offset);\n            offset += chunk.length;\n        }\n\n        return {\n            _compressed: true,\n            data: this.#arrayBufferToBase64(compressed.buffer),\n            algorithm\n        };\n    }\n\n    /**\n     * Decompresses a compressed payload.\n     * \n     * @param {CompressedPayload} compressed - Compressed payload\n     * @returns {Promise<any>} Decompressed payload\n     */\n    static async decompress(compressed) {\n        const algorithm = compressed.algorithm ?? this.DEFAULT_ALGORITHM;\n        const data = this.#base64ToArrayBuffer(compressed.data);\n\n        // Create decompression stream\n        // @ts-ignore - Types not yet in all TS libs\n        const ds = new DecompressionStream(/** @type {any} */(algorithm));\n        const writer = ds.writable.getWriter();\n        const reader = ds.readable.getReader();\n\n        // Write compressed data\n        writer.write(new Uint8Array(data));\n        writer.close();\n\n        // Read decompressed chunks\n        const chunks = [];\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n            chunks.push(value);\n        }\n\n        // Combine chunks\n        const decompressed = new Uint8Array(\n            chunks.reduce((acc, chunk) => acc + chunk.length, 0)\n        );\n        let offset = 0;\n        for (const chunk of chunks) {\n            decompressed.set(chunk, offset);\n            offset += chunk.length;\n        }\n\n        const decoder = new TextDecoder();\n        return JSON.parse(decoder.decode(decompressed));\n    }\n\n    /**\n     * Creates hook functions for automatic compression/decompression.\n     * \n     * @param {CompressionOptions} [options={}] - Compression options\n     * @returns {{ compressHook: import('../core/cross-bus.js').MessageHook, decompressHook: import('../core/cross-bus.js').MessageHook }}\n     * \n     * @example\n     * const { compressHook, decompressHook } = Compression.createCompressedHooks({\n     *   algorithm: 'gzip',\n     *   threshold: 1024 // Only compress payloads > 1KB\n     * });\n     * bus.addOutboundHook(compressHook);\n     * bus.addInboundHook(decompressHook);\n     */\n    static createCompressedHooks(options = {}) {\n        const { threshold = 0, algorithm = this.DEFAULT_ALGORITHM } = options;\n\n        return {\n            compressHook: async (payload, context) => {\n                // Skip if already compressed\n                if (payload && payload._compressed) return payload;\n\n                // Skip if below threshold\n                if (threshold > 0 && this.estimateSize(payload) < threshold) {\n                    return payload;\n                }\n\n                return await this.compress(payload, { algorithm: /** @type {CompressionFormat} */(algorithm) });\n            },\n\n            decompressHook: async (payload, context) => {\n                // Skip if not compressed\n                if (!payload || !payload._compressed) return payload;\n                return await this.decompress(payload);\n            }\n        };\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Private helpers\n    // ─────────────────────────────────────────────────────────────────\n\n    static #arrayBufferToBase64(buffer) {\n        const bytes = new Uint8Array(buffer);\n        let binary = '';\n        for (let i = 0; i < bytes.length; i++) {\n            binary += String.fromCharCode(bytes[i]);\n        }\n        return btoa(binary);\n    }\n\n    static #base64ToArrayBuffer(base64) {\n        const binary = atob(base64);\n        const bytes = new Uint8Array(binary.length);\n        for (let i = 0; i < binary.length; i++) {\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes.buffer;\n    }\n}\n\n/**\n * Helper to add compression to a CrossBus instance.\n * \n * @param {import(\"../core/cross-bus.js\").CrossBus} bus - CrossBus instance\n * @param {CompressionOptions} [options={}] - Compression options\n * @returns {import(\"../core/cross-bus.js\").CrossBus} Same bus with compression hooks installed\n * \n * @example\n * withCompression(bus, { threshold: 1024 });\n * // Large messages now compressed automatically\n */\nexport function withCompression(bus, options = {}) {\n    const { compressHook, decompressHook } = Compression.createCompressedHooks(options);\n    bus.addOutboundHook(compressHook);\n    bus.addInboundHook(decompressHook);\n    return bus;\n}\n"],"names":["withCompression","bus","options","compressHook","decompressHook","Compression","createCompressedHooks","addOutboundHook","addInboundHook","static","isSupported","CompressionStream","DecompressionStream","estimateSize","payload","json","JSON","stringify","TextEncoder","encode","length","compress","algorithm","this","DEFAULT_ALGORITHM","data","cs","writer","writable","getWriter","reader","readable","getReader","write","close","chunks","done","value","read","push","compressed","Uint8Array","reduce","acc","chunk","offset","set","_compressed","arrayBufferToBase64","buffer","decompress","base64ToArrayBuffer","ds","decompressed","decoder","TextDecoder","parse","decode","threshold","async","bytes","binary","i","String","fromCharCode","btoa","base64","atob","charCodeAt"],"mappings":"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"}