{"version":3,"file":"batch.min.js","sources":["../../src/plugins/batch.js"],"sourcesContent":["/**\n * @fileoverview Message Batching plugin for CrossBus.\n * Collects messages and sends them in batches to reduce postMessage overhead.\n * @module plugins/batch\n */\n\n/**\n * @typedef {Object} BatchOptions\n * @property {number} [windowMs=16] - Time window for batching (default: 1 frame @ 60fps)\n * @property {number} [maxBatchSize=100] - Maximum messages per batch\n * @property {boolean} [useRaf=true] - Use requestAnimationFrame for timing\n */\n\n/**\n * Message Batcher for high-frequency messaging scenarios.\n * \n * Instead of sending each message immediately, this plugin:\n * 1. Queues messages for a short time window (default: 16ms / 1 frame)\n * 2. Sends all messages as a single batch\n * 3. Automatically unbatches on the receiving side\n * \n * **Performance Impact:**\n * - 2-5x throughput improvement for high-frequency signals\n * - Reduces postMessage call overhead\n * - Ideal for streaming data, telemetry, mouse/touch events\n * \n * @example\n * import { CrossBus } from 'crossbus';\n * import { withBatching } from 'crossbus/plugins/batch';\n * \n * const bus = new CrossBus({ peerId: 'sender' });\n * withBatching(bus, { windowMs: 16 });\n * \n * // These 100 signals are sent as ~6 batches instead of 100 calls\n * for (let i = 0; i < 100; i++) {\n *   bus.signal('telemetry', { value: i });\n * }\n */\nexport class MessageBatcher {\n    /** @type {number} */\n    #windowMs;\n\n    /** @type {number} */\n    #maxBatchSize;\n\n    /** @type {boolean} */\n    #useRaf;\n\n    /** @type {Map<string, Object[]>} Batches per peer */\n    #batches = new Map();\n\n    /** @type {ReturnType<typeof setTimeout>|number|null} */\n    #flushTimer = null;\n\n    /** @type {boolean} */\n    #flushScheduled = false;\n\n    /** @type {((batch: Object[]) => void)|null} */\n    #sendFn = null;\n\n    /** @type {number} */\n    #batchesSent = 0;\n\n    /** @type {number} */\n    #messagesBatched = 0;\n\n    /**\n     * Creates a new MessageBatcher.\n     * \n     * @param {BatchOptions} [options={}]\n     */\n    constructor(options = {}) {\n        this.#windowMs = options.windowMs ?? 16;\n        this.#maxBatchSize = options.maxBatchSize ?? 100;\n        this.#useRaf = options.useRaf ?? (typeof requestAnimationFrame !== 'undefined');\n    }\n\n    /**\n     * Queues a message for batching.\n     * \n     * @param {Object} message - Message to queue\n     * @returns {boolean} True if message was queued\n     */\n    queue(message) {\n        const key = 'default';  // Could be per-peer in future\n\n        if (!this.#batches.has(key)) {\n            this.#batches.set(key, []);\n        }\n\n        const batch = this.#batches.get(key);\n        if (batch) {\n            batch.push(message);\n            this.#messagesBatched++;\n\n            // Flush if batch is full\n            if (batch.length >= this.#maxBatchSize) {\n                this.#flushBatch(key);\n            } else if (!this.#flushScheduled) {\n                this.#scheduleFlush();\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Sets the function to call when flushing batches.\n     * \n     * @param {(batch: Object[]) => void} fn\n     */\n    onFlush(fn) {\n        this.#sendFn = fn;\n    }\n\n    /**\n     * Manually flushes all pending batches.\n     */\n    flush() {\n        for (const key of this.#batches.keys()) {\n            this.#flushBatch(key);\n        }\n    }\n\n    /**\n     * Gets statistics.\n     */\n    get stats() {\n        return {\n            batchesSent: this.#batchesSent,\n            messagesBatched: this.#messagesBatched,\n            pendingMessages: this.#getPendingCount(),\n            avgBatchSize: this.#batchesSent > 0\n                ? Math.round(this.#messagesBatched / this.#batchesSent)\n                : 0\n        };\n    }\n\n    /**\n     * Resets statistics.\n     */\n    resetStats() {\n        this.#batchesSent = 0;\n        this.#messagesBatched = 0;\n    }\n\n    /**\n     * Destroys the batcher.\n     */\n    destroy() {\n        if (this.#flushTimer !== null) {\n            if (this.#useRaf && typeof cancelAnimationFrame !== 'undefined') {\n                cancelAnimationFrame(/** @type {number} */(this.#flushTimer));\n            } else {\n                clearTimeout(/** @type {ReturnType<typeof setTimeout>} */(this.#flushTimer));\n            }\n        }\n        this.#batches.clear();\n        this.#sendFn = null;\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Private methods\n    // ─────────────────────────────────────────────────────────────────\n\n    #scheduleFlush() {\n        this.#flushScheduled = true;\n\n        if (this.#useRaf && typeof requestAnimationFrame !== 'undefined') {\n            this.#flushTimer = requestAnimationFrame(() => {\n                this.#flushScheduled = false;\n                this.flush();\n            });\n        } else {\n            this.#flushTimer = setTimeout(() => {\n                this.#flushScheduled = false;\n                this.flush();\n            }, this.#windowMs);\n        }\n    }\n\n    #flushBatch(key) {\n        const batch = this.#batches.get(key);\n        if (!batch || batch.length === 0) return;\n\n        if (this.#sendFn) {\n            this.#sendFn(batch);\n            this.#batchesSent++;\n        }\n\n        this.#batches.set(key, []);\n    }\n\n    #getPendingCount() {\n        let count = 0;\n        for (const batch of this.#batches.values()) {\n            count += batch.length;\n        }\n        return count;\n    }\n}\n\n/**\n * Batch envelope type marker.\n */\nexport const BATCH_TYPE = '__crossbus_batch__';\n\n/**\n * Wraps a CrossBus to batch outgoing signals.\n * \n * @param {import('../core/cross-bus.js').CrossBus} bus - CrossBus instance\n * @param {BatchOptions} [options={}]\n * @returns {import('../core/cross-bus.js').CrossBus} Same bus with batching installed\n * \n * @example\n * const bus = new CrossBus({ peerId: 'high-freq-sender' });\n * withBatching(bus, { windowMs: 16 });\n * \n * // Rapid signals are now batched\n * for (let i = 0; i < 1000; i++) {\n *   bus.signal('data', { n: i });\n * }\n */\nexport function withBatching(bus, options = {}) {\n    const batcher = new MessageBatcher(options);\n\n    // Wrap the signal method\n    const originalSignal = bus.signal.bind(bus);\n\n    batcher.onFlush((batch) => {\n        // Send batch as a single message\n        originalSignal(BATCH_TYPE, { messages: batch });\n    });\n\n    // Override signal to queue\n    /** @type {any} */ (bus).signal = (/** @type {string} */ event, /** @type {any} */ data) => {\n        batcher.queue({ event, data });\n    };\n\n    // Add inbound hook to unbatch\n    bus.addInboundHook((payload, context) => {\n        if (payload && payload.messages && Array.isArray(payload.messages)) {\n            // Emit each message in the batch\n            for (const msg of payload.messages) {\n                bus.emit(msg.event, msg.data);\n            }\n            return null; // Don't pass batch through\n        }\n        return payload;\n    });\n\n    // Expose batcher for stats/control\n    // @ts-ignore - adding custom property\n    bus._batcher = batcher;\n\n    return bus;\n}\n\n/**\n * Creates a standalone batcher for custom use cases.\n * \n * @param {BatchOptions} options\n * @returns {MessageBatcher}\n */\nexport function createBatcher(options = {}) {\n    return new MessageBatcher(options);\n}\n"],"names":["withBatching","bus","options","batcher","MessageBatcher","originalSignal","signal","bind","onFlush","batch","BATCH_TYPE","messages","event","data","queue","addInboundHook","payload","Array","isArray","msg","emit","_batcher","createBatcher","windowMs","maxBatchSize","useRaf","batches","Map","flushTimer","flushScheduled","sendFn","batchesSent","messagesBatched","constructor","this","requestAnimationFrame","message","key","has","set","get","push","length","flushBatch","scheduleFlush","fn","flush","keys","stats","pendingMessages","getPendingCount","avgBatchSize","Math","round","resetStats","destroy","cancelAnimationFrame","clearTimeout","clear","setTimeout","count","values"],"mappings":"AA+NO,SAASA,EAAaC,EAAKC,EAAU,IACxC,MAAMC,EAAU,IAAIC,EAAeF,GAG7BG,EAAiBJ,EAAIK,OAAOC,KAAKN,GA4BvC,OA1BAE,EAAQK,QAASC,IAEbJ,EAAeK,EAAY,CAAEC,SAAUF,MAIxB,EAAMH,OAAS,CAAuBM,EAA0BC,KAC/EV,EAAQW,MAAM,CAAEF,QAAOC,UAI3BZ,EAAIc,eAAgBC,IAChB,GAAIA,GAAWA,EAAQL,UAAYM,MAAMC,QAAQF,EAAQL,UAAW,CAEhE,IAAK,MAAMQ,KAAOH,EAAQL,SACtBV,EAAImB,KAAKD,EAAIP,MAAOO,EAAIN,MAE5B,OAAO,IACX,CACA,OAAOG,IAKXf,EAAIoB,EAAWlB,EAERF,CACX,CAQO,SAASqB,EAAcpB,EAAU,IACpC,OAAO,IAAIE,EAAeF,EAC9B,CApOO,MAAME,EAETmB,GAGAC,GAGAC,GAGAC,GAAW,IAAIC,IAGfC,GAAc,KAGdC,IAAkB,EAGlBC,GAAU,KAGVC,GAAe,EAGfC,GAAmB,EAOnB,WAAAC,CAAY/B,EAAU,IAClBgC,MAAKX,EAAYrB,EAAQqB,UAAY,GACrCW,MAAKV,EAAgBtB,EAAQsB,cAAgB,IAC7CU,MAAKT,EAAUvB,EAAQuB,QAA4C,oBAA1BU,qBAC7C,CAQA,KAAArB,CAAMsB,GACF,MAAMC,EAAM,UAEPH,MAAKR,EAASY,IAAID,IACnBH,MAAKR,EAASa,IAAIF,EAAK,IAG3B,MAAM5B,EAAQyB,MAAKR,EAASc,IAAIH,GAahC,OAZI5B,IACAA,EAAMgC,KAAKL,GACXF,MAAKF,IAGDvB,EAAMiC,QAAUR,MAAKV,EACrBU,MAAKS,EAAYN,GACTH,MAAKL,GACbK,MAAKU,MAIN,CACX,CAOA,OAAApC,CAAQqC,GACJX,MAAKJ,EAAUe,CACnB,CAKA,KAAAC,GACI,IAAK,MAAMT,KAAOH,MAAKR,EAASqB,OAC5Bb,MAAKS,EAAYN,EAEzB,CAKA,SAAIW,GACA,MAAO,CACHjB,YAAaG,MAAKH,EAClBC,gBAAiBE,MAAKF,EACtBiB,gBAAiBf,MAAKgB,IACtBC,aAAcjB,MAAKH,EAAe,EAC5BqB,KAAKC,MAAMnB,MAAKF,EAAmBE,MAAKH,GACxC,EAEd,CAKA,UAAAuB,GACIpB,MAAKH,EAAe,EACpBG,MAAKF,EAAmB,CAC5B,CAKA,OAAAuB,GAC6B,OAArBrB,MAAKN,IACDM,MAAKT,GAA2C,oBAAzB+B,qBACvBA,qBAA2CtB,MAAgB,GAE3DuB,aAA0DvB,MAAgB,IAGlFA,MAAKR,EAASgC,QACdxB,MAAKJ,EAAU,IACnB,CAMA,EAAAc,GACIV,MAAKL,GAAkB,EAEnBK,MAAKT,GAA4C,oBAA1BU,sBACvBD,MAAKN,EAAcO,sBAAsB,KACrCD,MAAKL,GAAkB,EACvBK,KAAKY,UAGTZ,MAAKN,EAAc+B,WAAW,KAC1BzB,MAAKL,GAAkB,EACvBK,KAAKY,SACNZ,MAAKX,EAEhB,CAEA,EAAAoB,CAAYN,GACR,MAAM5B,EAAQyB,MAAKR,EAASc,IAAIH,GAC3B5B,GAA0B,IAAjBA,EAAMiC,SAEhBR,MAAKJ,IACLI,MAAKJ,EAAQrB,GACbyB,MAAKH,KAGTG,MAAKR,EAASa,IAAIF,EAAK,IAC3B,CAEA,EAAAa,GACI,IAAIU,EAAQ,EACZ,IAAK,MAAMnD,KAASyB,MAAKR,EAASmC,SAC9BD,GAASnD,EAAMiC,OAEnB,OAAOkB,CACX,EAMQ,MAAClD,EAAa"}