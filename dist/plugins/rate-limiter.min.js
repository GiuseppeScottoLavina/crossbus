function t(t,e={}){const i=new s(e);return t.addOutboundHook(i.createHook({perPeer:!0})),i}class e extends Error{code;retryAfter;constructor(t,e){super(t),this.code="ERR_RATE_LIMITED",this.retryAfter=e}}class s{#t;#e;#s;#i;#r;#h=new Map;constructor(t={}){this.#t=t.maxRequests??100,this.#e=this.#t,this.#s=t.windowMs??1e3,this.#i=Date.now(),this.#r=t.onLimitExceeded??null}tryAcquire(){return this.#n(),this.#e>0?(this.#e--,!0):(this.#r&&this.#r(),!1)}get remaining(){return this.#n(),this.#e}get retryAfter(){const t=Date.now()-this.#i;return Math.max(0,this.#s-t)}reset(){this.#e=this.#t,this.#i=Date.now()}forPeer(t){return this.#h.has(t)||this.#h.set(t,new s({maxRequests:this.#t,windowMs:this.#s,onLimitExceeded:this.#r})),this.#h.get(t)}createHook(t={}){const{perPeer:s=!1,throwOnLimit:i=!0}=t;return(t,r)=>{const h=s&&r.peerId?this.forPeer(r.peerId):this;if(!h.tryAcquire()){if(i)throw new e("Rate limit exceeded",h.retryAfter);return null}return t}}cleanup(t){const e=new Set(t);for(const t of this.#h.keys())e.has(t)||this.#h.delete(t)}#n(){const t=Date.now(),e=t-this.#i;if(e>=this.#s)this.#e=this.#t,this.#i=t;else{const s=Math.floor(e/this.#s*this.#t);s>0&&(this.#e=Math.min(this.#t,this.#e+s),this.#i=t)}}}export{s as RateLimiter,t as withRateLimiter};
//# sourceMappingURL=rate-limiter.min.js.map
