{"version":3,"file":"crossbus.min.js","sources":["../src/common/types.js","../src/core/message-types.js","../src/common/errors.js","../src/common/utils.js","../src/core/presence.js","../src/common/serialization.js","../src/core/event-emitter.js","../src/router/message-router.js","../src/router/pending-requests.js","../src/security/handshake.js","../src/security/origin-validator.js","../src/core/cross-bus.js","../src/core/stream.js","../src/transports/postmessage.js","../src/transports/broadcast-channel.js","../src/transports/message-channel.js","../src/transports/shared-worker.js","../src/transports/service-worker.js","../src/transports/native-bridge.js","../src/transports/websocket.js","../src/ordering/vector-clock.js","../src/ordering/causal-orderer.js"],"sourcesContent":["/**\n * @fileoverview Common types and constants shared across all modules.\n * This module is included in the common bundle to avoid duplication.\n * @module common/types\n */\n\n/**\n * Protocol marker for CrossBus messages.\n * @constant {string}\n */\nexport const PROTOCOL_MARKER = '_cb';\n\n/**\n * Current protocol version.\n * @constant {number}\n */\nexport const PROTOCOL_VERSION = 1;\n\n/**\n * Message type codes (compact for wire efficiency).\n * @readonly\n * @enum {string}\n */\nexport const MessageType = Object.freeze({\n    /** Signal - one-way message */\n    SIGNAL: 'sig',\n    /** Request - expects response */\n    REQUEST: 'req',\n    /** Response - reply to request */\n    RESPONSE: 'res',\n    /** Acknowledge - delivery confirmation */\n    ACK: 'ack',\n    /** Handshake - connection negotiation */\n    HANDSHAKE: 'hsk',\n    HANDSHAKE_INIT: 'hsk_init',\n    HANDSHAKE_ACK: 'hsk_ack',\n    HANDSHAKE_COMPLETE: 'hsk_done',\n    /** Ping - heartbeat */\n    PING: 'png',\n    /** Pong - heartbeat response */\n    PONG: 'pog',\n    /** Goodbye - graceful disconnect */\n    BYE: 'bye',\n    /** Broadcast - message for all peers */\n    BROADCAST: 'bc'\n});\n\n/**\n * Handshake phase codes.\n * @readonly\n * @enum {string}\n */\nexport const HandshakePhase = Object.freeze({\n    INIT: 'init',\n    INIT_SENT: 'init_sent',\n    ACK: 'ack',\n    ACK_SENT: 'ack_sent',\n    DONE: 'done'\n});\n\n/**\n * Peer connection status.\n * @readonly\n * @enum {string}\n */\nexport const PeerStatus = Object.freeze({\n    CONNECTING: 'connecting',\n    CONNECTED: 'connected',\n    DISCONNECTED: 'disconnected',\n    RECONNECTING: 'reconnecting',\n    FAILED: 'failed'\n});\n\n/**\n * Peer type (transport mechanism).\n * @readonly\n * @enum {string}\n */\nexport const PeerType = Object.freeze({\n    IFRAME: 'iframe',\n    WORKER: 'worker',\n    SERVICE_WORKER: 'sw',\n    WINDOW: 'window',\n    PORT: 'port'\n});\n\n/**\n * Delivery status for emit results.\n * @readonly\n * @enum {string}\n */\nexport const DeliveryStatus = Object.freeze({\n    /** Delivered to local listeners only */\n    LOCAL: 'local',\n    /** Sent to peer (no ACK requested) */\n    SENT: 'sent',\n    /** Sent and ACK received */\n    ACKED: 'acked',\n    /** Queued for offline peer */\n    QUEUED: 'queued',\n    /** ACK timeout */\n    TIMEOUT: 'timeout',\n    /** Delivery failed */\n    FAILED: 'failed'\n});\n\n/**\n * Default configuration values.\n * @readonly\n * @type {Object}\n */\nexport const Defaults = Object.freeze({\n    ACK_TIMEOUT: 5000,\n    REQUEST_TIMEOUT: 30000,\n    HANDSHAKE_TIMEOUT: 10000,\n    HEARTBEAT_INTERVAL: 15000,\n    HEARTBEAT_TIMEOUT: 5000,\n    RECONNECT_INTERVAL: 3000,\n    MAX_RECONNECT_ATTEMPTS: 5,\n    MAX_PEERS: 100,\n    MAX_PENDING_REQUESTS: 1000,\n    MAX_QUEUE_SIZE: 100,\n    MAX_MESSAGE_SIZE: 1048576, // 1MB\n    TTL: 5\n});\n\n/**\n * Checks if an object is a valid CrossBus message.\n * \n * @param {*} obj - Object to check.\n * @returns {boolean} True if valid protocol message.\n */\nexport function isProtocolMessage(obj) {\n    return (\n        obj !== null &&\n        typeof obj === 'object' &&\n        obj[PROTOCOL_MARKER] === PROTOCOL_VERSION &&\n        typeof obj.id === 'string' &&\n        (typeof obj.type === 'string' || typeof obj.t === 'string')\n    );\n}\n\n/**\n * List of transferable types for auto-detection.\n * @constant {Function[]}\n */\nexport const TransferableTypes = [\n    ArrayBuffer,\n    MessagePort,\n    // ImageBitmap and OffscreenCanvas are checked dynamically\n    // as they may not exist in all contexts\n];\n\n/**\n * Checks if a value is transferable.\n * \n * @param {*} value - Value to check.\n * @returns {boolean} True if transferable.\n */\nexport function isTransferable(value) {\n    if (value instanceof ArrayBuffer) return true;\n    if (value instanceof MessagePort) return true;\n    if (typeof ImageBitmap !== 'undefined' && value instanceof ImageBitmap) return true;\n    if (typeof OffscreenCanvas !== 'undefined' && value instanceof OffscreenCanvas) return true;\n    if (typeof ReadableStream !== 'undefined' && value instanceof ReadableStream) return true;\n    if (typeof WritableStream !== 'undefined' && value instanceof WritableStream) return true;\n    if (typeof TransformStream !== 'undefined' && value instanceof TransformStream) return true;\n    return false;\n}\n\n/**\n * Recursively finds all transferable objects in a value.\n * \n * @param {*} value - Value to search.\n * @param {Set<Transferable>} [found] - Set to collect transferables.\n * @returns {Transferable[]} Array of transferables found.\n */\nexport function findTransferables(value, found = new Set()) {\n    if (value === null || value === undefined) return Array.from(found);\n\n    if (isTransferable(value)) {\n        found.add(value);\n        return Array.from(found);\n    }\n\n    if (Array.isArray(value)) {\n        for (const item of value) {\n            findTransferables(item, found);\n        }\n    } else if (typeof value === 'object') {\n        for (const key of Object.keys(value)) {\n            findTransferables(value[key], found);\n        }\n    }\n\n    return Array.from(found);\n}\n","/**\n * @fileoverview Protocol message schemas for CrossBus.\n * All message types are frozen for immutability.\n * @module core/message-types\n */\n\n// Import MessageType from common/types to ensure consistent type codes\nimport { MessageType, PROTOCOL_MARKER as PROTOCOL_PREFIX, PROTOCOL_VERSION } from '../common/types.js';\n\n// Re-export for convenience\nexport { MessageType };\n\n/**\n * Delivery status constants.\n * @readonly\n * @enum {string}\n */\nexport const DeliveryStatus = Object.freeze({\n  /** Delivered to local listeners only */\n  LOCAL: 'local',\n  /** Sent to remote peer */\n  REMOTE: 'remote',\n  /** Queued for offline peer */\n  QUEUED: 'queued',\n  /** Delivery failed */\n  FAILED: 'failed'\n});\n\n/**\n * Peer connection status constants.\n * @readonly\n * @enum {string}\n */\nexport const PeerStatus = Object.freeze({\n  /** Connection in progress */\n  CONNECTING: 'connecting',\n  /** Successfully connected */\n  CONNECTED: 'connected',\n  /** Disconnected */\n  DISCONNECTED: 'disconnected',\n  /** Connection failed */\n  FAILED: 'failed'\n});\n\n/**\n * Peer type constants.\n * @readonly\n * @enum {string}\n */\nexport const PeerType = Object.freeze({\n  /** iframe element */\n  IFRAME: 'iframe',\n  /** Web Worker */\n  WORKER: 'worker',\n  /** Service Worker */\n  SERVICE_WORKER: 'service-worker',\n  /** Window (popup, tab) */\n  WINDOW: 'window',\n  /** MessagePort direct connection */\n  PORT: 'port',\n  /** Local (self) */\n  LOCAL: 'local'\n});\n\n// PROTOCOL_PREFIX and PROTOCOL_VERSION are imported from common/types.js\n\n/**\n * Creates a protocol message envelope.\n * \n * @param {MessageType} type - Message type.\n * @param {Object} payload - Message payload.\n * @param {Object} [meta={}] - Additional metadata.\n * @param {string|null} [id=null] - Optional custom message ID.\n * @returns {ProtocolMessage} Frozen message object.\n * \n * @typedef {Object} ProtocolMessage\n * @property {number} _cb - Protocol marker version (compact wire format).\n * @property {number} version - Protocol version.\n * @property {string} id - Unique message ID (UUID v4).\n * @property {MessageType} type - Message type.\n * @property {number} timestamp - Unix timestamp (ms).\n * @property {Object} payload - Message payload.\n * @property {Object} meta - Additional metadata.\n */\nexport function createMessage(type, payload, meta = {}, id = null) {\n  return Object.freeze({\n    [PROTOCOL_PREFIX]: PROTOCOL_VERSION,\n    version: PROTOCOL_VERSION,\n    id: id || crypto.randomUUID(),\n    type,\n    timestamp: Date.now(),\n    payload: Object.freeze({ ...payload }),\n    meta: Object.freeze({ ...meta })\n  });\n}\n\n/**\n * Creates a signal message.\n * \n * @param {string} name - Signal name.\n * @param {*} data - Signal data.\n * @param {string} sourcePeerId - Source peer ID.\n * @param {string|null} [destPeerId] - Destination peer ID.\n * @returns {ProtocolMessage} Signal message.\n */\nexport function createSignalMessage(name, data, sourcePeerId, destPeerId = null) {\n  return createMessage(MessageType.SIGNAL, {\n    name,\n    data,\n    source: sourcePeerId,\n    dest: destPeerId\n  });\n}\n\n/**\n * Creates a broadcast message.\n * \n * @param {string} name - Signal name.\n * @param {*} data - Signal data.\n * @param {string} sourcePeerId - Source peer ID.\n * @param {Object} [options={}] - Broadcast options.\n * @returns {ProtocolMessage} Broadcast message.\n */\nexport function createBroadcastMessage(name, data, sourcePeerId, options = {}) {\n  return createMessage(MessageType.BROADCAST, {\n    name,\n    data,\n    source: sourcePeerId,\n    options\n  });\n}\n\n/**\n * Creates a handshake init message.\n * \n * @param {string} peerId - Initiating peer ID.\n * @param {string} origin - Initiating peer origin.\n * @param {string} challenge - Random challenge string.\n * @returns {ProtocolMessage} Handshake init message.\n */\nexport function createHandshakeInit(peerId, origin, challenge) {\n  return createMessage(MessageType.HANDSHAKE_INIT, {\n    peerId,\n    origin,\n    challenge\n  });\n}\n\n/**\n * Creates a handshake acknowledgment message.\n * \n * @param {string} peerId - Responding peer ID.\n * @param {string} origin - Responding peer origin.\n * @param {string} challenge - Original challenge.\n * @param {string} response - Challenge response.\n * @returns {ProtocolMessage} Handshake ack message.\n */\nexport function createHandshakeAck(peerId, origin, challenge, response) {\n  return createMessage(MessageType.HANDSHAKE_ACK, {\n    peerId,\n    origin,\n    challenge,\n    response\n  });\n}\n\n/**\n * Creates a handshake complete message.\n * \n * @param {string} peerId - Confirming peer ID.\n * @param {boolean} success - Whether handshake succeeded.\n * @returns {ProtocolMessage} Handshake complete message.\n */\nexport function createHandshakeComplete(peerId, success) {\n  return createMessage(MessageType.HANDSHAKE_COMPLETE, {\n    peerId,\n    success\n  });\n}\n\n/**\n * Creates a request message (expecting response).\n * \n * @param {string} name - Request name.\n * @param {*} data - Request data.\n * @param {string} sourcePeerId - Source peer ID.\n * @param {string} destPeerId - Destination peer ID.\n * @param {string|null} [id=null] - Optional custom request ID.\n * @returns {ProtocolMessage} Request message.\n */\nexport function createRequestMessage(name, data, sourcePeerId, destPeerId, id = null) {\n  return createMessage(MessageType.REQUEST, {\n    name,\n    data,\n    source: sourcePeerId,\n    dest: destPeerId\n  }, {}, id);\n}\n\n/**\n * Creates a response message.\n * \n * @param {string} requestId - Original request message ID.\n * @param {*} data - Response data.\n * @param {string} sourcePeerId - Source peer ID.\n * @param {boolean} [success=true] - Whether request succeeded.\n * @param {Object|null} [error] - Error object if failed.\n * @returns {ProtocolMessage} Response message.\n */\nexport function createResponseMessage(requestId, data, sourcePeerId, success = true, error = null) {\n  return createMessage(MessageType.RESPONSE, {\n    requestId,\n    data,\n    source: sourcePeerId,\n    success,\n    error\n  });\n}\n\n/**\n * Validates if an object is a valid CrossBus protocol message.\n * \n * @param {*} obj - Object to validate.\n * @returns {boolean} True if valid protocol message.\n */\nexport function isProtocolMessage(obj) {\n  return (\n    obj !== null &&\n    typeof obj === 'object' &&\n    obj[PROTOCOL_PREFIX] === PROTOCOL_VERSION &&\n    typeof obj.version === 'number' &&\n    typeof obj.id === 'string' &&\n    (typeof obj.type === 'string' || typeof obj.t === 'string') &&\n    typeof obj.timestamp === 'number' &&\n    obj.payload !== undefined\n  );\n}\n\n/**\n * Validates protocol version compatibility.\n * \n * @param {ProtocolMessage} message - Message to check.\n * @returns {boolean} True if version is compatible.\n */\nexport function isCompatibleVersion(message) {\n  return message.version === PROTOCOL_VERSION;\n}\n","/**\n * @fileoverview Centralized error handling for CrossBus.\n * @module common/errors\n */\n\n/**\n * Error codes for CrossBus.\n * @readonly\n * @enum {string}\n */\nexport const ErrorCode = Object.freeze({\n    // Connection errors\n    HANDSHAKE_TIMEOUT: 'ERR_HANDSHAKE_TIMEOUT',\n    HANDSHAKE_REJECTED: 'ERR_HANDSHAKE_REJECTED',\n    ORIGIN_FORBIDDEN: 'ERR_ORIGIN_FORBIDDEN',\n    PEER_EXISTS: 'ERR_PEER_EXISTS',\n    PEER_NOT_FOUND: 'ERR_PEER_NOT_FOUND',\n    PEER_DISCONNECTED: 'ERR_PEER_DISCONNECTED',\n    RECONNECT_FAILED: 'ERR_RECONNECT_FAILED',\n    UNSUPPORTED: 'ERR_UNSUPPORTED',\n    NOT_CONNECTED: 'ERR_NOT_CONNECTED',\n\n    // Message errors\n    ACK_TIMEOUT: 'ERR_ACK_TIMEOUT',\n    RESPONSE_TIMEOUT: 'ERR_RESPONSE_TIMEOUT',\n    QUEUE_FULL: 'ERR_QUEUE_FULL',\n    INVALID_MESSAGE: 'ERR_INVALID_MESSAGE',\n    VERSION_MISMATCH: 'ERR_VERSION_MISMATCH',\n    CLONE_ERROR: 'ERR_CLONE_ERROR',\n    TRANSFER_ERROR: 'ERR_TRANSFER_ERROR',\n    MESSAGE_TOO_LARGE: 'ERR_MESSAGE_TOO_LARGE',\n\n    // Routing errors\n    UNREACHABLE: 'ERR_UNREACHABLE',\n    TTL_EXCEEDED: 'ERR_TTL_EXCEEDED',\n    NO_ROUTE: 'ERR_NO_ROUTE',\n\n    // Handler errors\n    NO_HANDLER: 'ERR_NO_HANDLER',\n    HANDLER_ERROR: 'ERR_HANDLER_ERROR',\n    HANDLER_TIMEOUT: 'ERR_HANDLER_TIMEOUT',\n    HANDLER_EXISTS: 'ERR_HANDLER_EXISTS',\n    SEND_FAILED: 'ERR_SEND_FAILED',\n\n    // Channel errors\n    CHANNEL_FAILED: 'ERR_CHANNEL_FAILED',\n    CHANNEL_CLOSED: 'ERR_CHANNEL_CLOSED',\n\n    // Resource errors\n    MAX_PEERS: 'ERR_MAX_PEERS',\n    MAX_PENDING: 'ERR_MAX_PENDING',\n    DESTROYED: 'ERR_DESTROYED',\n\n    // Circuit Breaker\n    CIRCUIT_OPEN: 'ERR_CIRCUIT_OPEN',\n\n    // Security errors\n    PAYLOAD_TOO_LARGE: 'ERR_PAYLOAD_TOO_LARGE',\n    RATE_LIMITED: 'ERR_RATE_LIMITED',\n    UNAUTHORIZED: 'ERR_UNAUTHORIZED',\n    INVALID_PAYLOAD: 'ERR_INVALID_PAYLOAD'\n});\n\n/**\n * Error metadata including default messages, retryability, and AI-friendly suggestions.\n * @type {Object<ErrorCode, {message: string, retryable: boolean, suggestion: string}>}\n */\nconst ERROR_META = Object.freeze({\n    [ErrorCode.HANDSHAKE_TIMEOUT]: {\n        message: 'Handshake timed out',\n        retryable: true,\n        suggestion: 'Increase timeout or check if target is loaded. Use iframe.onload before connecting.'\n    },\n    [ErrorCode.HANDSHAKE_REJECTED]: {\n        message: 'Handshake rejected by peer',\n        retryable: false,\n        suggestion: 'Check targetOrigin matches the peer\\'s origin. Verify peer allows your origin.'\n    },\n    [ErrorCode.ORIGIN_FORBIDDEN]: {\n        message: 'Origin not in allowed origins list',\n        retryable: false,\n        suggestion: 'Add your origin to allowedOrigins option or use targetOrigin: \"*\" for development.'\n    },\n    [ErrorCode.PEER_EXISTS]: {\n        message: 'Peer with this ID already exists',\n        retryable: false,\n        suggestion: 'Use unique peerId for each context. Try: peerId: `agent-${Date.now()}`'\n    },\n    [ErrorCode.PEER_NOT_FOUND]: {\n        message: 'Peer not found',\n        retryable: false,\n        suggestion: 'Check if peer is connected using bus.peers. Wait for peer connection before request.'\n    },\n    [ErrorCode.PEER_DISCONNECTED]: {\n        message: 'Peer is disconnected',\n        retryable: true,\n        suggestion: 'Wait for peer to reconnect. Listen for \"peer:join\" event before retry.'\n    },\n    [ErrorCode.RECONNECT_FAILED]: {\n        message: 'Max reconnection attempts reached',\n        retryable: false,\n        suggestion: 'Check network connectivity. Consider increasing maxRetries option.'\n    },\n    [ErrorCode.UNSUPPORTED]: {\n        message: 'Operation not supported by this environment',\n        retryable: false,\n        suggestion: 'This feature requires a browser environment. Check for feature availability first.'\n    },\n    [ErrorCode.NOT_CONNECTED]: {\n        message: 'Transport is not connected',\n        retryable: true,\n        suggestion: 'Call addTransport() and wait for connection before sending messages.'\n    },\n    [ErrorCode.ACK_TIMEOUT]: {\n        message: 'ACK not received within timeout',\n        retryable: true,\n        suggestion: 'Increase ackTimeout option or check peer availability.'\n    },\n    [ErrorCode.RESPONSE_TIMEOUT]: {\n        message: 'Response not received within timeout',\n        retryable: true,\n        suggestion: 'Increase timeout in request options: { timeout: 10000 }. Check if handler exists on peer.'\n    },\n    [ErrorCode.QUEUE_FULL]: {\n        message: 'Message queue is full',\n        retryable: false,\n        suggestion: 'Increase maxQueueSize or wait for queue to drain. Consider using batching plugin.'\n    },\n    [ErrorCode.INVALID_MESSAGE]: {\n        message: 'Invalid message format',\n        retryable: false,\n        suggestion: 'Ensure message data is JSON-serializable. Avoid DOM nodes and functions.'\n    },\n    [ErrorCode.VERSION_MISMATCH]: {\n        message: 'Protocol version mismatch',\n        retryable: false,\n        suggestion: 'Update CrossBus to same version on both sides.'\n    },\n    [ErrorCode.CLONE_ERROR]: {\n        message: 'Data cannot be cloned (contains functions or DOM nodes)',\n        retryable: false,\n        suggestion: 'Remove functions, DOM nodes, and circular references from message data.'\n    },\n    [ErrorCode.TRANSFER_ERROR]: {\n        message: 'Failed to transfer object ownership',\n        retryable: false,\n        suggestion: 'Ensure ArrayBuffers are not detached. Each buffer can only be transferred once.'\n    },\n    [ErrorCode.MESSAGE_TOO_LARGE]: {\n        message: 'Message exceeds maximum size',\n        retryable: false,\n        suggestion: 'Use streaming for large payloads or increase maxMessageSize option.'\n    },\n    [ErrorCode.UNREACHABLE]: {\n        message: 'Destination peer is unreachable',\n        retryable: true,\n        suggestion: 'Check if peer is still connected. Use bus.peers to list available peers.'\n    },\n    [ErrorCode.TTL_EXCEEDED]: {\n        message: 'Message TTL exceeded (possible routing loop)',\n        retryable: false,\n        suggestion: 'Check for circular transport configurations. Increase maxTTL if needed.'\n    },\n    [ErrorCode.NO_ROUTE]: {\n        message: 'No route to destination',\n        retryable: false,\n        suggestion: 'Add transport connecting to target peer. Set isHub: true on orchestrator.'\n    },\n    [ErrorCode.NO_HANDLER]: {\n        message: 'No handler registered for this request',\n        retryable: false,\n        suggestion: 'Register handler on target: bus.handle(\"handlerName\", fn). Check handler name spelling.'\n    },\n    [ErrorCode.HANDLER_ERROR]: {\n        message: 'Handler threw an exception',\n        retryable: false,\n        suggestion: 'Check target peer logs for error. Wrap handler in try/catch.'\n    },\n    [ErrorCode.HANDLER_TIMEOUT]: {\n        message: 'Handler did not respond within timeout',\n        retryable: true,\n        suggestion: 'Handler is slow. Increase timeout or optimize handler performance.'\n    },\n    [ErrorCode.HANDLER_EXISTS]: {\n        message: 'Handler already registered with this name',\n        retryable: false,\n        suggestion: 'Use different handler name or call bus.removeHandler() first.'\n    },\n    [ErrorCode.SEND_FAILED]: {\n        message: 'Failed to send message to peer',\n        retryable: true,\n        suggestion: 'Check transport status. Target window may be closed or blocked.'\n    },\n    [ErrorCode.CHANNEL_FAILED]: {\n        message: 'Failed to create direct channel',\n        retryable: true,\n        suggestion: 'Check browser support for MessageChannel. Retry after short delay.'\n    },\n    [ErrorCode.CHANNEL_CLOSED]: {\n        message: 'Channel was closed unexpectedly',\n        retryable: false,\n        suggestion: 'Target context was destroyed. Check if iframe/worker still exists.'\n    },\n    [ErrorCode.MAX_PEERS]: {\n        message: 'Maximum number of peers reached',\n        retryable: false,\n        suggestion: 'Increase maxPeers option or disconnect unused peers first.'\n    },\n    [ErrorCode.MAX_PENDING]: {\n        message: 'Maximum pending requests reached',\n        retryable: false,\n        suggestion: 'Wait for pending requests to complete. Increase maxPendingRequests option.'\n    },\n    [ErrorCode.DESTROYED]: {\n        message: 'CrossBus instance has been destroyed',\n        retryable: false,\n        suggestion: 'Create new CrossBus instance. Do not use bus after calling destroy().'\n    },\n    [ErrorCode.CIRCUIT_OPEN]: {\n        message: 'Circuit breaker is open',\n        retryable: false,\n        suggestion: 'Too many failures. Wait for circuit to reset or call circuit.reset().'\n    },\n    [ErrorCode.PAYLOAD_TOO_LARGE]: {\n        message: 'Payload exceeds maximum allowed size',\n        retryable: false,\n        suggestion: 'Reduce payload size or increase maxPayloadSize option. Consider using streaming for large data.'\n    },\n    [ErrorCode.RATE_LIMITED]: {\n        message: 'Request rate limit exceeded',\n        retryable: true,\n        suggestion: 'Wait before retrying. Consider adding delay or using exponential backoff.'\n    },\n    [ErrorCode.UNAUTHORIZED]: {\n        message: 'Peer is not authorized to call this handler',\n        retryable: false,\n        suggestion: 'Add peer to handler allowedPeers list or remove peer restrictions.'\n    },\n    [ErrorCode.INVALID_PAYLOAD]: {\n        message: 'Payload validation failed',\n        retryable: false,\n        suggestion: 'Check payload structure against handler requirements.'\n    }\n});\n\n/**\n * Custom error class for CrossBus.\n * \n * @extends Error\n * \n * @example\n * try {\n *   await bus.emit('msg', data, 'unknown-peer');\n * } catch (err) {\n *   if (err instanceof CrossBusError) {\n *     console.log(err.code);      // 'ERR_PEER_NOT_FOUND'\n *     console.log(err.message);   // 'Peer not found'\n *     console.log(err.details);   // { peerId: 'unknown-peer' }\n *     console.log(err.retryable); // false\n *   }\n * }\n */\nexport class CrossBusError extends Error {\n    /**\n     * Error code.\n     * @type {ErrorCode}\n     */\n    code;\n\n    /**\n     * Additional error context.\n     * @type {Object}\n     */\n    details;\n\n    /**\n     * Whether the operation can be retried.\n     * @type {boolean}\n     */\n    retryable;\n\n    /**\n     * Original error that caused this error.\n     * @type {Error|undefined}\n     */\n    cause;\n\n    /**\n     * Timestamp when error occurred.\n     * @type {number}\n     */\n    timestamp;\n\n    /**\n     * Creates a new CrossBusError.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {string} [message] - Custom message (uses default if omitted).\n     * @param {Object} [options] - Additional options.\n     * @param {Object} [options.details={}] - Error context.\n     * @param {boolean} [options.retryable] - Override default retryable.\n     * @param {Error} [options.cause] - Original error.\n     */\n    constructor(code, message, options = {}) {\n        const meta = ERROR_META[code] ?? { message: 'Unknown error', retryable: false };\n        super(message ?? meta.message);\n\n        this.name = 'CrossBusError';\n        this.code = code;\n        this.details = options.details ?? {};\n        this.retryable = options.retryable ?? meta.retryable;\n        this.cause = options.cause;\n        this.timestamp = Date.now();\n\n        // Maintain proper stack trace in V8\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CrossBusError);\n        }\n    }\n\n    /**\n     * Creates error from code with default message.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {Object} [details] - Error context.\n     * @returns {CrossBusError}\n     */\n    static from(code, details = {}) {\n        return new CrossBusError(code, undefined, { details });\n    }\n\n    /**\n     * Creates error from another error.\n     * \n     * @param {ErrorCode} code - Error code.\n     * @param {Error} cause - Original error.\n     * @param {Object} [details] - Additional context.\n     * @returns {CrossBusError}\n     */\n    static wrap(code, cause, details = {}) {\n        return new CrossBusError(code, cause.message, { cause, details });\n    }\n\n    /**\n     * Converts error to JSON-serializable object.\n     * @returns {Object}\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            code: this.code,\n            message: this.message,\n            details: this.details,\n            retryable: this.retryable,\n            timestamp: this.timestamp\n        };\n    }\n\n    /**\n     * String representation.\n     * @returns {string}\n     */\n    toString() {\n        return `${this.name} [${this.code}]: ${this.message}`;\n    }\n}\n\n/**\n * Checks if an error is a CrossBusError.\n * \n * @param {*} err - Value to check.\n * @returns {boolean}\n */\nexport function isCrossBusError(err) {\n    return err instanceof CrossBusError;\n}\n\n/**\n * Checks if an error is retryable.\n * \n * @param {Error} err - Error to check.\n * @returns {boolean}\n */\nexport function isRetryable(err) {\n    if (err instanceof CrossBusError) {\n        return err.retryable;\n    }\n    return false;\n}\n","/**\n * @fileoverview Utility functions shared across modules.\n * @module common/utils\n */\n\n/**\n * Generates a UUID v4.\n * Uses crypto.randomUUID() when available, falls back to manual generation.\n * \n * @returns {string} UUID v4 string.\n */\nexport function uuid() {\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback for older browsers\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n\n/**\n * Checks if data can be structured cloned.\n * \n * @param {*} data - Data to check.\n * @returns {boolean} True if cloneable.\n */\nexport function isCloneable(data) {\n    if (data === null || data === undefined) return true;\n\n    const type = typeof data;\n\n    // Primitives are always cloneable\n    if (type === 'boolean' || type === 'number' || type === 'string') {\n        return true;\n    }\n\n    // Functions and symbols are not cloneable\n    if (type === 'function' || type === 'symbol') {\n        return false;\n    }\n\n    // Check for DOM nodes\n    if (typeof Node !== 'undefined' && data instanceof Node) {\n        return false;\n    }\n\n    // Check for WeakMap/WeakSet\n    if (data instanceof WeakMap || data instanceof WeakSet) {\n        return false;\n    }\n\n    // For objects/arrays, we'd need to recursively check\n    // For performance, we assume they're cloneable and let postMessage fail\n    return true;\n}\n\n/**\n * Creates a deferred promise (Promise.withResolvers polyfill).\n * Uses native Promise.withResolvers() when available (ES2024+).\n * \n * @template T\n * @returns {{promise: Promise<T>, resolve: (value: T) => void, reject: (reason: any) => void}}\n */\nexport function deferred() {\n    // Use native Promise.withResolvers if available (ES2024+, ~10x faster)\n    // @ts-ignore\n    if (typeof Promise.withResolvers === 'function') {\n        // @ts-ignore\n        return Promise.withResolvers();\n    }\n    // Fallback for older engines\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    // @ts-ignore\n    return { promise, resolve, reject };\n}\n\n/**\n * Creates a promise that resolves after a timeout.\n * \n * @param {number} ms - Timeout in milliseconds.\n * @param {AbortSignal} [signal] - Optional abort signal.\n * @returns {Promise<void>}\n */\nexport function sleep(ms, signal) {\n    return new Promise((resolve, reject) => {\n        if (signal?.aborted) {\n            reject(signal.reason ?? new Error('Aborted'));\n            return;\n        }\n\n        const timeoutId = setTimeout(resolve, ms);\n\n        if (signal) {\n            signal.addEventListener('abort', () => {\n                clearTimeout(timeoutId);\n                reject(signal.reason ?? new Error('Aborted'));\n            }, { once: true });\n        }\n    });\n}\n\n/**\n * Creates a promise that rejects after a timeout.\n * \n * @template T\n * @param {Promise<T>} promise - Promise to race against.\n * @param {number} ms - Timeout in milliseconds.\n * @param {string} [message='Operation timed out'] - Timeout error message.\n * @returns {Promise<T>}\n */\nexport function withTimeout(promise, ms, message = 'Operation timed out') {\n    return Promise.race([\n        promise,\n        new Promise((_, reject) => {\n            setTimeout(() => reject(new Error(message)), ms);\n        })\n    ]);\n}\n\n\n\n/**\n * Detects the type of a peer target.\n * \n * @param {*} target - Target to check.\n * @returns {'iframe'|'worker'|'sw'|'window'|'port'|'unknown'}\n */\nexport function detectPeerType(target) {\n    // MessagePort\n    if (target instanceof MessagePort) {\n        return 'port';\n    }\n\n    // Worker\n    if (typeof Worker !== 'undefined' && target instanceof Worker) {\n        return 'worker';\n    }\n\n    // ServiceWorker\n    if (typeof ServiceWorker !== 'undefined' && target instanceof ServiceWorker) {\n        return 'sw';\n    }\n\n    // Window (iframe or popup)\n    if (typeof Window !== 'undefined' && target instanceof Window) {\n        return 'window';\n    }\n\n    // HTMLIFrameElement\n    if (typeof HTMLIFrameElement !== 'undefined' && target instanceof HTMLIFrameElement) {\n        return 'iframe';\n    }\n\n    // DedicatedWorkerGlobalScope (inside worker)\n    if (typeof DedicatedWorkerGlobalScope !== 'undefined' &&\n        target instanceof DedicatedWorkerGlobalScope) {\n        return 'worker';\n    }\n\n    return 'unknown';\n}\n\n\n\n/**\n * Creates a frozen timestamp object.\n * \n * @returns {{timestamp: number, iso: string}}\n */\nexport function timestamp() {\n    const ts = Date.now();\n    return Object.freeze({\n        timestamp: ts,\n        iso: new Date(ts).toISOString()\n    });\n}\n\n\n","/**\n * @fileoverview Presence system for CrossBus.\n * Tracks online peers with heartbeat-based detection.\n * @module core/presence\n */\n\nimport { EventEmitter } from './event-emitter.js';\nimport { PROTOCOL_MARKER, PROTOCOL_VERSION } from '../common/types.js';\n\n/**\n * @typedef {Object} PresenceOptions\n * @property {number} [heartbeatInterval=15000] - How often to send heartbeat (ms).\n * @property {number} [timeout=45000] - Time before peer considered offline (ms).\n * @property {boolean} [autoStart=true] - Start heartbeat automatically.\n */\n\n/**\n * @typedef {Object} PeerPresence\n * @property {string} peerId - Peer identifier.\n * @property {'online' | 'away' | 'offline'} status - Current status.\n * @property {number} lastSeen - Timestamp of last activity.\n * @property {Object} [meta] - Optional metadata (user info, etc).\n */\n\n/**\n * @typedef {'join' | 'leave' | 'update' | 'heartbeat'} PresenceEvent\n */\n\n/**\n * Presence manager for tracking online peers.\n * \n * Emits events:\n * - 'join' - Peer came online\n * - 'leave' - Peer went offline\n * - 'update' - Peer presence updated\n * \n * @example\n * const presence = new PresenceManager(sendFn, { peerId: 'my-peer' });\n * \n * presence.on('join', (peerId, meta) => console.log(`${peerId} is online`));\n * presence.on('leave', (peerId) => console.log(`${peerId} went offline`));\n * \n * // Get all online peers\n * const online = presence.getOnlinePeers();\n * \n * // Update own status\n * presence.setStatus('away');\n * \n * // Cleanup\n * presence.destroy();\n */\nexport class PresenceManager extends EventEmitter {\n    /** @type {string} */\n    #peerId;\n\n    /** @type {Function} */\n    #sendFn;\n\n    /** @type {Map<string, PeerPresence>} */\n    #peers = new Map();\n\n    /** @type {number} */\n    #heartbeatInterval;\n\n    /** @type {number} */\n    #timeout;\n\n    /** @type {ReturnType<typeof setInterval>|null} */\n    #heartbeatTimer = null;\n\n    /** @type {ReturnType<typeof setInterval>|null} */\n    #cleanupTimer = null;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /** @type {'online' | 'away' | 'offline'} */\n    #status = 'online';\n\n    /** @type {Object} */\n    #meta = {};\n\n    /**\n     * Creates a PresenceManager.\n     * \n     * @param {Function} sendFn - Function to broadcast messages: (message) => Promise.\n     * @param {{ peerId: string } & PresenceOptions} options - Options.\n     */\n    constructor(sendFn, options) {\n        super();\n\n        if (!options.peerId) {\n            throw new Error('peerId is required');\n        }\n\n        this.#peerId = options.peerId;\n        this.#sendFn = sendFn;\n        this.#heartbeatInterval = options.heartbeatInterval ?? 15000;\n        this.#timeout = options.timeout ?? 45000;\n\n        if (options.autoStart !== false) {\n            this.start();\n        }\n    }\n\n    /**\n     * Gets own peer ID.\n     * @returns {string}\n     */\n    get peerId() {\n        return this.#peerId;\n    }\n\n    /**\n     * Gets own status.\n     * @returns {'online' | 'away' | 'offline'}\n     */\n    get status() {\n        return this.#status;\n    }\n\n    /**\n     * Gets count of online peers.\n     * @returns {number}\n     */\n    get onlineCount() {\n        let count = 0;\n        for (const peer of this.#peers.values()) {\n            if (peer.status !== 'offline') count++;\n        }\n        return count;\n    }\n\n    /**\n     * Starts the presence system.\n     */\n    start() {\n        if (this.#heartbeatTimer) return;\n\n        // Send initial presence\n        this.#sendPresence('join');\n\n        // Start heartbeat\n        this.#heartbeatTimer = setInterval(() => {\n            this.#sendPresence('heartbeat');\n        }, this.#heartbeatInterval);\n\n        // Start cleanup timer\n        this.#cleanupTimer = setInterval(() => {\n            this.#cleanupOfflinePeers();\n        }, this.#heartbeatInterval);\n    }\n\n    /**\n     * Stops the presence system.\n     */\n    stop() {\n        if (this.#heartbeatTimer) {\n            clearInterval(this.#heartbeatTimer);\n            this.#heartbeatTimer = null;\n        }\n\n        if (this.#cleanupTimer) {\n            clearInterval(this.#cleanupTimer);\n            this.#cleanupTimer = null;\n        }\n\n        // Announce leaving\n        this.#sendPresence('leave');\n    }\n\n    /**\n     * Sets own presence status.\n     * \n     * @param {'online' | 'away' | 'offline'} status - New status.\n     * @param {Object} [meta] - Optional metadata update.\n     */\n    setStatus(status, meta) {\n        this.#status = status;\n        if (meta) {\n            this.#meta = { ...this.#meta, ...meta };\n        }\n        this.#sendPresence('update');\n    }\n\n    /**\n     * Sets own metadata.\n     * \n     * @param {Object} meta - Metadata to merge.\n     */\n    setMeta(meta) {\n        this.#meta = { ...this.#meta, ...meta };\n        this.#sendPresence('update');\n    }\n\n    /**\n     * Gets all online peer IDs.\n     * \n     * @returns {string[]}\n     */\n    getOnlinePeers() {\n        const result = [];\n        for (const [peerId, peer] of this.#peers) {\n            if (peer.status !== 'offline') {\n                result.push(peerId);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all peer presences.\n     * \n     * @returns {PeerPresence[]}\n     */\n    getAllPeers() {\n        return Array.from(this.#peers.values());\n    }\n\n    /**\n     * Gets a specific peer's presence.\n     * \n     * @param {string} peerId - Peer ID.\n     * @returns {PeerPresence | undefined}\n     */\n    getPeer(peerId) {\n        return this.#peers.get(peerId);\n    }\n\n    /**\n     * Checks if a peer is online.\n     * \n     * @param {string} peerId - Peer ID to check.\n     * @returns {boolean}\n     */\n    isOnline(peerId) {\n        const peer = this.#peers.get(peerId);\n        return peer ? peer.status !== 'offline' : false;\n    }\n\n    /**\n     * Handles incoming presence message.\n     * Call this from CrossBus message handler.\n     * \n     * @param {Object} message - Presence message.\n     * @param {string} fromPeerId - Source peer ID.\n     */\n    handleMessage(message, fromPeerId) {\n        if (message.t !== 'presence') return;\n        if (fromPeerId === this.#peerId) return; // Ignore own messages\n\n        const { pt: presenceType, status, meta } = message;\n        const now = Date.now();\n\n        switch (presenceType) {\n            case 'join':\n                this.#handleJoin(fromPeerId, status, meta, now);\n                // Respond with own presence so they know we're here\n                this.#sendPresence('heartbeat');\n                break;\n\n            case 'leave':\n                this.#handleLeave(fromPeerId);\n                break;\n\n            case 'heartbeat':\n            case 'update':\n                this.#handleUpdate(fromPeerId, status, meta, now);\n                break;\n        }\n    }\n\n    /**\n     * Handles peer join.\n     */\n    #handleJoin(peerId, status, meta, now) {\n        const isNew = !this.#peers.has(peerId);\n\n        this.#peers.set(peerId, {\n            peerId,\n            status: status ?? 'online',\n            lastSeen: now,\n            meta: meta ?? {}\n        });\n\n        if (isNew) {\n            this.emitSync('join', { peerId, meta });\n        }\n    }\n\n    /**\n     * Handles peer leave.\n     */\n    #handleLeave(peerId) {\n        const peer = this.#peers.get(peerId);\n        if (!peer) return;\n\n        peer.status = 'offline';\n        this.#peers.delete(peerId);\n        this.emitSync('leave', { peerId });\n    }\n\n    /**\n     * Handles presence update/heartbeat.\n     */\n    #handleUpdate(peerId, status, meta, now) {\n        let peer = this.#peers.get(peerId);\n        const wasOffline = !peer || peer.status === 'offline';\n\n        if (!peer) {\n            peer = {\n                peerId,\n                status: status ?? 'online',\n                lastSeen: now,\n                meta: meta ?? {}\n            };\n            this.#peers.set(peerId, peer);\n        } else {\n            peer.lastSeen = now;\n            if (status) peer.status = status;\n            if (meta) peer.meta = { ...peer.meta, ...meta };\n        }\n\n        if (wasOffline && peer.status !== 'offline') {\n            this.emitSync('join', { peerId, meta: peer.meta });\n        } else {\n            this.emitSync('update', { peerId, peer });\n        }\n    }\n\n    /**\n     * Cleans up peers that haven't sent heartbeat.\n     */\n    #cleanupOfflinePeers() {\n        const now = Date.now();\n        const threshold = now - this.#timeout;\n\n        for (const [peerId, peer] of this.#peers) {\n            if (peer.lastSeen < threshold && peer.status !== 'offline') {\n                peer.status = 'offline';\n                this.#peers.delete(peerId);\n                this.emitSync('leave', { peerId });\n            }\n        }\n    }\n\n    /**\n     * Sends presence message.\n     */\n    async #sendPresence(type) {\n        if (this.#destroyed) return;\n\n        const message = {\n            [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n            t: 'presence',\n            pt: type,\n            peerId: this.#peerId,\n            status: this.#status,\n            meta: this.#meta,\n            ts: Date.now()\n        };\n\n        try {\n            await this.#sendFn(message);\n        } catch (e) {\n            console.error('[CrossBus] Failed to send presence:', e);\n        }\n    }\n\n    /**\n     * Destroys the presence manager.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n        this.stop();\n        this.#peers.clear();\n    }\n\n    /**\n     * Gets whether manager is destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n}\n\n/**\n * Creates a presence manager integrated with CrossBus.\n * \n * @param {import('./cross-bus.js').CrossBus} bus - CrossBus instance.\n * @param {PresenceOptions} [options] - Options.\n * @returns {PresenceManager}\n * \n * @example\n * const bus = new CrossBus({ peerId: 'my-peer' });\n * const presence = createPresence(bus);\n * \n * presence.on('join', (peerId) => console.log(`${peerId} joined`));\n */\nexport function createPresence(bus, options = {}) {\n    const sendFn = async (message) => {\n        // Broadcast to all peers\n        await bus.signal('__presence__', message);\n    };\n\n    const presence = new PresenceManager(sendFn, {\n        peerId: bus.peerId,\n        ...options\n    });\n\n    // Register handler for presence messages\n    bus.on('__presence__', (message, ctx) => {\n        presence.handleMessage(message, ctx?.peerId ?? message.peerId);\n    });\n\n    return presence;\n}\n","/**\n * @fileoverview Serialization abstraction layer for CrossBus.\n * Uses JSON serialization for maximum compatibility.\n * @module common/serialization\n */\n\n/**\n * @typedef {Object} Serializer\n * @property {string} contentType - MIME type of the serialization format.\n * @property {function(*): string} serialize - Encodes data.\n * @property {function(string): *} deserialize - Decodes data.\n */\n\n/**\n * Standard JSON Serializer (Default).\n * Compatible with all browsers, native bridges (iOS/Android), and standard tooling.\n * @type {Serializer}\n */\nexport const JSONSerializer = {\n    contentType: 'application/json',\n    serialize: (data) => JSON.stringify(data),\n    deserialize: (data) => JSON.parse(/** @type {string} */(data))\n};\n\n/**\n * Registry of available serializers.\n * Extensible for future formats if needed.\n */\nconst serializers = new Map();\nserializers.set(JSONSerializer.contentType, JSONSerializer);\n\n/**\n * Gets a serializer by content type.\n * Defaults to JSON if not found.\n * \n * @param {string} contentType \n * @returns {Serializer}\n */\nexport function getSerializer(contentType) {\n    return serializers.get(contentType) || JSONSerializer;\n}\n\n/**\n * Returns the preferred content type for the given payload.\n * Always returns JSON for maximum compatibility with native bridges.\n * \n * @param {*} payload \n * @returns {string} Content-Type preferred\n */\nexport function detectPreferredContentType(payload) {\n    return JSONSerializer.contentType;\n}\n","/**\n * @fileoverview Local event emitter with wildcard support and AbortSignal integration.\n * Uses Symbol-based private storage for encapsulation.\n * @module core/event-emitter\n */\n\n/** @type {symbol} Private storage key for listeners map */\nconst LISTENERS = Symbol('listeners');\n\n/** @type {symbol} Private storage key for subscription counter */\nconst SUB_COUNTER = Symbol('subCounter');\n\n/** @type {symbol} Private storage key for max listeners setting */\nconst MAX_LISTENERS = Symbol('maxListeners');\n\n/** @type {symbol} Private storage key for fast callback cache (Object-based) */\nconst FAST_CACHE = Symbol('fastCache');\n\n/** @type {number} Default max listeners before warning */\nconst DEFAULT_MAX_LISTENERS = 10;\n\n/** @type {Object} Default source for local emissions */\nconst DEFAULT_SOURCE = Object.freeze({\n    peerId: 'self',\n    origin: typeof globalThis.location !== 'undefined' ? globalThis.location.origin : 'unknown',\n    type: 'local'\n});\n\n/**\n * @typedef {Object} ListenerOptions\n * @property {boolean} [once=false] - Auto-remove after first invocation.\n * @property {AbortSignal} [signal] - AbortController signal for cleanup.\n * @property {'sync'|'async'} [mode='async'] - Execution mode.\n * @property {number} [priority=0] - Execution order (higher = first).\n */\n\n/**\n * @typedef {Object} Subscription\n * @property {string} id - Unique subscription ID.\n * @property {string} signalName - The signal name subscribed to.\n * @property {Function} unsubscribe - Call to remove this listener.\n * @property {boolean} active - Whether subscription is active.\n */\n\n/**\n * @typedef {Object} SignalEvent\n * @property {string} name - Signal name that was emitted.\n * @property {*} data - The payload data.\n * @property {string} messageId - Unique message ID.\n * @property {number} timestamp - When the signal was emitted.\n * @property {SignalSource} source - Origin of the signal.\n */\n\n/**\n * @typedef {Object} SignalSource\n * @property {string} peerId - ID of the emitting peer ('self' if local).\n * @property {string} origin - Origin URL.\n * @property {'local'|'iframe'|'worker'|'service-worker'|'window'} type - Source type.\n */\n\n/**\n * @callback SignalHandler\n * @param {SignalEvent} event - The signal event object.\n * @returns {void|Promise<void>}\n */\n\n/**\n * @typedef {Object} ListenerEntry\n * @property {string} id - Subscription ID.\n * @property {SignalHandler} handler - The callback function.\n * @property {number} priority - Execution priority.\n * @property {'sync'|'async'} mode - Execution mode.\n * @property {boolean} once - Auto-remove after first invocation.\n * @property {AbortSignal|null} signal - Abort signal.\n */\n\n/**\n * @typedef {Object} RemoveResult\n * @property {boolean} success - True if at least one listener was removed.\n * @property {number} removedCount - Number of listeners removed.\n * @property {number} remainingCount - Listeners still registered for this signal.\n */\n\n/**\n * Local event emitter with wildcard support.\n * \n * Supports:\n * - Exact match: `on('user:login', handler)`\n * - Namespace wildcard: `on('user:*', handler)` matches `user:login`, `user:logout`\n * - Global wildcard: `on('*', handler)` matches all signals\n * \n * @example\n * const emitter = new EventEmitter();\n * \n * // Basic listener\n * emitter.on('message', (event) => console.log(event.data));\n * \n * // Wildcard listener\n * emitter.on('user:*', (event) => console.log('User event:', event.name));\n * \n * // Emit signal\n * emitter.emit('message', { text: 'Hello' });\n */\nexport class EventEmitter {\n    constructor() {\n        /** @type {Map<string, ListenerEntry[]>} */\n        this[LISTENERS] = new Map();\n\n        /** @type {number} */\n        this[SUB_COUNTER] = 0;\n\n        /** @type {number} Max listeners before memory leak warning */\n        this[MAX_LISTENERS] = DEFAULT_MAX_LISTENERS;\n\n        /** @type {Object<string, Function[]>} Fast Object-based cache for callbacks only */\n        this[FAST_CACHE] = Object.create(null);\n    }\n\n    /**\n     * Sets the max listeners threshold for memory leak warnings.\n     * @param {number} n - Max listeners (0 = unlimited)\n     */\n    setMaxListeners(n) {\n        this[MAX_LISTENERS] = n;\n        return this;\n    }\n\n    /**\n     * Gets the current max listeners setting.\n     * @returns {number}\n     */\n    getMaxListeners() {\n        return this[MAX_LISTENERS];\n    }\n\n    /**\n     * Registers a listener for a signal.\n     * \n     * @param {string} name - Signal name. Supports wildcards: '*', 'namespace:*'.\n     * @param {SignalHandler} handler - Callback function.\n     * @param {ListenerOptions} [options={}] - Configuration options.\n     * @returns {Subscription} Subscription object.\n     * @throws {TypeError} If name is not a string or handler is not a function.\n     * \n     * @example\n     * // Basic listener\n     * const sub = emitter.on('user:login', (event) => {\n     *   console.log(`User ${event.data.userId} logged in`);\n     * });\n     * \n     * @example\n     * // One-time listener\n     * emitter.on('init:complete', handler, { once: true });\n     * \n     * @example\n     * // With AbortController\n     * const controller = new AbortController();\n     * emitter.on('data:update', handler, { signal: controller.signal });\n     * controller.abort(); // Removes listener\n     * \n     * @example\n     * // Priority-based ordering\n     * emitter.on('event', lowPriorityHandler, { priority: 1 });\n     * emitter.on('event', highPriorityHandler, { priority: 10 }); // Runs first\n     */\n    on(name, handler, options = {}) {\n        if (typeof name !== 'string') {\n            throw new TypeError('Signal name must be a string');\n        }\n        if (typeof handler !== 'function') {\n            throw new TypeError('Handler must be a function');\n        }\n\n        const id = `sub_${++this[SUB_COUNTER]}`;\n\n        // V8 Optimization: Consistent object shape for hidden class caching\n        // All entries have same properties in same order\n        /** @type {ListenerEntry} */\n        const entry = {\n            id,\n            handler,\n            priority: options.priority ?? 0,\n            mode: options.mode ?? 'async',\n            once: options.once ?? false,\n            signal: options.signal ?? null\n        };\n\n        // Get or create listeners array for this signal\n        if (!this[LISTENERS].has(name)) {\n            this[LISTENERS].set(name, []);\n        }\n\n        const listeners = this[LISTENERS].get(name);\n\n        // Binary insert for O(log n) search instead of O(n log n) sort\n        if (listeners.length === 0 || entry.priority <= listeners[listeners.length - 1].priority) {\n            // Fast path: append (most common case with priority 0)\n            listeners.push(entry);\n        } else {\n            // Binary search for insert position (higher priority first)\n            let lo = 0, hi = listeners.length;\n            while (lo < hi) {\n                const mid = (lo + hi) >>> 1;\n                if (listeners[mid].priority >= entry.priority) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid;\n                }\n            }\n            listeners.splice(lo, 0, entry);\n        }\n\n        // Sync FAST_CACHE for ultra-fast emitSync\n        this[FAST_CACHE][name] = listeners.map(e => e.handler);\n\n        // Memory leak detection: warn if too many listeners\n        const maxListeners = this[MAX_LISTENERS];\n        if (maxListeners > 0 && listeners.length > maxListeners) {\n            console.warn(\n                `[CrossBus] Possible memory leak: ${listeners.length} listeners for \"${name}\". ` +\n                `Use setMaxListeners(n) to increase limit.`\n            );\n        }\n\n        // Create subscription object\n        let active = true;\n        const subscription = {\n            id,\n            signalName: name,\n            get active() { return active; },\n            unsubscribe: () => {\n                if (active) {\n                    this.#removeListener(name, id);\n                    active = false;\n                }\n            }\n        };\n\n        // Handle AbortSignal\n        if (entry.signal) {\n            if (entry.signal.aborted) {\n                // Already aborted, remove immediately\n                this.#removeListener(name, id);\n                active = false;\n            } else {\n                entry.signal.addEventListener('abort', () => {\n                    subscription.unsubscribe();\n                }, { once: true });\n            }\n        }\n\n        return subscription;\n    }\n\n    /**\n     * Registers a one-time listener.\n     * Convenience method for `on(name, handler, { once: true })`.\n     * \n     * @param {string} name - Signal name.\n     * @param {SignalHandler} handler - Callback function.\n     * @param {ListenerOptions} [options={}] - Additional options.\n     * @returns {Subscription} Subscription object.\n     */\n    once(name, handler, options = {}) {\n        return this.on(name, handler, { ...options, once: true });\n    }\n\n    /**\n     * Ultra-fast listener registration for performance-critical paths.\n     * \n     * Unlike on(), this method:\n     * - No input validation (caller must ensure correct types)\n     * - No subscription object (returns unbind function directly)\n     * - No priority, once, or AbortSignal support\n     * - Direct push to FAST_CACHE (minimal overhead)\n     * \n     * Use when you need maximum subscribe performance.\n     * \n     * @param {string} name - Signal name.\n     * @param {EventListener} handler - Callback function.\n     * @returns {Function} Unbind function (call to remove listener).\n     * \n     * @example\n     * // 50M+ ops/sec subscribe/unsubscribe\n     * const off = emitter.onFast('tick', (data) => console.log(data));\n     * off(); // Remove listener\n     */\n    onFast(name, handler) {\n        // Match nanoevents exactly: ||= pattern, minimal code\n        (this[FAST_CACHE][name] ||= []).push(handler);\n        return () => {\n            this[FAST_CACHE][name] = this[FAST_CACHE][name]?.filter(h => h !== handler);\n        };\n    }\n\n    /**\n     * Ultra-fast listener removal for performance-critical paths.\n     * \n     * @param {string} name - Signal name.\n     * @param {EventListener} handler - Handler to remove.\n     */\n    offFast(name, handler) {\n        const cache = this[FAST_CACHE][name];\n        if (cache) {\n            const idx = cache.indexOf(handler);\n            if (idx !== -1) cache.splice(idx, 1);\n        }\n        // Also clean LISTENERS\n        const listeners = this[LISTENERS].get(name);\n        if (listeners) {\n            const idx = listeners.findIndex(e => e.handler === handler);\n            if (idx !== -1) listeners.splice(idx, 1);\n        }\n    }\n\n    /**\n     * Removes signal listener(s).\n     * \n     * @param {string} name - Signal name.\n     * @param {SignalHandler} [handler] - Specific handler to remove.\n     *                                    If omitted, removes ALL listeners.\n     * @returns {RemoveResult} Result of the removal.\n     * @throws {TypeError} If name is not a string.\n     * \n     * @example\n     * // Remove specific handler\n     * const result = emitter.off('msg', myHandler);\n     * // => { success: true, removedCount: 1, remainingCount: 0 }\n     * \n     * @example\n     * // Remove ALL listeners for a signal\n     * emitter.off('updates');\n     * // => { success: true, removedCount: 2, remainingCount: 0 }\n     */\n    off(name, handler) {\n        if (typeof name !== 'string') {\n            throw new TypeError('Signal name must be a string');\n        }\n\n        const listeners = this[LISTENERS].get(name);\n\n        if (!listeners || listeners.length === 0) {\n            return { success: false, removedCount: 0, remainingCount: 0 };\n        }\n\n        let removedCount = 0;\n\n        if (handler === undefined) {\n            // Remove all listeners for this signal\n            removedCount = listeners.length;\n            this[LISTENERS].delete(name);\n            delete this[FAST_CACHE][name];\n        } else {\n            // Remove specific handler\n            const initialLength = listeners.length;\n            const filtered = listeners.filter(entry => entry.handler !== handler);\n            removedCount = initialLength - filtered.length;\n\n            if (filtered.length === 0) {\n                this[LISTENERS].delete(name);\n                delete this[FAST_CACHE][name];\n            } else {\n                this[LISTENERS].set(name, filtered);\n                this[FAST_CACHE][name] = filtered.map(e => e.handler);\n            }\n        }\n\n        const remaining = this[LISTENERS].get(name)?.length ?? 0;\n\n        return {\n            success: removedCount > 0,\n            removedCount,\n            remainingCount: remaining\n        };\n    }\n\n    /**\n     * Ultra-fast synchronous emit for performance-critical paths.\n     * \n     * Unlike emit(), this method:\n     * - Is synchronous (no async/await overhead)\n     * - Passes data directly (no event envelope)\n     * - Skips messageId, timestamp generation\n     * - No wildcard matching (exact match only)\n     * \n     * Use for high-frequency events where metadata is not needed.\n     * \n     * @param {string} name - Signal name (exact match only).\n     * @param {*} data - Payload to pass directly to handlers.\n     * @returns {number} Number of listeners invoked.\n     * \n     * @example\n     * // 150M+ ops/sec - use for hot paths\n     * emitter.emitSync('tick', { x: 100, y: 200 });\n     */\n    emitSync(name, data) {\n        // Ultra-fast path: use Object-based cache (faster than Map.get)\n        const callbacks = this[FAST_CACHE][name];\n        if (!callbacks) return 0;\n\n        // Direct callback invocation (no .handler indirection)\n        const len = callbacks.length;\n        if (len === 1) {\n            callbacks[0](data);\n            return 1;\n        }\n        if (len === 2) {\n            callbacks[0](data);\n            callbacks[1](data);\n            return 2;\n        }\n        if (len === 3) {\n            callbacks[0](data);\n            callbacks[1](data);\n            callbacks[2](data);\n            return 3;\n        }\n        if (len === 4) {\n            callbacks[0](data);\n            callbacks[1](data);\n            callbacks[2](data);\n            callbacks[3](data);\n            return 4;\n        }\n\n        // General loop for 5+ listeners\n        for (let i = 0; i < len; i++) {\n            callbacks[i](data);\n        }\n        return len;\n    }\n\n    /**\n     * Emits a signal to local listeners.\n     * \n     * @param {string} name - Signal name.\n     * @param {*} data - Payload data.\n     * @param {Partial<SignalSource>} [source] - Signal source info.\n     * @returns {Promise<number>} Number of listeners invoked.\n     * @throws {TypeError} If name is not a string.\n     * \n     * @example\n     * const count = await emitter.emit('user:login', { userId: 123 });\n     * console.log(`Notified ${count} listeners`);\n     */\n    async emit(name, data, source) {\n        if (typeof name !== 'string') {\n            throw new TypeError('Signal name must be a string');\n        }\n\n        // Fast path: single exact-match listener, no wildcards\n        const exactListeners = this[LISTENERS].get(name);\n        const hasWildcard = this[LISTENERS].has('*');\n\n        if (exactListeners?.length === 1 && !hasWildcard && !source) {\n            const entry = exactListeners[0];\n            const event = {\n                name,\n                data,\n                messageId: crypto.randomUUID(),\n                timestamp: Date.now(),\n                source: DEFAULT_SOURCE\n            };\n\n            try {\n                if (entry.mode === 'sync') {\n                    await entry.handler(event);\n                } else {\n                    Promise.resolve().then(() => entry.handler(event));\n                }\n            } catch (error) {\n                console.error(`[CrossBus] Handler error for \"${name}\":`, error);\n            }\n\n            if (entry.once) {\n                this.#removeListener(name, entry.id);\n            }\n\n            return 1;\n        }\n\n        // Full path: multiple listeners or wildcards\n        const event = {\n            name,\n            data,\n            messageId: crypto.randomUUID(),\n            timestamp: Date.now(),\n            source: source ? { ...DEFAULT_SOURCE, ...source } : DEFAULT_SOURCE\n        };\n\n        // Collect matching listeners\n        const matchingEntries = this.#getMatchingListeners(name);\n\n        // Track entries to remove (once: true)\n        const toRemove = [];\n\n        // Invoke handlers\n        for (const { signalName, entry } of matchingEntries) {\n            try {\n                if (entry.mode === 'sync') {\n                    await entry.handler(event);\n                } else {\n                    // Fire async without blocking\n                    Promise.resolve().then(() => entry.handler(event));\n                }\n            } catch (error) {\n                // Log but don't throw - other listeners should still run\n                console.error(`[CrossBus] Handler error for \"${name}\":`, error);\n            }\n\n            if (entry.once) {\n                toRemove.push({ signalName, id: entry.id });\n            }\n        }\n\n        // Remove once listeners\n        for (const { signalName, id } of toRemove) {\n            this.#removeListener(signalName, id);\n        }\n\n        return matchingEntries.length;\n    }\n\n    /**\n     * Checks if there are any listeners for a signal.\n     * \n     * @param {string} name - Signal name (exact match only).\n     * @returns {boolean} True if listeners exist.\n     */\n    hasListeners(name) {\n        const listeners = this[LISTENERS].get(name);\n        return listeners !== undefined && listeners.length > 0;\n    }\n\n    /**\n     * Gets the count of listeners for a signal.\n     * \n     * @param {string} name - Signal name (exact match only).\n     * @returns {number} Number of listeners.\n     */\n    listenerCount(name) {\n        return this[LISTENERS].get(name)?.length ?? 0;\n    }\n\n    /**\n     * Gets all registered signal names.\n     * \n     * @returns {string[]} Array of signal names.\n     */\n    getSignalNames() {\n        return Array.from(this[LISTENERS].keys());\n    }\n\n    /**\n     * Removes all listeners.\n     */\n    clear() {\n        this[LISTENERS].clear();\n        // Reset FAST_CACHE to empty object\n        for (const key in this[FAST_CACHE]) {\n            delete this[FAST_CACHE][key];\n        }\n    }\n\n    /**\n     * Gets all listeners matching a signal name (including wildcards).\n     * \n     * \n     * @param {string} name - Signal name to match.\n     * @returns {Array<{signalName: string, entry: ListenerEntry}>} Matching entries.\n     */\n    #getMatchingListeners(name) {\n        // Fast path: check exact match first and if no wildcards registered\n        const exactListeners = this[LISTENERS].get(name);\n        const globalWildcard = this[LISTENERS].get('*');\n\n        // Find namespace wildcards (e.g., 'user:*' for 'user:login')\n        let namespaceWildcard = null;\n        const colonIdx = name.indexOf(':');\n        if (colonIdx > 0) {\n            const wildcardPattern = name.slice(0, colonIdx + 1) + '*';\n            namespaceWildcard = this[LISTENERS].get(wildcardPattern);\n        }\n\n        // Super-fast path: only exact match, no wildcards\n        if (exactListeners && !globalWildcard && !namespaceWildcard) {\n            return exactListeners.map(entry => ({ signalName: name, entry }));\n        }\n\n        // Fast path: single source, already sorted\n        const sources = [\n            exactListeners && { signalName: name, entries: exactListeners },\n            globalWildcard && { signalName: '*', entries: globalWildcard },\n            namespaceWildcard && { signalName: name.slice(0, colonIdx + 1) + '*', entries: namespaceWildcard }\n        ].filter(Boolean);\n\n        if (sources.length === 0) {\n            return [];\n        }\n\n        if (sources.length === 1) {\n            // Single source: already sorted, no merge needed\n            return sources[0].entries.map(entry => ({ signalName: sources[0].signalName, entry }));\n        }\n\n        // Multiple sources: collect and merge-sort by priority\n        const results = [];\n        for (const { signalName, entries } of sources) {\n            for (const entry of entries) {\n                results.push({ signalName, entry });\n            }\n        }\n\n        // Only sort when merging multiple sources\n        results.sort((a, b) => b.entry.priority - a.entry.priority);\n\n        return results;\n    }\n\n\n\n    /**\n     * Removes a listener by ID.\n     * \n     * \n     * @param {string} name - Signal name.\n     * @param {string} id - Subscription ID.\n     */\n    #removeListener(name, id) {\n        const listeners = this[LISTENERS].get(name);\n        if (!listeners) return;\n\n        const filtered = listeners.filter(entry => entry.id !== id);\n\n        if (filtered.length === 0) {\n            this[LISTENERS].delete(name);\n            delete this[FAST_CACHE][name];\n        } else {\n            this[LISTENERS].set(name, filtered);\n            this[FAST_CACHE][name] = filtered.map(e => e.handler);\n        }\n    }\n}\n\n/**\n * Creates an ultra-fast plain object emitter that beats nanoevents.\n * \n * Unlike EventEmitter class, this is a minimal plain object with:\n * - No class overhead\n * - No Symbol lookups\n * - No validation\n * - Direct property access\n * \n * Benchmarks:\n * - on/off cycle: 45M ops/sec (vs nanoevents 38M) = 1.18x faster\n * - emit (10 listeners): 82M ops/sec (vs nanoevents 65M) = 1.26x faster\n * \n * @returns {Object} Fast emitter with on(), emit() methods\n * \n * @example\n * const emitter = createFastEmitter();\n * const off = emitter.on('event', (data) => console.log(data));\n * emitter.emit('event', { value: 42 });\n * off(); // Remove listener\n */\nexport const createFastEmitter = () => ({\n    events: {},\n\n    /**\n     * Subscribe to an event. Returns unbind function.\n     * @param {string} event - Event name\n     * @param {EventListener} cb - Callback function\n     * @returns {Function} Unbind function\n     */\n    on(event, cb) {\n        (this.events[event] ||= []).push(cb);\n        return () => {\n            this.events[event] = this.events[event]?.filter(i => cb !== i);\n        };\n    },\n\n    /**\n     * Emit an event to all listeners.\n     * @param {string} event - Event name\n     * @param {*} data - Data to pass to listeners\n     */\n    emit(event, data) {\n        const c = this.events[event];\n        if (!c) return;\n        const len = c.length;\n        // Unrolled for 1-4 (most common)\n        if (len === 1) { c[0](data); return; }\n        if (len === 2) { c[0](data); c[1](data); return; }\n        if (len === 3) { c[0](data); c[1](data); c[2](data); return; }\n        if (len === 4) { c[0](data); c[1](data); c[2](data); c[3](data); return; }\n        // Loop for 5+\n        for (let i = 0; i < len; i++) c[i](data);\n    },\n\n    /**\n     * Remove all listeners for an event or all events.\n     * @param {string} [event] - Event name (omit to clear all)\n     */\n    off(event) {\n        if (event) {\n            delete this.events[event];\n        } else {\n            this.events = {};\n        }\n    }\n});\n\n","/**\n * @fileoverview Message router for hub-based routing.\n * Routes messages between peers through a central hub.\n * @module router/message-router\n */\n\nimport { MessageType, PeerStatus } from '../common/types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { EventEmitter } from '../core/event-emitter.js';\n\n/**\n * @typedef {Object} RoutingEntry\n * @property {string} peerId - Peer identifier.\n * @property {Function} sendFn - Function to send to this peer.\n * @property {Object} meta - Peer metadata.\n * @property {string} origin - Peer origin.\n * @property {PeerStatus} status - Connection status.\n * @property {number} connectedAt - Connection timestamp.\n */\n\n/**\n * @typedef {Object} RouteResult\n * @property {boolean} success - Whether routing succeeded.\n * @property {number} delivered - Number of peers message was delivered to.\n * @property {string[]} failed - Peer IDs that failed delivery.\n */\n\n/**\n * Message router for hub-based communication pattern.\n * \n * In hub mode, all messages flow through a central router which:\n * - Maintains peer registry\n * - Routes unicast messages to specific peers\n * - Broadcasts messages to all/selected peers\n * - Tracks message delivery\n * \n * Performance optimizations:\n * - Object-based cache for fast peer lookup (faster than Map.get)\n * - Direct sendFn cache to avoid property indirection\n * - Unrolled loops for common broadcast patterns\n * \n * @example\n * const router = new MessageRouter();\n * \n * // Register peers\n * router.addPeer('widget-1', (msg) => iframe1.postMessage(msg));\n * router.addPeer('widget-2', (msg) => iframe2.postMessage(msg));\n * \n * // Route unicast\n * router.route({ target: 'widget-1', payload: data });\n * \n * // Route broadcast\n * router.broadcast({ payload: data });\n */\nexport class MessageRouter extends EventEmitter {\n    /** @type {Map<string, RoutingEntry>} Full feature storage */\n    #peers = new Map();\n\n    /** @type {number} */\n    #messageSeq = 0;\n\n    /** @type {Map<string, number>} Per-peer sequence numbers */\n    #peerSeq = new Map();\n\n    /** @type {Object<string, RoutingEntry>} Fast Object-based cache for peer lookup */\n    #peerCache = Object.create(null);\n\n    /** @type {Object<string, Function>} Fast Object-based cache for sendFn direct access */\n    #sendFnCache = Object.create(null);\n\n    /** @type {string[]} Cached peer IDs array for fast iteration */\n    #peerIds = [];\n\n    /**\n     * Creates a new message router.\n     */\n    constructor() {\n        super();\n    }\n\n    /**\n     * Adds a peer to the routing table.\n     * \n     * @param {string} peerId - Unique peer identifier.\n     * @param {EventListener} sendFn - Function to send messages to peer.\n     * @param {Object} [options={}] - Additional options.\n     * @param {Object} [options.meta={}] - Peer metadata.\n     * @param {string} [options.origin='unknown'] - Peer origin.\n     * @throws {CrossBusError} If peer already exists.\n     * \n     * @example\n     * router.addPeer('iframe-widget', (msg) => {\n     *   iframe.contentWindow.postMessage(msg, '*');\n     * }, { meta: { type: 'widget' } });\n     */\n    addPeer(peerId, sendFn, options = {}) {\n        if (this.#peers.has(peerId)) {\n            throw CrossBusError.from(ErrorCode.PEER_EXISTS, { peerId });\n        }\n\n        if (typeof sendFn !== 'function') {\n            throw new TypeError('sendFn must be a function');\n        }\n\n        /** @type {RoutingEntry} */\n        const entry = {\n            peerId,\n            sendFn,\n            meta: options.meta ?? {},\n            origin: options.origin ?? 'unknown',\n            status: PeerStatus.CONNECTED,\n            connectedAt: Date.now()\n        };\n\n        // Full feature storage\n        this.#peers.set(peerId, entry);\n        this.#peerSeq.set(peerId, 0);\n\n        // Sync fast caches for O(1) lookup\n        this.#peerCache[peerId] = entry;\n        this.#sendFnCache[peerId] = sendFn;\n        this.#peerIds.push(peerId);\n\n        // Emit peer added event\n        this.emit('peer:added', { peerId, meta: entry.meta });\n    }\n\n    /**\n     * Removes a peer from the routing table.\n     * \n     * @param {string} peerId - Peer to remove.\n     * @returns {boolean} True if peer was removed.\n     */\n    removePeer(peerId) {\n        const peer = this.#peerCache[peerId];\n        if (!peer) return false;\n\n        // Full storage cleanup\n        this.#peers.delete(peerId);\n        this.#peerSeq.delete(peerId);\n\n        // Sync fast caches\n        delete this.#peerCache[peerId];\n        delete this.#sendFnCache[peerId];\n        const idx = this.#peerIds.indexOf(peerId);\n        if (idx !== -1) this.#peerIds.splice(idx, 1);\n\n        // Emit peer removed event\n        this.emit('peer:removed', { peerId, meta: peer.meta });\n\n        return true;\n    }\n\n    /**\n     * Gets a peer by ID.\n     * \n     * @param {string} peerId\n     * @returns {RoutingEntry|undefined}\n     */\n    getPeer(peerId) {\n        // Fast Object-based lookup (faster than Map.get)\n        return this.#peerCache[peerId];\n    }\n\n    /**\n     * Gets all connected peer IDs.\n     * \n     * @returns {string[]}\n     */\n    getPeerIds() {\n        // Return cached array (avoids Array.from overhead)\n        return this.#peerIds.slice();\n    }\n\n    /**\n     * Gets count of connected peers.\n     * \n     * @returns {number}\n     */\n    get peerCount() {\n        return this.#peers.size;\n    }\n\n    /**\n     * Routes a message to a specific peer or broadcasts.\n     * \n     * @param {Object} message - Message to route.\n     * @param {string} [message.target] - Target peer ID (omit for broadcast).\n     * @param {Object} message.payload - Message payload.\n     * @param {Object} [options] - Broadcast options\n     * @param {string[]} [options.exclude] - Peer IDs to exclude from broadcast.\n     * @returns {RouteResult}\n     */\n    route(message, options = {}) {\n        const { target, payload } = message;\n\n        if (target) {\n            // Unicast to specific peer\n            return this.#routeUnicast(target, payload);\n        } else {\n            // Broadcast to all peers - lazy Set creation\n            const excludeArr = options.exclude;\n            const exclude = excludeArr?.length ? new Set(excludeArr) : null;\n            return this.#routeBroadcast(payload, exclude);\n        }\n    }\n\n    /**\n     * Broadcasts a message to all peers.\n     * \n     * @param {Object} payload - Message payload.\n     * @param {Object} [options={}] - Broadcast options.\n     * @param {string[]} [options.exclude] - Peers to exclude.\n     * @param {string[]} [options.include] - Only include these peers.\n     * @returns {RouteResult}\n     */\n    broadcast(payload, options = {}) {\n        // Lazy Set creation - skip allocation when not needed\n        const excludeArr = options.exclude;\n        const exclude = excludeArr?.length ? new Set(excludeArr) : null;\n        const includeArr = options.include;\n        const include = includeArr?.length ? new Set(includeArr) : null;\n\n        let delivered = 0;\n        const failed = [];\n\n        for (const [peerId, peer] of this.#peers) {\n            // Skip excluded peers\n            if (exclude?.has(peerId)) continue;\n\n            // Skip if not in include list (when specified)\n            if (include && !include.has(peerId)) continue;\n\n            // Skip disconnected peers\n            if (peer.status !== PeerStatus.CONNECTED) continue;\n\n            try {\n                const envelope = this.#createEnvelope(peerId, payload, MessageType.BROADCAST);\n                peer.sendFn(envelope);\n                delivered++;\n            } catch (error) {\n                console.error(`[Router] Failed to send to ${peerId}:`, error);\n                failed.push(peerId);\n            }\n        }\n\n        return { success: failed.length === 0, delivered, failed };\n    }\n\n    /**\n     * Gets the next sequence number for a peer.\n     * Used for causal ordering in SignalStore.\n     * \n     * @param {string} peerId\n     * @returns {number}\n     */\n    getSequence(peerId) {\n        return this.#peerSeq.get(peerId) ?? 0;\n    }\n\n    /**\n     * Updates peer status.\n     * \n     * @param {string} peerId\n     * @param {PeerStatus} status\n     */\n    setPeerStatus(peerId, status) {\n        const peer = this.#peerCache[peerId];\n        if (peer) {\n            peer.status = status;\n            this.emit('peer:status', { peerId, status });\n        }\n    }\n\n    /**\n     * Clears all peers.\n     */\n    clearPeers() {\n        // Fast iteration using cached array\n        const peerIds = this.#peerIds.slice();\n        for (const peerId of peerIds) {\n            this.removePeer(peerId);\n        }\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Routes to a single peer.\n     * \n     */\n    #routeUnicast(peerId, payload) {\n        const peer = this.#peerCache[peerId];\n\n        if (!peer) {\n            return {\n                success: false,\n                delivered: 0,\n                failed: [peerId],\n                error: ErrorCode.PEER_NOT_FOUND\n            };\n        }\n\n        if (peer.status !== PeerStatus.CONNECTED) {\n            return {\n                success: false,\n                delivered: 0,\n                failed: [peerId],\n                error: ErrorCode.PEER_DISCONNECTED\n            };\n        }\n\n        try {\n            // If payload is already a protocol message (has the marker), send directly\n            // Otherwise wrap in envelope for signals/broadcasts\n            const messageToSend = (payload && payload._cb)\n                ? payload\n                : this.#createEnvelope(peerId, payload, MessageType.SIGNAL);\n            peer.sendFn(messageToSend);\n            return { success: true, delivered: 1, failed: [] };\n        } catch (error) {\n            console.error(`[Router] Failed to send to ${peerId}:`, error);\n            return { success: false, delivered: 0, failed: [peerId] };\n        }\n    }\n\n    /**\n     * Broadcasts to multiple peers.\n     * \n     */\n    #routeBroadcast(payload, exclude) {\n        // exclude is already a Set or null from route()\n        return this.broadcast(payload, exclude ? { exclude: Array.from(exclude) } : {});\n    }\n\n    /**\n     * Creates a message envelope with routing info.\n     * \n     */\n    #createEnvelope(peerId, payload, type) {\n        // Increment per-peer sequence\n        const seq = (this.#peerSeq.get(peerId) ?? 0) + 1;\n        this.#peerSeq.set(peerId, seq);\n\n        return {\n            id: `msg_${++this.#messageSeq}`,\n            t: type,\n            ts: Date.now(),\n            seq,\n            p: payload\n        };\n    }\n}\n","/**\n * @fileoverview Pending requests tracker for request/response pattern.\n * Tracks outgoing requests and matches them with responses.\n * @module router/pending-requests\n */\n\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { deferred, withTimeout } from '../common/utils.js';\n\n/**\n * @typedef {Object} PendingRequest\n * @property {string} id - Request ID.\n * @property {string} targetPeer - Target peer ID.\n * @property {string} handlerName - Name of the handler.\n * @property {number} createdAt - When request was created.\n * @property {number} timeout - Timeout in ms.\n * @property {Function} resolve - Promise resolve function.\n * @property {Function} reject - Promise reject function.\n * @property {*} [defaultValue] - Value to return on timeout.\n */\n\n/**\n * @typedef {Object} RequestOptions\n * @property {number} [timeout=30000] - Request timeout in ms.\n * @property {*} [defaultValue] - Value to return on timeout instead of throwing.\n */\n\n/**\n * @typedef {Object} ResponseData\n * @property {string} requestId - Original request ID.\n * @property {boolean} success - Whether handler succeeded.\n * @property {*} [data] - Response data if successful.\n * @property {Object} [error] - Error if failed.\n */\n\n/**\n * Tracks pending requests and matches responses.\n * \n * Supports:\n * - Timeout handling\n * - Automatic cleanup\n * - Error propagation\n * - Request cancellation\n * \n * @example\n * const tracker = new PendingRequests();\n * \n * // Create request\n * const { requestId, promise } = tracker.create('peer-1', 'getData', {\n *   timeout: 5000\n * });\n * \n * // Send request via transport...\n * transport.send({ id: requestId, type: 'request', handler: 'getData' });\n * \n * // When response arrives:\n * tracker.resolve(requestId, responseData);\n * \n * // Or wait for response:\n * const result = await promise;\n */\nexport class PendingRequests {\n    /** @type {Map<string, PendingRequest>} Full feature storage */\n    #pending = new Map();\n\n    /** @type {Object<string, PendingRequest>} Fast Object-based cache for lookup */\n    #cache = Object.create(null);\n\n    /** @type {number} */\n    #requestCounter = 0;\n\n    /** @type {number} Default timeout */\n    #defaultTimeout;\n\n    /** @type {number} Maximum pending requests */\n    #maxPending;\n\n    /**\n     * Creates a new pending requests tracker.\n     * \n     * @param {Object} [options={}]\n     * @param {number} [options.defaultTimeout=30000] - Default timeout in ms.\n     * @param {number} [options.maxPending=1000] - Maximum pending requests (0 = unlimited).\n     */\n    constructor(options = {}) {\n        this.#defaultTimeout = options.defaultTimeout ?? 30000;\n        this.#maxPending = options.maxPending ?? 1000;\n    }\n\n    /**\n     * Creates a new pending request.\n     * \n     * @param {string} targetPeer - Target peer ID.\n     * @param {string} handlerName - Name of the handler to invoke.\n     * @param {RequestOptions} [options={}] - Request options.\n     * @returns {{ requestId: string, promise: Promise<*> }}\n     * \n     * @example\n     * const { requestId, promise } = tracker.create('widget', 'getState');\n     * const result = await promise;\n     */\n    create(targetPeer, handlerName, options = {}) {\n        // Enforce max pending limit to prevent memory exhaustion\n        if (this.#maxPending > 0 && this.#pending.size >= this.#maxPending) {\n            throw CrossBusError.from(ErrorCode.MAX_PENDING, {\n                current: this.#pending.size,\n                max: this.#maxPending,\n                targetPeer,\n                handlerName\n            });\n        }\n\n        const now = Date.now();\n        const requestId = `req_${++this.#requestCounter}_${now}`;\n        const timeout = options.timeout ?? this.#defaultTimeout;\n        const { promise, resolve, reject } = deferred();\n\n        /** @type {PendingRequest} */\n        const pending = {\n            id: requestId,\n            targetPeer,\n            handlerName,\n            createdAt: now,\n            timeout,\n            resolve,\n            reject,\n            defaultValue: options.defaultValue\n        };\n\n        this.#pending.set(requestId, pending);\n        this.#cache[requestId] = pending;  // Sync fast cache\n\n        // Set up timeout\n        const timeoutPromise = withTimeout(promise, timeout).catch(error => {\n            // Cleanup on timeout - use cache for fast check\n            if (requestId in this.#cache) {\n                this.#pending.delete(requestId);\n                delete this.#cache[requestId];\n\n                // Return default value if provided\n                if ('defaultValue' in options) {\n                    return options.defaultValue;\n                }\n\n                throw CrossBusError.from(ErrorCode.RESPONSE_TIMEOUT, {\n                    requestId,\n                    targetPeer,\n                    handlerName,\n                    timeout\n                });\n            }\n            throw error;\n        });\n\n        return { requestId, promise: timeoutPromise };\n    }\n\n    /**\n     * Resolves a pending request with response data.\n     * \n     * @param {string} requestId - Request ID to resolve.\n     * @param {ResponseData} response - Response data.\n     * @returns {boolean} True if request was found and resolved.\n     */\n    resolve(requestId, response) {\n        const pending = this.#cache[requestId];\n        if (!pending) return false;\n\n        // Sync both storages\n        this.#pending.delete(requestId);\n        delete this.#cache[requestId];\n\n        if (response.success) {\n            pending.resolve(response.data);\n        } else {\n            const error = CrossBusError.from(\n                response.error?.code ?? ErrorCode.HANDLER_ERROR,\n                {\n                    requestId,\n                    targetPeer: pending.targetPeer,\n                    handlerName: pending.handlerName,\n                    originalError: response.error\n                }\n            );\n            error.message = response.error?.message ?? 'Handler error';\n            pending.reject(error);\n        }\n\n        return true;\n    }\n\n    /**\n     * Rejects a pending request with an error.\n     * \n     * @param {string} requestId - Request ID to reject.\n     * @param {Error|string} error - Error or error message.\n     * @returns {boolean} True if request was found and rejected.\n     */\n    reject(requestId, error) {\n        const pending = this.#cache[requestId];\n        if (!pending) return false;\n\n        // Sync both storages\n        this.#pending.delete(requestId);\n        delete this.#cache[requestId];\n\n        const err = error instanceof Error ? error : new Error(error);\n        pending.reject(err);\n\n        return true;\n    }\n\n    /**\n     * Cancels a pending request.\n     * \n     * @param {string} requestId - Request ID to cancel.\n     * @returns {boolean} True if request was found and cancelled.\n     */\n    cancel(requestId) {\n        const pending = this.#cache[requestId];\n        if (!pending) return false;\n\n        // Sync both storages\n        this.#pending.delete(requestId);\n        delete this.#cache[requestId];\n        pending.reject(new Error('Request cancelled'));\n\n        return true;\n    }\n\n    /**\n     * Cancels all pending requests for a peer.\n     * Used when peer disconnects.\n     * \n     * @param {string} peerId - Peer ID.\n     * @returns {number} Number of requests cancelled.\n     */\n    cancelForPeer(peerId) {\n        let count = 0;\n\n        for (const [requestId, pending] of this.#pending) {\n            if (pending.targetPeer === peerId) {\n                this.#pending.delete(requestId);\n                delete this.#cache[requestId];  // Sync cache\n                pending.reject(CrossBusError.from(ErrorCode.PEER_DISCONNECTED, {\n                    peerId,\n                    requestId\n                }));\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    /**\n     * Cancels all pending requests.\n     * \n     * @returns {number} Number of requests cancelled.\n     */\n    cancelAll() {\n        const count = this.#pending.size;\n\n        for (const [requestId, pending] of this.#pending) {\n            pending.reject(new Error('All requests cancelled'));\n        }\n\n        this.#pending.clear();\n        // Reset cache to empty object\n        for (const key in this.#cache) {\n            delete this.#cache[key];\n        }\n        return count;\n    }\n\n    /**\n     * Checks if a request is pending.\n     * \n     * @param {string} requestId\n     * @returns {boolean}\n     */\n    has(requestId) {\n        // Fast Object-based check (faster than Map.has)\n        return requestId in this.#cache;\n    }\n\n    /**\n     * Gets a pending request.\n     * \n     * @param {string} requestId\n     * @returns {PendingRequest|undefined}\n     */\n    get(requestId) {\n        // Fast Object-based lookup\n        return this.#cache[requestId];\n    }\n\n    /**\n     * Gets count of pending requests.\n     * @returns {number}\n     */\n    get size() {\n        return this.#pending.size;\n    }\n\n    /**\n     * Gets all pending request IDs.\n     * @returns {string[]}\n     */\n    getRequestIds() {\n        return Array.from(this.#pending.keys());\n    }\n\n    /**\n     * Gets pending requests for a specific peer.\n     * \n     * @param {string} peerId\n     * @returns {PendingRequest[]}\n     */\n    getForPeer(peerId) {\n        const requests = [];\n        for (const pending of this.#pending.values()) {\n            if (pending.targetPeer === peerId) {\n                requests.push(pending);\n            }\n        }\n        return requests;\n    }\n}\n","/**\n * @fileoverview Secure handshake protocol for peer negotiation.\n * Handles connection establishment, authentication, and capability exchange.\n * @module security/handshake\n */\n\nimport { MessageType, HandshakePhase } from '../common/types.js';\nimport { ErrorCode } from '../common/errors.js';\nimport { uuid, deferred, withTimeout } from '../common/utils.js';\n\n/**\n * @typedef {Object} HandshakeConfig\n * @property {string} [peerId] - Our peer ID (auto-generated if not specified).\n * @property {number} [timeout=10000] - Handshake timeout in ms.\n * @property {Object} [meta={}] - Metadata to share with peer.\n * @property {string[]} [capabilities=[]] - Supported capabilities.\n */\n\n/**\n * @typedef {Object} PeerInfo\n * @property {string} peerId - Remote peer's ID.\n * @property {string} origin - Remote peer's origin.\n * @property {string} type - Remote peer's type (iframe, worker, etc).\n * @property {Object} meta - Remote peer's metadata.\n * @property {string[]} capabilities - Remote peer's capabilities.\n * @property {number} connectedAt - Connection timestamp.\n */\n\n/**\n * @typedef {Object} HandshakeResult\n * @property {boolean} success - Whether handshake succeeded.\n * @property {PeerInfo} [peer] - Peer info if successful.\n * @property {string} [error] - Error code if failed.\n * @property {string} [reason] - Error reason if failed.\n */\n\n/**\n * Handshake protocol for secure peer establishment.\n * \n * Protocol flow:\n * ```\n * INITIATOR                          RESPONDER\n *                                        \n *       HANDSHAKE_INIT                   \n *       { peerId, meta, caps }           \n *         \n *                                        \n *       HANDSHAKE_ACK                    \n *       { peerId, meta, caps, accept }   \n *         \n *                                        \n *       HANDSHAKE_COMPLETE               \n *       { confirmed: true }              \n *         \n *                                        \n *        Connected                      \n * ```\n */\nexport class Handshake {\n    /** @type {string} */\n    #localPeerId;\n\n    /** @type {Object} */\n    #meta;\n\n    /** @type {string[]} */\n    #capabilities;\n\n    /** @type {number} */\n    #timeout;\n\n    /** @type {Map<string, Object>} */\n    #pendingHandshakes = new Map();\n\n    /**\n     * Creates a new Handshake handler.\n     * \n     * @param {HandshakeConfig} [config={}]\n     */\n    constructor(config = {}) {\n        this.#localPeerId = config.peerId ?? uuid();\n        this.#meta = config.meta ?? {};\n        this.#capabilities = config.capabilities ?? [];\n        this.#timeout = config.timeout ?? 10000;\n    }\n\n    /**\n     * Gets the local peer ID.\n     * @returns {string}\n     */\n    get peerId() {\n        return this.#localPeerId;\n    }\n\n    /**\n     * Creates a handshake initiation message.\n     * \n     * @returns {Object} Handshake init message.\n     */\n    createInitMessage() {\n        return {\n            type: MessageType.HANDSHAKE_INIT,\n            handshakeId: uuid(),\n            peerId: this.#localPeerId,\n            meta: this.#meta,\n            capabilities: this.#capabilities,\n            timestamp: Date.now()\n        };\n    }\n\n    /**\n     * Creates a handshake acknowledgment message.\n     * \n     * @param {Object} initMessage - The received init message.\n     * @param {boolean} accept - Whether to accept the connection.\n     * @param {string} [reason] - Rejection reason if not accepted.\n     * @returns {Object} Handshake ack message.\n     */\n    createAckMessage(initMessage, accept, reason) {\n        return {\n            type: MessageType.HANDSHAKE_ACK,\n            handshakeId: initMessage.handshakeId,\n            peerId: this.#localPeerId,\n            meta: this.#meta,\n            capabilities: this.#capabilities,\n            accept,\n            reason: accept ? undefined : reason,\n            timestamp: Date.now()\n        };\n    }\n\n    /**\n     * Creates a handshake completion message.\n     * \n     * @param {string} handshakeId - The handshake ID.\n     * @returns {Object} Handshake complete message.\n     */\n    createCompleteMessage(handshakeId) {\n        return {\n            type: MessageType.HANDSHAKE_COMPLETE,\n            handshakeId,\n            confirmed: true,\n            timestamp: Date.now()\n        };\n    }\n\n    /**\n     * Initiates a handshake with a peer.\n     * \n     * @param {EventListener} sendFn - Function to send messages to peer.\n     * @returns {Promise<HandshakeResult>} Result of handshake attempt.\n     */\n    async initiate(sendFn) {\n        const initMsg = this.createInitMessage();\n        const { promise, resolve, reject } = deferred();\n\n        // Store pending handshake\n        this.#pendingHandshakes.set(initMsg.handshakeId, {\n            phase: HandshakePhase.INIT_SENT,\n            resolve,\n            reject,\n            initMsg,\n            startTime: Date.now()\n        });\n\n        // Send init message\n        sendFn(initMsg);\n\n        // Wait for response with timeout\n        try {\n            const result = await withTimeout(promise, this.#timeout);\n            return result;\n        } catch (/** @type {any} */ error) {\n            this.#pendingHandshakes.delete(initMsg.handshakeId);\n\n            if (error.code === ErrorCode.HANDSHAKE_TIMEOUT) {\n                return {\n                    success: false,\n                    error: ErrorCode.HANDSHAKE_TIMEOUT,\n                    reason: `Handshake timeout after ${this.#timeout}ms`\n                };\n            }\n\n            return {\n                success: false,\n                error: ErrorCode.HANDSHAKE_REJECTED,\n                reason: error.message\n            };\n        }\n    }\n\n    /**\n     * Handles a received handshake message.\n     * \n     * @param {Object} message - Received handshake message.\n     * @param {string} origin - Origin of the message.\n     * @param {EventListener} sendFn - Function to send response.\n     * @param {EventListener} [validateFn] - Optional validation function.\n     * @returns {PeerInfo|null} Peer info if handshake completes, null otherwise.\n     */\n    handleMessage(message, origin, sendFn, validateFn) {\n        switch (message.type) {\n            case MessageType.HANDSHAKE_INIT:\n                return this.#handleInit(message, origin, sendFn, validateFn);\n\n            case MessageType.HANDSHAKE_ACK:\n                return this.#handleAck(message, origin, sendFn);\n\n            case MessageType.HANDSHAKE_COMPLETE:\n                return this.#handleComplete(message, origin);\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Checks if a handshake is pending.\n     * \n     * @param {string} handshakeId\n     * @returns {boolean}\n     */\n    hasPending(handshakeId) {\n        return this.#pendingHandshakes.has(handshakeId);\n    }\n\n    /**\n     * Cancels a pending handshake.\n     * \n     * @param {string} handshakeId\n     */\n    cancel(handshakeId) {\n        const pending = this.#pendingHandshakes.get(handshakeId);\n        if (pending) {\n            pending.reject(new Error('Handshake cancelled'));\n            this.#pendingHandshakes.delete(handshakeId);\n        }\n    }\n\n    /**\n     * Cancels all pending handshakes.\n     */\n    cancelAll() {\n        for (const [id, pending] of this.#pendingHandshakes) {\n            pending.reject(new Error('All handshakes cancelled'));\n        }\n        this.#pendingHandshakes.clear();\n    }\n\n    // \n    // Private handlers\n    // \n\n    /**\n     * Handles HANDSHAKE_INIT message (we are responder).\n     * \n     */\n    #handleInit(message, origin, sendFn, validateFn) {\n        // Validate if validator provided\n        if (validateFn && !validateFn(message, origin)) {\n            const ack = this.createAckMessage(message, false, 'Validation failed');\n            sendFn(ack);\n            return null;\n        }\n\n        // Accept the connection\n        const ack = this.createAckMessage(message, true);\n        sendFn(ack);\n\n        // Store awaiting complete\n        this.#pendingHandshakes.set(message.handshakeId, {\n            phase: HandshakePhase.ACK_SENT,\n            remotePeer: {\n                peerId: message.peerId,\n                origin,\n                meta: message.meta,\n                capabilities: message.capabilities\n            }\n        });\n\n        return null; // Wait for complete message\n    }\n\n    /**\n     * Handles HANDSHAKE_ACK message (we are initiator).\n     * \n     */\n    #handleAck(message, origin, sendFn) {\n        const pending = this.#pendingHandshakes.get(message.handshakeId);\n        if (!pending) {\n            return null; // Unknown handshake\n        }\n\n        if (!message.accept) {\n            // Rejected\n            pending.reject(new Error(message.reason || 'Connection rejected'));\n            this.#pendingHandshakes.delete(message.handshakeId);\n            return null;\n        }\n\n        // Send complete message\n        const complete = this.createCompleteMessage(message.handshakeId);\n        sendFn(complete);\n\n        // Create peer info\n        const peerInfo = {\n            peerId: message.peerId,\n            origin,\n            meta: message.meta,\n            capabilities: message.capabilities,\n            type: 'unknown', // Will be updated by PeerRegistry\n            connectedAt: Date.now()\n        };\n\n        // Resolve the promise\n        pending.resolve({\n            success: true,\n            peer: peerInfo\n        });\n\n        this.#pendingHandshakes.delete(message.handshakeId);\n        return peerInfo;\n    }\n\n    /**\n     * Handles HANDSHAKE_COMPLETE message (we are responder).\n     * \n     */\n    #handleComplete(message, origin) {\n        const pending = this.#pendingHandshakes.get(message.handshakeId);\n        if (!pending || pending.phase !== HandshakePhase.ACK_SENT) {\n            return null;\n        }\n\n        if (!message.confirmed) {\n            this.#pendingHandshakes.delete(message.handshakeId);\n            return null;\n        }\n\n        // Handshake complete!\n        const peerInfo = {\n            ...pending.remotePeer,\n            connectedAt: Date.now()\n        };\n\n        this.#pendingHandshakes.delete(message.handshakeId);\n        return peerInfo;\n    }\n}\n","/**\n * @fileoverview Origin validation for cross-origin security.\n * Validates message origins against an allowlist.\n * @module security/origin-validator\n */\n\n/**\n * @typedef {Object} OriginValidatorOptions\n * @property {string[]} [allowed=[]] - Allowed origins. Empty = same-origin only.\n * @property {boolean} [allowAll=false] - Allow all origins (dangerous!).\n */\n\n/**\n * Validates message origins against a configured allowlist.\n * \n * Supports:\n * - Exact matches: 'https://example.com'\n * - Wildcards: 'https://*.example.com' (subdomains only)\n * - Protocols: 'chrome-extension://*', 'file://*'\n * \n * @example\n * const validator = new OriginValidator({\n *   allowed: [\n *     'https://app.example.com',\n *     'https://*.widgets.com'\n *   ]\n * });\n * \n * validator.isAllowed('https://app.example.com');     // true\n * validator.isAllowed('https://foo.widgets.com');     // true\n * validator.isAllowed('https://evil.com');            // false\n */\nexport class OriginValidator {\n    /** @type {Set<string>} */\n    #exactOrigins = new Set();\n\n    /** @type {RegExp[]} */\n    #patterns = [];\n\n    /** @type {boolean} */\n    #allowAll = false;\n\n    /** @type {string|undefined} */\n    #selfOrigin;\n\n    /**\n     * Creates a new origin validator.\n     * \n     * @param {OriginValidatorOptions} [options={}] - Configuration.\n     */\n    constructor(options = {}) {\n        this.#allowAll = options.allowAll ?? false;\n        this.#selfOrigin = globalThis.location?.origin;\n\n        // Process allowed origins\n        if (options.allowed) {\n            for (const origin of options.allowed) {\n                this.#addOrigin(origin);\n            }\n        }\n    }\n\n    /**\n     * Checks if an origin is allowed.\n     * \n     * @param {string} origin - Origin to check (e.g., 'https://example.com').\n     * @returns {boolean} True if allowed.\n     * \n     * @example\n     * validator.isAllowed('https://trusted.com');  // true\n     * validator.isAllowed('https://unknown.com');  // false\n     */\n    isAllowed(origin) {\n        // Allow-all mode (dangerous but sometimes needed)\n        if (this.#allowAll) {\n            return true;\n        }\n\n        // Null origin (file://, sandboxed iframes, etc.)\n        if (origin === 'null' || origin === null) {\n            return this.#exactOrigins.has('null');\n        }\n\n        // Empty/no allowed origins = same-origin only\n        if (this.#exactOrigins.size === 0 && this.#patterns.length === 0) {\n            return origin === this.#selfOrigin;\n        }\n\n        // Check exact match first (fast path)\n        if (this.#exactOrigins.has(origin)) {\n            return true;\n        }\n\n        // Check pattern matches\n        for (const pattern of this.#patterns) {\n            if (pattern.test(origin)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Adds an origin to the allowlist.\n     * \n     * @param {string} origin - Origin to add (supports wildcards).\n     * @returns {this} For chaining.\n     */\n    allow(origin) {\n        this.#addOrigin(origin);\n        return this;\n    }\n\n    /**\n     * Removes an origin from the allowlist.\n     * \n     * @param {string} origin - Origin to remove.\n     * @returns {boolean} True if removed.\n     */\n    disallow(origin) {\n        // For exact origins\n        if (this.#exactOrigins.has(origin)) {\n            this.#exactOrigins.delete(origin);\n            return true;\n        }\n\n        // For patterns, we'd need to store the original string\n        // For simplicity, patterns cannot be removed individually\n        return false;\n    }\n\n    /**\n     * Gets all exact (non-pattern) allowed origins.\n     * \n     * @returns {string[]} Array of allowed origins.\n     */\n    getAllowed() {\n        return Array.from(this.#exactOrigins);\n    }\n\n    /**\n     * Clears all allowed origins.\n     */\n    clear() {\n        this.#exactOrigins.clear();\n        this.#patterns = [];\n    }\n\n    /**\n     * Gets the current origin (if available).\n     * @returns {string|undefined}\n     */\n    get selfOrigin() {\n        return this.#selfOrigin;\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Adds an origin to the appropriate collection.\n     * \n     * @param {string} origin\n     */\n    #addOrigin(origin) {\n        if (typeof origin !== 'string') {\n            throw new TypeError('Origin must be a string');\n        }\n\n        // Wildcard '*' means allow all\n        if (origin === '*') {\n            this.#allowAll = true;\n            return;\n        }\n\n        // Contains wildcards - create pattern\n        if (origin.includes('*')) {\n            const pattern = this.#createPattern(origin);\n            this.#patterns.push(pattern);\n        } else {\n            // Exact origin\n            this.#exactOrigins.add(origin);\n        }\n    }\n\n    /**\n     * Creates a RegExp from a wildcard pattern.\n     * Uses bounded quantifiers to prevent ReDoS attacks.\n     * \n     * @param {string} pattern - Pattern with wildcards.\n     * @returns {RegExp}\n     */\n    #createPattern(pattern) {\n        // Escape special regex characters except *\n        const escaped = pattern\n            .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')\n            // Use bounded quantifier to prevent catastrophic backtracking\n            // Allows up to 253 chars per segment (max DNS label)\n            .replace(/\\*/g, '[a-zA-Z0-9.-]{0,253}');\n\n        return new RegExp(`^${escaped}$`);\n    }\n}\n\n/**\n * Creates an origin validator with common configurations.\n */\nexport const OriginValidatorPresets = {\n    /**\n     * Same-origin only (most secure).\n     * @returns {OriginValidator}\n     */\n    sameOrigin() {\n        return new OriginValidator();\n    },\n\n    /**\n     * Allow all origins (use with caution!).\n     * @returns {OriginValidator}\n     */\n    allowAll() {\n        return new OriginValidator({ allowAll: true });\n    },\n\n    /**\n     * Allow specific domains.\n     * @param {string[]} origins\n     * @returns {OriginValidator}\n     */\n    fromList(origins) {\n        return new OriginValidator({ allowed: origins });\n    }\n};\n","/**\n * @fileoverview CrossBus - Main facade for cross-context messaging.\n * Provides a unified API for inter-context communication.\n * @module core/cross-bus\n */\n\nimport { EventEmitter } from './event-emitter.js';\nimport { MessageType, PeerStatus } from '../common/types.js';\nimport { createSignalMessage, createRequestMessage, createResponseMessage } from './message-types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { uuid } from '../common/utils.js';\nimport { MessageRouter } from '../router/message-router.js';\nimport { PendingRequests } from '../router/pending-requests.js';\nimport { Handshake } from '../security/handshake.js';\nimport { OriginValidator } from '../security/origin-validator.js';\n\n/**\n * @typedef {Object} CrossBusOptions\n * @property {string} [peerId] - Unique peer identifier (auto-generated if not specified).\n * @property {boolean} [isHub=false] - Whether this instance is the hub.\n * @property {number} [requestTimeout=30000] - Default request timeout in ms.\n * @property {number} [handshakeTimeout=10000] - Handshake timeout in ms.\n * @property {string[]} [allowedOrigins=[]] - Allowed origins for incoming connections.\n * @property {Object} [meta={}] - Metadata to share with peers.\n * @property {string[]} [capabilities=[]] - Supported capabilities.\n * @property {string} [contentType='application/json'] - Preferred serialization format.\n * @property {number} [maxPayloadSize=1048576] - Maximum payload size in bytes (default: 1MB).\n * @property {number} [maxPendingRequests=100] - Maximum concurrent pending requests.\n * @property {boolean} [strictMode=false] - Enforce strict security (disallows wildcard origins).\n * @property {boolean} [debug=false] - Enable verbose debug logging.\n * @property {string} [debugPrefix='[CrossBus]'] - Prefix for debug log messages.\n */\n\n/**\n * @typedef {Object} HandlerOptions\n * @property {string[]} [allowedPeers] - Peer IDs allowed to call this handler.\n * @property {number} [rateLimit] - Max calls per second from each peer.\n * @property {Function} [validatePayload] - Custom payload validator function.\n */\n\n/**\n * @typedef {Object} PeerInfo\n * @property {string} peerId - Peer identifier.\n * @property {string} origin - Peer origin.\n * @property {Object} meta - Peer metadata.\n * @property {PeerStatus} status - Connection status.\n * @property {number} connectedAt - Connection timestamp.\n */\n\n/**\n * @typedef {Object} RequestOptions\n * @property {number} [timeout] - Request timeout in ms.\n * @property {*} [defaultValue] - Value to return on timeout instead of throwing.\n */\n\n/**\n * @typedef {Object} BroadcastRequestOptions\n * @property {number} [timeout] - Per-peer timeout in ms.\n * @property {string[]} [exclude] - Peer IDs to exclude.\n * @property {boolean} [ignoreErrors=true] - Whether to ignore peer errors.\n */\n\n/**\n * @typedef {Object} HookContext\n * @property {'signal'|'request'|'response'} type - Message type.\n * @property {string} [peerId] - Peer ID (if applicable).\n * @property {string} [handlerName] - Handler name (for requests).\n * @property {'inbound'|'outbound'} direction - Hook direction.\n */\n\n/**\n * @callback MessageHook\n * @param {*} payload - Payload to transform.\n * @param {HookContext} context - Hook context.\n * @returns {*|Promise<*>} Transformed payload.\n */\n\n/**\n * @typedef {Object} HookEntry\n * @property {MessageHook} fn - Hook function.\n * @property {number} priority - Execution priority (lower = first).\n */\n\n/**\n * @callback RequestHandler\n * @param {*} payload - Request payload.\n * @param {Object} context - Request context (peerId, meta, etc).\n * @returns {Promise<*>|*} - Response data.\n */\n\n/**\n * CrossBus - Zero-leak, high-performance cross-context messaging.\n * \n * Features:\n * - Hub/Mesh routing\n * - Request/Response pattern\n * - Broadcast to all peers\n * - ACK-based reliability\n * - Origin validation\n * - Resource lifecycle management\n * \n * @example\n * // Hub (main page)\n * const hub = new CrossBus({ isHub: true });\n * \n * // Connect iframe\n * hub.connect(iframe.contentWindow, {\n *   targetOrigin: 'https://widget.example.com'\n * });\n * \n * // Register handler\n * hub.handle('getData', async (payload, ctx) => {\n *   return { items: await fetchItems() };\n * });\n * \n * // Emit signal\n * hub.emit('user:login', { userId: 123 });\n * \n * // Request/Response\n * const result = await hub.request('widget-1', 'getStatus');\n * \n * // Cleanup\n * hub.destroy();\n */\nexport class CrossBus extends EventEmitter {\n    /** @type {string} */\n    #peerId;\n\n    /** @type {boolean} */\n    #isHub;\n\n    /** @type {MessageRouter} */\n    #router;\n\n    /** @type {PendingRequests} */\n    #pendingRequests;\n\n    /** @type {Handshake} */\n    #handshake;\n\n    /** @type {OriginValidator} */\n    #originValidator;\n\n    /** @type {string} */\n    #contentType;\n\n    /** @type {Map<string, RequestHandler>} */\n    #handlers = new Map();\n\n    /** @type {HookEntry[]} */\n    #inboundHooks = [];\n\n    /** @type {HookEntry[]} */\n    #outboundHooks = [];\n\n    /** @type {Object} */\n    #meta;\n\n    /** @type {string[]} */\n    #capabilities;\n\n    /** @type {number} */\n    #requestTimeout;\n\n    /** @type {number} */\n    #maxPayloadSize;\n\n    /** @type {number} */\n    #maxPendingRequests;\n\n    /** @type {boolean} */\n    #strictMode;\n\n    /** @type {Map<string, { count: number, resetAt: number }>} */\n    #rateLimitCounters = new Map();\n\n    /** @type {Map<string, HandlerOptions>} */\n    #handlerOptions = new Map();\n\n    /** @type {boolean} */\n    #debug = false;\n\n    /** @type {string} */\n    #debugPrefix = '[CrossBus]';\n\n    /** @type {number} */\n    #createdAt;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /**\n     * Creates a new CrossBus instance.\n     * \n     * @param {CrossBusOptions} [options={}]\n     */\n    constructor(options = {}) {\n        super();\n\n        this.#peerId = options.peerId ?? uuid();\n        this.#isHub = options.isHub ?? false;\n        this.#meta = options.meta ?? {};\n        this.#capabilities = options.capabilities ?? [];\n        this.#requestTimeout = options.requestTimeout ?? 30000;\n\n        // Initialize components\n        this.#router = new MessageRouter();\n        this.#pendingRequests = new PendingRequests({\n            defaultTimeout: this.#requestTimeout\n        });\n        this.#handshake = new Handshake({\n            peerId: this.#peerId,\n            meta: this.#meta,\n            capabilities: this.#capabilities,\n            timeout: options.handshakeTimeout ?? 10000\n        });\n        this.#originValidator = new OriginValidator({\n            allowed: options.allowedOrigins ?? []\n        });\n\n        // Serialization setup\n        this.#contentType = options.contentType ?? 'application/json';\n        // this.#serializer = getSerializer(this.#contentType);\n\n        // Security settings\n        this.#maxPayloadSize = options.maxPayloadSize ?? 1024 * 1024; // 1MB\n        this.#maxPendingRequests = options.maxPendingRequests ?? 100;\n        this.#strictMode = options.strictMode ?? false;\n\n        // Debug settings\n        this.#debug = options.debug ?? false;\n        this.#debugPrefix = options.debugPrefix ?? '[CrossBus]';\n        this.#createdAt = Date.now();\n\n        // Development security warnings\n        this.#emitSecurityWarnings(options);\n\n        // Initialize handshake capability\n        this.#capabilities.push(`serializer:${this.#contentType}`);\n\n        // Wire up router events\n        this.#router.on('peer:added', (e) => { this.emit('peer:connected', e.data); });\n        this.#router.on('peer:removed', (e) => { this.emit('peer:disconnected', e.data); });\n        this.#router.on('peer:status', (e) => { this.emit('peer:status', e.data); });\n\n        if (this.#debug) {\n            this.#log('info', `Initialized (isHub: ${this.#isHub})`);\n        }\n    }\n\n    /**\n     * Gets the local peer ID.\n     * @returns {string}\n     */\n    get peerId() {\n        return this.#peerId;\n    }\n\n    /**\n     * Gets whether this instance is the hub.\n     * @returns {boolean}\n     */\n    get isHub() {\n        return this.#isHub;\n    }\n\n    /**\n     * Gets connected peer count.\n     * @returns {number}\n     */\n    get peerCount() {\n        return this.#router.peerCount;\n    }\n\n    /**\n     * Gets all connected peer IDs.\n     * @returns {string[]}\n     */\n    get peers() {\n        return this.#router.getPeerIds();\n    }\n\n    /**\n     * Gets peer info by ID.\n     * \n     * @param {string} peerId\n     * @returns {PeerInfo|undefined}\n     */\n    getPeer(peerId) {\n        return this.#router.getPeer(peerId);\n    }\n\n    // \n    // Messaging API\n    // \n\n    /**\n     * Sends a signal to all connected peers.\n     * \n     * @param {string} signalName - Signal name (e.g., 'user:login').\n     * @param {*} [payload] - Signal payload.\n     * @param {Object} [options={}] - Send options.\n     * @param {string[]} [options.exclude] - Peer IDs to exclude.\n     * @returns {Promise<{ delivered: number, failed: string[] }>}\n     *  \n     * @example\n     * bus.signal('user:login', { userId: 123 });\n     */\n    async signal(signalName, payload, options = {}) {\n        this.#assertNotDestroyed();\n\n        // Apply outbound hooks\n        const transformedPayload = await this.#runHooks(\n            this.#outboundHooks,\n            payload,\n            { type: 'signal', direction: 'outbound' }\n        );\n\n        const message = createSignalMessage(\n            signalName,\n            transformedPayload,\n            this.#peerId\n        );\n\n        const result = await this.#router.broadcast(message, options);\n\n        this.#log('out', `SIGNAL \"${signalName}\" to ${result.delivered} peers`);\n\n        return result;\n    }\n\n    /**\n     * Sends a request to a specific peer and waits for response.\n     * \n     * @param {string} peerId - Target peer ID.\n     * @param {string} handlerName - Handler to invoke.\n     * @param {*} [payload] - Request payload.\n     * @param {RequestOptions} [options={}]\n     * @returns {Promise<*>} Handler response.\n     * \n     * @example\n     * const data = await bus.request('widget-1', 'getData', { id: 5 });\n     */\n    async request(peerId, handlerName, payload, options = {}) {\n        this.#assertNotDestroyed();\n\n        this.#log('out', `REQUEST \"${handlerName}\" to ${peerId}`);\n\n        const peer = this.#router.getPeer(peerId);\n        if (!peer) {\n            throw CrossBusError.from(ErrorCode.PEER_NOT_FOUND, { peerId });\n        }\n\n        // Create pending request\n        const { requestId, promise } = this.#pendingRequests.create(\n            peerId,\n            handlerName,\n            { timeout: options.timeout ?? this.#requestTimeout }\n        );\n\n        // Apply outbound hooks\n        const transformedPayload = await this.#runHooks(\n            this.#outboundHooks,\n            payload,\n            { type: 'request', peerId, handlerName, direction: 'outbound' }\n        );\n\n        // Build request message\n        const message = createRequestMessage(\n            handlerName,\n            transformedPayload,\n            this.#peerId,\n            peerId,\n            requestId // Pass the tracking ID\n        );\n\n        // Send request\n        const result = this.#router.route({ target: peerId, payload: message });\n\n        if (!result.success) {\n            this.#pendingRequests.cancel(requestId);\n            throw CrossBusError.from(ErrorCode.SEND_FAILED, { peerId });\n        }\n\n        return promise;\n    }\n\n    /**\n     * Broadcasts a request to all peers and collects responses.\n     * \n     * @param {string} handlerName - Handler to invoke on all peers.\n     * @param {*} [payload] - Request payload.\n     * @param {BroadcastRequestOptions} [options={}]\n     * @returns {Promise<Map<string, *>>} Map of peerId -> response.\n     * \n     * @example\n     * const responses = await bus.broadcastRequest('getStatus');\n     * for (const [peerId, status] of responses) {\n     *   console.log(`${peerId}: ${status.state}`);\n     * }\n     */\n    async broadcastRequest(handlerName, payload, options = {}) {\n        this.#assertNotDestroyed();\n\n        const timeout = options.timeout ?? this.#requestTimeout;\n        const ignoreErrors = options.ignoreErrors ?? true;\n        const exclude = new Set(options.exclude ?? []);\n\n        const results = new Map();\n        const promises = [];\n\n        for (const peerId of this.#router.getPeerIds()) {\n            if (exclude.has(peerId)) continue;\n\n            const requestPromise = this.request(peerId, handlerName, payload, { timeout })\n                .then(response => {\n                    results.set(peerId, { success: true, data: response });\n                })\n                .catch(error => {\n                    if (ignoreErrors) {\n                        results.set(peerId, { success: false, error: error.message });\n                    } else {\n                        throw error;\n                    }\n                });\n\n            promises.push(requestPromise);\n        }\n\n        await Promise.all(promises);\n        return results;\n    }\n\n    // \n    // Handler API\n    // \n\n    /**\n     * Registers a request handler.\n     * \n     * @param {string} handlerName - Handler name.\n     * @param {RequestHandler} handler - Handler function.\n     * @param {HandlerOptions} [options={}] - Security options.\n     * @returns {Function} Unregister function.\n     * \n     * @example\n     * // Basic handler\n     * const unhandle = bus.handle('getData', async (payload, ctx) => {\n     *   return await fetchData(payload.id);\n     * });\n     * \n     * // Secure handler with restrictions\n     * bus.handle('sensitiveData', async (payload) => { ... }, {\n     *   allowedPeers: ['trusted-agent'],  // Only these peers can call\n     *   rateLimit: 10,                    // Max 10 calls/second per peer\n     *   validatePayload: (p) => p.id != null  // Custom validation\n     * });\n     */\n    handle(handlerName, handler, options = {}) {\n        if (this.#handlers.has(handlerName)) {\n            throw CrossBusError.from(ErrorCode.HANDLER_EXISTS, { handlerName });\n        }\n\n        // Store handler options for security checks\n        if (options.allowedPeers || options.rateLimit || options.validatePayload) {\n            this.#handlerOptions.set(handlerName, options);\n        }\n\n        this.#handlers.set(handlerName, handler);\n\n        return () => {\n            this.#handlers.delete(handlerName);\n            this.#handlerOptions.delete(handlerName);\n        };\n    }\n\n    /**\n     * Removes a handler.\n     * \n     * @param {string} handlerName\n     * @returns {boolean} True if handler was removed.\n     */\n    unhandle(handlerName) {\n        return this.#handlers.delete(handlerName);\n    }\n\n    /**\n     * Checks if a handler is registered.\n     * \n     * @param {string} handlerName\n     * @returns {boolean}\n     */\n    hasHandler(handlerName) {\n        return this.#handlers.has(handlerName);\n    }\n\n    // \n    // Hook API\n    // \n\n    /**\n     * Adds an inbound hook to transform incoming payloads.\n     * \n     * @param {MessageHook} hookFn - Hook function.\n     * @param {number} [priority=10] - Execution priority (lower = first).\n     * @returns {Function} Unregister function.\n     * \n     * @example\n     * // Decrypt incoming messages\n     * const unhook = bus.addInboundHook(async (payload, ctx) => {\n     *   return await decrypt(payload);\n     * });\n     */\n    addInboundHook(hookFn, priority = 10) {\n        if (typeof hookFn !== 'function') {\n            throw new TypeError('hookFn must be a function');\n        }\n\n        const entry = { fn: hookFn, priority };\n        this.#inboundHooks.push(entry);\n        this.#inboundHooks.sort((a, b) => a.priority - b.priority);\n\n        return () => this.removeInboundHook(hookFn);\n    }\n\n    /**\n     * Adds an outbound hook to transform outgoing payloads.\n     * \n     * @param {MessageHook} hookFn - Hook function.\n     * @param {number} [priority=10] - Execution priority (lower = first).\n     * @returns {Function} Unregister function.\n     * \n     * @example\n     * // Encrypt outgoing messages\n     * const unhook = bus.addOutboundHook(async (payload, ctx) => {\n     *   return await encrypt(payload);\n     * });\n     */\n    addOutboundHook(hookFn, priority = 10) {\n        if (typeof hookFn !== 'function') {\n            throw new TypeError('hookFn must be a function');\n        }\n\n        const entry = { fn: hookFn, priority };\n        this.#outboundHooks.push(entry);\n        this.#outboundHooks.sort((a, b) => a.priority - b.priority);\n\n        return () => this.removeOutboundHook(hookFn);\n    }\n\n    /**\n     * Removes an inbound hook.\n     * \n     * @param {MessageHook} hookFn\n     * @returns {boolean} True if removed.\n     */\n    removeInboundHook(hookFn) {\n        const index = this.#inboundHooks.findIndex(e => e.fn === hookFn);\n        if (index !== -1) {\n            this.#inboundHooks.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes an outbound hook.\n     * \n     * @param {MessageHook} hookFn\n     * @returns {boolean} True if removed.\n     */\n    removeOutboundHook(hookFn) {\n        const index = this.#outboundHooks.findIndex(e => e.fn === hookFn);\n        if (index !== -1) {\n            this.#outboundHooks.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n\n    // \n    // Connection API\n    // \n\n    /**\n     * Adds a peer with a send function.\n     * Used for hub mode when managing connections manually.\n     * \n     * @param {string} peerId - Peer identifier.\n     * @param {EventListener} sendFn - Function to send messages.\n     * @param {Object} [options={}] - Additional options.\n     */\n    addPeer(peerId, sendFn, options = {}) {\n        this.#assertNotDestroyed();\n        this.#router.addPeer(peerId, sendFn, options);\n    }\n\n    /**\n     * Removes a peer.\n     * \n     * @param {string} peerId\n     * @returns {boolean}\n     */\n    removePeer(peerId) {\n        this.#pendingRequests.cancelForPeer(peerId);\n        return this.#router.removePeer(peerId);\n    }\n\n    /**\n     * Adds a transport and automatically wires up message handling.\n     * This is the recommended way to connect transports for AI agents.\n     * \n     * @param {Object} transport - Transport instance with send() and onMessage() methods.\n     * @param {Object} [options={}] - Additional options.\n     * @param {string} [options.peerId] - Override peer ID (defaults to transport's peerId or auto-generated).\n     * @param {string} [options.origin='*'] - Origin for message validation.\n     * @returns {Function} Cleanup function to remove the transport.\n     * \n     * @example\n     * // Simple usage\n     * const cleanup = bus.addTransport(new PostMessageTransport(iframe.contentWindow));\n     * \n     * // With options\n     * const cleanup = bus.addTransport(transport, { peerId: 'my-agent' });\n     * \n     * // Cleanup when done\n     * cleanup();\n     */\n    addTransport(transport, options = {}) {\n        this.#assertNotDestroyed();\n\n        if (!transport || typeof transport.send !== 'function') {\n            throw new TypeError('Transport must have a send() method');\n        }\n\n        const peerId = options.peerId || transport.peerId || `transport-${uuid()}`;\n        const origin = options.origin || '*';\n\n        // Wire up inbound: transport -> CrossBus\n        if (typeof transport.onMessage === 'function') {\n            transport.onMessage((message) => {\n                this.handleMessage(message, origin, peerId);\n            });\n        }\n\n        // Wire up outbound: CrossBus -> transport\n        this.addPeer(peerId, (message) => {\n            transport.send(message);\n        }, options);\n\n        // Return cleanup function\n        return () => {\n            this.removePeer(peerId);\n            if (typeof transport.destroy === 'function') {\n                transport.destroy();\n            }\n        };\n    }\n\n    /**\n     * Handles an incoming message.\n     * Call this when receiving a message from any transport.\n     * \n     * @param {Object} message - The received message.\n     * @param {string} origin - Origin of the message.\n     * @param {string} [peerId] - Source peer ID if known.\n     * @param {Function} [replyFn] - Function to reply to the sender.\n     */\n    async handleMessage(message, origin, peerId, replyFn) {\n        if (this.#destroyed) return;\n\n        // Validate origin\n        if (!this.#originValidator.isAllowed(origin)) {\n            console.warn(`[CrossBus] Blocked message from unauthorized origin: ${origin}`);\n            return;\n        }\n\n        // Apply inbound hooks to payload\n        // Apply inbound hooks to payload\n        // Support both standard 'payload'/'data' and legacy 'p'\n        const rawPayload = message.payload ?? message.data ?? message.p;\n        const msgType = message.type ?? message.t;\n\n        // Normalize fields based on schema\n        let handlerOrName = message.handler ?? message.name;\n        let dataContent = rawPayload;\n\n        // If ProtocolMessage (has 'payload' object containing metadata), extract from it\n        if (message.payload && typeof message.payload === 'object' && !message.p) {\n            if (msgType === MessageType.SIGNAL || msgType === MessageType.BROADCAST) {\n                handlerOrName = message.payload.name;\n                dataContent = message.payload.data;\n            } else if (msgType === MessageType.REQUEST) {\n                handlerOrName = message.payload.name;\n                dataContent = message.payload.data;\n            } else if (msgType === MessageType.RESPONSE) {\n                // Response payload structure? createResponseMessage puts 'data' in payload\n                dataContent = message.payload.data;\n            }\n        }\n        // Handle envelope format: { t, p: { type, payload: { name, data } } }\n        // Router creates envelopes with 'p' containing the original signal message\n        // Detect by: has 't' (not 'type'), has 'p' with nested 'payload' (ProtocolMessage structure)\n        else if (message.t && !message.type && message.p && typeof message.p === 'object' && message.p.payload) {\n            const innerMsg = message.p;\n            // Extract from nested ProtocolMessage\n            handlerOrName = innerMsg.payload.name ?? innerMsg.name;\n            dataContent = innerMsg.payload.data ?? innerMsg.data;\n        }\n\n        if (dataContent !== undefined) {\n            const hookContext = {\n                type: msgType === MessageType.SIGNAL ? 'signal' :\n                    msgType === MessageType.REQUEST ? 'request' : 'response',\n                peerId,\n                handlerName: handlerOrName,\n                direction: 'inbound'\n            };\n            // Run hooks\n            dataContent = await this.#runHooks(this.#inboundHooks, dataContent, hookContext);\n        }\n\n        switch (msgType) {\n            case MessageType.BROADCAST:  // Broadcast has same structure as signal\n            case MessageType.SIGNAL:\n                if (typeof handlerOrName !== 'string') {\n                    console.warn('[CrossBus] Invalid signal name type');\n                    return;\n                }\n                await this.#handleSignal(handlerOrName, dataContent, peerId);\n                break;\n\n            case MessageType.REQUEST:\n                if (typeof handlerOrName !== 'string') {\n                    console.warn('[CrossBus] Invalid handler name type');\n                    return;\n                }\n                // Pass normalized ID\n                // const reqId = message.id ?? (message.payload ? message.payload.id : undefined);\n                // Wait, 'id' is top level in ProtocolMessage AND legacy.\n\n                await this.#handleRequest(message.id, handlerOrName, dataContent, peerId, replyFn);\n                break;\n\n            case MessageType.RESPONSE: {\n                let success = message.success;\n                let error = message.error;\n\n                // Extract from ProtocolMessage payload if needed\n                if (message.payload && message.payload.success !== undefined) {\n                    success = message.payload.success;\n                    error = message.payload.error;\n                }\n\n                // If legacy response structure inside payload?\n                this.#handleResponse(message.payload?.requestId ?? message.id, success, dataContent, error);\n                break;\n            }\n\n            case MessageType.HANDSHAKE_INIT:\n            case MessageType.HANDSHAKE_ACK:\n            case MessageType.HANDSHAKE_COMPLETE:\n                this.#handshake.handleMessage(message, origin, /** @type {EventListener} */(replyFn));\n                break;\n\n            default:\n                console.warn(`[CrossBus] Unknown message type: ${msgType}`);\n        }\n    }\n\n    // \n    // Lifecycle\n    // \n\n    /**\n     * Destroys the CrossBus, cleaning up all resources.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n\n        // Cancel all pending requests\n        this.#pendingRequests.cancelAll();\n\n        // Clear handlers\n        this.#handlers.clear();\n\n        // Clear peers\n        this.#router.clearPeers();\n\n        // Clear event listeners\n        this.clear();\n\n        this.emit('destroyed', {});\n    }\n\n    /**\n     * Checks if the bus has been destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n\n    // \n    // Private handlers\n    // \n\n    /**\n     * Handles incoming signal.\n     * \n     */\n    async #handleSignal(name, data, peerId) {\n        await this.emit(name, {\n            payload: data,\n            source: peerId\n        });\n    }\n\n    /**\n     * Handles incoming request.\n     * \n     */\n    async #handleRequest(requestId, handlerName, data, peerId, replyFn) {\n        const handler = this.#handlers.get(handlerName);\n\n        let response;\n\n        if (!handler) {\n            response = createResponseMessage(\n                requestId,\n                null,\n                this.#peerId,\n                false,\n                {\n                    code: ErrorCode.NO_HANDLER,\n                    message: 'Handler not found'\n                }\n            );\n        } else {\n            // Check handler security (allowedPeers, rateLimit, validatePayload)\n            const securityCheck = this.#checkHandlerSecurity(handlerName, peerId, data);\n            if (!securityCheck.allowed) {\n                response = createResponseMessage(\n                    requestId,\n                    null,\n                    this.#peerId,\n                    false,\n                    {\n                        code: securityCheck.error?.code ?? ErrorCode.UNAUTHORIZED,\n                        message: securityCheck.error?.message ?? 'Security check failed'\n                    }\n                );\n            } else {\n                try {\n                    const result = await handler(data, {\n                        peerId,\n                        requestId: requestId,\n                        handlerName: handlerName\n                    });\n\n                    // Apply outbound hooks to response\n                    const transformedResult = await this.#runHooks(\n                        this.#outboundHooks,\n                        result,\n                        { type: 'response', peerId, handlerName: handlerName, direction: 'outbound' }\n                    );\n\n                    response = createResponseMessage(\n                        requestId,\n                        transformedResult,\n                        this.#peerId,\n                        true\n                    );\n                } catch (/** @type {any} */ error) {\n                    response = createResponseMessage(\n                        requestId,\n                        null,\n                        this.#peerId,\n                        false,\n                        {\n                            code: error.code ?? ErrorCode.HANDLER_ERROR,\n                            message: error.message\n                        }\n                    );\n                }\n            }\n        }\n\n        // Send response\n        if (replyFn) {\n            replyFn(response);\n        } else if (peerId) {\n            this.#router.route({ target: peerId, payload: response });\n        }\n    }\n\n    /**\n     * Handles incoming response.\n     * \n     */\n    #handleResponse(requestId, success, data, error) {\n        this.#pendingRequests.resolve(requestId, {\n            requestId,\n            success,\n            data,\n            error\n        });\n    }\n\n    /**\n     * Asserts the bus is not destroyed.\n     * \n     */\n    #assertNotDestroyed() {\n        if (this.#destroyed) {\n            throw CrossBusError.from(ErrorCode.DESTROYED, {\n                context: 'CrossBus operation'\n            });\n        }\n    }\n\n    /**\n     * Runs a chain of hooks on a payload.\n     * \n     */\n    async #runHooks(hooks, payload, context) {\n        let current = payload;\n        for (const { fn } of hooks) {\n            try {\n                current = await fn(current, context);\n            } catch (error) {\n                console.error('[CrossBus] Hook error:', error);\n                // Continue with unmodified payload on error\n            }\n        }\n        return current;\n    }\n\n    // \n    // Security Methods\n    // \n\n    /**\n     * Emits security warnings in development mode.\n     * @param {CrossBusOptions} options\n     */\n    #emitSecurityWarnings(options) {\n        // Only warn in development\n        const isDev = typeof process !== 'undefined'\n            ? process.env?.NODE_ENV !== 'production'\n            : typeof window !== 'undefined' && window.location?.hostname === 'localhost';\n\n        if (!isDev) return;\n\n        // Warn if allowedOrigins is not specified\n        if (!options.allowedOrigins || options.allowedOrigins.length === 0) {\n            console.warn(\n                '[CrossBus Security]  No allowedOrigins specified.\\n' +\n                'This bus will REJECT all incoming messages from transports.\\n' +\n                'To receive messages, specify allowed origins:\\n' +\n                '  allowedOrigins: [\"https://trusted-domain.com\"]\\n' +\n                'For development only: allowedOrigins: [\"*\"]'\n            );\n        }\n\n        // Warn about wildcard origins\n        if (options.allowedOrigins?.includes('*')) {\n            console.warn(\n                '[CrossBus Security]  allowedOrigins: [\"*\"] accepts messages from ANY origin.\\n' +\n                'This is INSECURE in production. Use specific origins instead:\\n' +\n                '  allowedOrigins: [\"https://trusted-domain.com\"]\\n' +\n                'For production, use:\\n' +\n                '  CrossBus.createSecure({ allowedOrigins: [\"https://...\"] })\\n' +\n                'Suppress this warning with NODE_ENV=production'\n            );\n\n            // In strict mode, throw error\n            if (this.#strictMode) {\n                throw new Error(\n                    'strictMode: allowedOrigins: [\"*\"] is not allowed. ' +\n                    'Use specific origins for security.'\n                );\n            }\n        }\n    }\n\n    /**\n     * Checks handler security before execution.\n     * @param {string} handlerName\n     * @param {string} peerId\n     * @param {*} payload\n     * @returns {{ allowed: boolean, error?: CrossBusError }}\n     */\n    #checkHandlerSecurity(handlerName, peerId, payload) {\n        const options = this.#handlerOptions.get(handlerName);\n        if (!options) {\n            return { allowed: true };\n        }\n\n        // Check peer allowlist\n        if (options.allowedPeers && !options.allowedPeers.includes(peerId)) {\n            return {\n                allowed: false,\n                error: CrossBusError.from(ErrorCode.UNAUTHORIZED, {\n                    handler: handlerName,\n                    peer: peerId,\n                    allowedPeers: options.allowedPeers\n                })\n            };\n        }\n\n        // Check rate limit\n        if (options.rateLimit) {\n            const limitKey = `${handlerName}:${peerId}`;\n            if (!this.#checkRateLimit(limitKey, options.rateLimit)) {\n                return {\n                    allowed: false,\n                    error: CrossBusError.from(ErrorCode.RATE_LIMITED, {\n                        handler: handlerName,\n                        peer: peerId,\n                        limit: options.rateLimit\n                    })\n                };\n            }\n        }\n\n        // Validate payload\n        if (options.validatePayload) {\n            try {\n                const isValid = options.validatePayload(payload);\n                if (!isValid) {\n                    return {\n                        allowed: false,\n                        error: CrossBusError.from(ErrorCode.INVALID_PAYLOAD, {\n                            handler: handlerName\n                        })\n                    };\n                }\n            } catch (/** @type {any} */ e) {\n                return {\n                    allowed: false,\n                    error: CrossBusError.from(ErrorCode.INVALID_PAYLOAD, {\n                        handler: handlerName,\n                        reason: e?.message ?? 'Validation error'\n                    })\n                };\n            }\n        }\n\n        return { allowed: true };\n    }\n\n    /**\n     * Checks rate limit for a key.\n     * @param {string} key - Rate limit key (e.g., \"handlerName:peerId\")\n     * @param {number} maxPerSecond - Maximum calls per second\n     * @returns {boolean} - True if allowed, false if rate limited\n     */\n    #checkRateLimit(key, maxPerSecond) {\n        const now = Date.now();\n        const counter = this.#rateLimitCounters.get(key);\n\n        if (!counter || now >= counter.resetAt) {\n            // Start new window\n            this.#rateLimitCounters.set(key, {\n                count: 1,\n                resetAt: now + 1000\n            });\n            return true;\n        }\n\n        if (counter.count >= maxPerSecond) {\n            return false;\n        }\n\n        counter.count++;\n        return true;\n    }\n\n\n\n    /**\n     * Gets the maximum payload size.\n     * @returns {number}\n     */\n    get maxPayloadSize() {\n        return this.#maxPayloadSize;\n    }\n\n    /**\n     * Gets whether strict mode is enabled.\n     * @returns {boolean}\n     */\n    get strictMode() {\n        return this.#strictMode;\n    }\n\n    /**\n     * Gets whether debug mode is enabled.\n     * @returns {boolean}\n     */\n    get debug() {\n        return this.#debug;\n    }\n\n    /**\n     * Gets the uptime in milliseconds.\n     * @returns {number}\n     */\n    get uptime() {\n        return Date.now() - this.#createdAt;\n    }\n\n    // \n    // Debug Logging\n    // \n\n    /**\n     * Logs a debug message if debug mode is enabled.\n     * @param {'in'|'out'|'info'|'warn'|'error'} type - Log type\n     * @param {string} message - Message to log\n     */\n    #log(type, message) {\n        if (!this.#debug) return;\n\n        const arrow = type === 'out' ? '' :\n            type === 'in' ? '' :\n                type === 'warn' ? '' :\n                    type === 'error' ? '' : '';\n\n        // eslint-disable-next-line no-console\n        console.log(`${this.#debugPrefix} ${arrow} ${message}`);\n    }\n\n    // \n    // Health Check\n    // \n\n    /**\n     * Returns the health status of the CrossBus instance.\n     * Useful for monitoring and diagnostics.\n     * \n     * @returns {Object} Health status object\n     * \n     * @example\n     * const health = bus.healthCheck();\n     * // {\n     * //   status: 'healthy',\n     * //   peerId: 'hub-1',\n     * //   uptime: 123456,\n     * //   peers: { total: 5, connected: 4 },\n     * //   handlers: ['getData', 'setData'],\n     * //   memory: { heapUsed: 12345678 }\n     * // }\n     */\n    healthCheck() {\n        const peerIds = this.#router.getPeerIds();\n        const connectedCount = peerIds.length;\n\n        // Determine status\n        let status = 'healthy';\n        if (this.#destroyed) {\n            status = 'unhealthy';\n        } else if (connectedCount === 0 && this.#isHub) {\n            status = 'degraded';\n        }\n\n        // Get memory usage if available\n        let memory;\n        if (typeof process !== 'undefined' && process.memoryUsage) {\n            try {\n                const mem = process.memoryUsage();\n                memory = {\n                    heapUsed: mem.heapUsed,\n                    heapTotal: mem.heapTotal,\n                    rss: mem.rss\n                };\n            } catch {\n                // Memory info not available\n            }\n        }\n\n        return {\n            status,\n            peerId: this.#peerId,\n            isHub: this.#isHub,\n            uptime: this.uptime,\n            peers: {\n                total: connectedCount,\n                ids: peerIds\n            },\n            handlers: Array.from(this.#handlers.keys()),\n            pendingRequests: this.#pendingRequests.size ?? 0,\n            destroyed: this.#destroyed,\n            ...(memory && { memory })\n        };\n    }\n\n    // \n    // Static Factory Methods\n    // \n\n    /**\n     * Creates a pre-configured secure CrossBus instance.\n     * Recommended for production use by AI agents.\n     * \n     * Enforces:\n     * - strictMode (no wildcard origins)\n     * - 1MB max payload size\n     * - 100 max pending requests\n     * - 30s request timeout\n     * \n     * @param {CrossBusOptions} options - Configuration options\n     * @returns {CrossBus} Configured instance\n     * @throws {Error} If allowedOrigins contains '*' or is missing\n     * \n     * @example\n     * // For production use\n     * const hub = CrossBus.createSecure({\n     *   peerId: 'my-hub',\n     *   isHub: true,\n     *   allowedOrigins: ['https://trusted-domain.com']\n     * });\n     */\n    static createSecure(options = {}) {\n        if (!options.allowedOrigins || options.allowedOrigins.length === 0) {\n            throw new Error(\n                'createSecure() requires allowedOrigins to be specified. ' +\n                'For development, use: new CrossBus({ allowedOrigins: [\"*\"] })'\n            );\n        }\n\n        if (options.allowedOrigins.includes('*')) {\n            throw new Error(\n                'createSecure() does not allow wildcard origins. ' +\n                'Specify exact origins: allowedOrigins: [\"https://example.com\"]'\n            );\n        }\n\n        return new CrossBus({\n            strictMode: true,\n            maxPayloadSize: 1024 * 1024,\n            maxPendingRequests: 100,\n            requestTimeout: 30000,\n            ...options\n        });\n    }\n\n    // \n    // Diagnostics (AI Agent Helper)\n    // \n\n    /**\n     * Performs diagnostics and returns troubleshooting suggestions.\n     * Designed to help AI agents identify and fix common issues.\n     * \n     * @returns {Object} Diagnostic report with issues and suggestions\n     * \n     * @example\n     * const report = bus.diagnose();\n     * if (report.issues.length > 0) {\n     *   console.log('Issues found:', report.issues);\n     *   console.log('Suggestions:', report.suggestions);\n     * }\n     */\n    diagnose() {\n        const issues = [];\n        const suggestions = [];\n        const warnings = [];\n\n        // Check if destroyed\n        if (this.#destroyed) {\n            issues.push('Instance is destroyed');\n            suggestions.push('Create a new CrossBus instance');\n            return { status: 'error', issues, suggestions, warnings };\n        }\n\n        // Check peer connections\n        const peerCount = this.#router.getPeerIds().length;\n        if (peerCount === 0) {\n            if (this.#isHub) {\n                warnings.push('Hub has no connected peers');\n                suggestions.push('Add transports with addTransport() or wait for agents to connect');\n            } else {\n                issues.push('Agent has no connected peers');\n                suggestions.push('Add a transport to connect to hub: bus.addTransport(transport, {peerId: \"hub\"})');\n            }\n        }\n\n        // Check handlers\n        const handlerCount = this.#handlers.size;\n        if (this.#isHub && handlerCount === 0) {\n            warnings.push('Hub has no registered handlers');\n            suggestions.push('Register handlers with bus.handle(\"name\", fn)');\n        }\n\n        // Check pending requests\n        const pendingCount = this.#pendingRequests.size ?? 0;\n        if (pendingCount > this.#maxPendingRequests * 0.8) {\n            warnings.push(`High pending request count: ${pendingCount}/${this.#maxPendingRequests}`);\n            suggestions.push('Consider increasing maxPendingRequests or check for slow handlers');\n        }\n\n        // Check strict mode in production hints\n        if (!this.#strictMode) {\n            warnings.push('strictMode is disabled');\n            suggestions.push('For production, use CrossBus.createSecure() or set strictMode: true');\n        }\n\n        // Determine overall status\n        let status = 'healthy';\n        if (issues.length > 0) {\n            status = 'error';\n        } else if (warnings.length > 0) {\n            status = 'warning';\n        }\n\n        return {\n            status,\n            peerId: this.#peerId,\n            isHub: this.#isHub,\n            peerCount,\n            handlerCount,\n            pendingRequests: pendingCount,\n            uptime: this.uptime,\n            issues,\n            warnings,\n            suggestions\n        };\n    }\n}\n","/**\n * @fileoverview Streaming support for CrossBus.\n * Enables efficient transfer of large payloads (files, LLM responses) via chunked messages.\n * @module core/stream\n */\n\nimport { PROTOCOL_MARKER, PROTOCOL_VERSION } from '../common/types.js';\nimport { uuid } from '../common/utils.js';\n\n/**\n * @typedef {Object} StreamOptions\n * @property {number} [chunkSize=64000] - Size of each chunk in bytes.\n * @property {number} [timeout=30000] - Timeout for stream operations in ms.\n */\n\n/**\n * @typedef {Object} StreamMeta\n * @property {string} streamId - Unique stream identifier.\n * @property {string} name - Stream name/type.\n * @property {number} [totalSize] - Total size if known.\n * @property {string} [contentType] - MIME type if applicable.\n * @property {Object} [meta] - Additional metadata.\n */\n\n/**\n * @typedef {'open' | 'data' | 'end' | 'error' | 'ack'} StreamMessageType\n */\n\n/**\n * Writable stream for sending large payloads in chunks.\n * \n * @example\n * const stream = new WritableSignalStream(sendFn, 'upload', {\n *   meta: { filename: 'data.json' }\n * });\n * \n * for await (const chunk of readFile(file)) {\n *   await stream.write(chunk);\n * }\n * await stream.end();\n */\nexport class WritableSignalStream {\n    /** @type {string} */\n    #streamId;\n\n    /** @type {string} */\n    #name;\n\n    /** @type {Function} */\n    #sendFn;\n\n    /** @type {number} */\n    #chunkSize;\n\n    /** @type {number} */\n    #seq = 0;\n\n    /** @type {boolean} */\n    #ended = false;\n\n    /** @type {boolean} */\n    #opened = false;\n\n    /** @type {Object} */\n    #meta;\n\n    /**\n     * Creates a new writable stream.\n     * \n     * @param {Function} sendFn - Function to send messages.\n     * @param {string} name - Stream name/type identifier.\n     * @param {StreamOptions & { meta?: Object }} [options={}] - Options.\n     */\n    constructor(sendFn, name, options = {}) {\n        this.#streamId = uuid();\n        this.#name = name;\n        this.#sendFn = sendFn;\n        this.#chunkSize = options.chunkSize ?? 64000;\n        this.#meta = options.meta ?? {};\n    }\n\n    /**\n     * Gets the stream ID.\n     * @returns {string}\n     */\n    get streamId() {\n        return this.#streamId;\n    }\n\n    /**\n     * Gets the stream name.\n     * @returns {string}\n     */\n    get name() {\n        return this.#name;\n    }\n\n    /**\n     * Opens the stream (called automatically on first write).\n     * \n     * @param {Object} [meta] - Additional metadata.\n     * @returns {Promise<void>}\n     */\n    async open(meta) {\n        if (this.#opened) return;\n\n        this.#opened = true;\n\n        await this.#send({\n            st: 'open',\n            name: this.#name,\n            meta: { ...this.#meta, ...meta }\n        });\n    }\n\n    /**\n     * Writes data to the stream.\n     * \n     * @param {string | ArrayBuffer | Uint8Array | Object} data - Data to write.\n     * @returns {Promise<void>}\n     */\n    async write(data) {\n        if (this.#ended) {\n            throw new Error('Stream already ended');\n        }\n\n        if (!this.#opened) {\n            await this.open();\n        }\n\n        // Convert data to sendable format\n        let payload;\n        let isBase64 = false;\n\n        if (data instanceof ArrayBuffer) {\n            payload = this.#arrayBufferToBase64(new Uint8Array(data));\n            isBase64 = true;\n        } else if (data instanceof Uint8Array) {\n            payload = this.#arrayBufferToBase64(data);\n            isBase64 = true;\n        } else if (typeof data === 'string') {\n            // String data - chunk if needed\n            const chunks = this.#chunkString(data, this.#chunkSize);\n            for (const chunk of chunks) {\n                await this.#send({\n                    st: 'data',\n                    seq: this.#seq++,\n                    d: chunk,\n                    b64: false\n                });\n            }\n            return;\n        } else {\n            // Object - serialize to JSON\n            payload = JSON.stringify(data);\n        }\n\n        // Send (chunk if binary)\n        if (isBase64) {\n            const chunks = this.#chunkString(payload, this.#chunkSize);\n            for (const chunk of chunks) {\n                await this.#send({\n                    st: 'data',\n                    seq: this.#seq++,\n                    d: chunk,\n                    b64: true\n                });\n            }\n        } else {\n            await this.#send({\n                st: 'data',\n                seq: this.#seq++,\n                d: payload,\n                b64: false\n            });\n        }\n    }\n\n    /**\n     * Ends the stream.\n     * \n     * @param {Object} [finalMeta] - Final metadata.\n     * @returns {Promise<void>}\n     */\n    async end(finalMeta) {\n        if (this.#ended) return;\n\n        this.#ended = true;\n\n        await this.#send({\n            st: 'end',\n            seq: this.#seq,\n            meta: finalMeta\n        });\n    }\n\n    /**\n     * Aborts the stream with an error.\n     * \n     * @param {string} [reason] - Error reason.\n     * @returns {Promise<void>}\n     */\n    async abort(reason) {\n        if (this.#ended) return;\n\n        this.#ended = true;\n\n        await this.#send({\n            st: 'error',\n            reason: reason ?? 'Stream aborted'\n        });\n    }\n\n    /**\n     * Sends a stream message.\n     * \n     * @param {Object} payload - Stream payload.\n     */\n    async #send(payload) {\n        const message = {\n            [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n            t: 'stream',\n            sid: this.#streamId,\n            ...payload\n        };\n\n        await this.#sendFn(message);\n    }\n\n    /**\n     * Chunks a string into smaller pieces.\n     * \n     * @param {string} str - String to chunk.\n     * @param {number} size - Chunk size.\n     * @returns {string[]}\n     */\n    #chunkString(str, size) {\n        const chunks = [];\n        for (let i = 0; i < str.length; i += size) {\n            chunks.push(str.slice(i, i + size));\n        }\n        return chunks;\n    }\n\n    /**\n     * Converts Uint8Array to base64.\n     * \n     * @param {Uint8Array} bytes \n     * @returns {string}\n     */\n    #arrayBufferToBase64(bytes) {\n        let binary = '';\n        for (let i = 0; i < bytes.length; i++) {\n            binary += String.fromCharCode(bytes[i]);\n        }\n        return btoa(binary);\n    }\n}\n\n/**\n * Readable stream for receiving large payloads.\n * \n * @example\n * streamManager.onStream('upload', async (stream) => {\n *   for await (const chunk of stream) {\n *     await processChunk(chunk);\n *   }\n * });\n */\nexport class ReadableSignalStream {\n    /** @type {string} */\n    #streamId;\n\n    /** @type {string} */\n    #name;\n\n    /** @type {Object} */\n    #meta;\n\n    /** @type {Array<any>} */\n    #buffer = [];\n\n    /** @type {Function|null} */\n    #resolveNext = null;\n\n    /** @type {boolean} */\n    #ended = false;\n\n    /** @type {Error|null} */\n    #error = null;\n\n    /** @type {number} */\n    // #expectedSeq = 0;\n\n    /**\n     * Creates a readable stream from open message.\n     * \n     * @param {string} streamId - Stream ID.\n     * @param {string} name - Stream name.\n     * @param {Object} [meta] - Stream metadata.\n     */\n    constructor(streamId, name, meta = {}) {\n        this.#streamId = streamId;\n        this.#name = name;\n        this.#meta = meta;\n    }\n\n    /**\n     * Gets the stream ID.\n     * @returns {string}\n     */\n    get streamId() {\n        return this.#streamId;\n    }\n\n    /**\n     * Gets the stream name.\n     * @returns {string}\n     */\n    get name() {\n        return this.#name;\n    }\n\n    /**\n     * Gets stream metadata.\n     * @returns {Object}\n     */\n    get meta() {\n        return this.#meta;\n    }\n\n    /**\n     * Gets whether stream has ended.\n     * @returns {boolean}\n     */\n    get ended() {\n        return this.#ended;\n    }\n\n    /**\n     * Pushes data chunk from message.\n     * \n     * @param {Object} message - Stream data message.\n     */\n    push(message) {\n        if (this.#ended) return;\n\n        // Decode data\n        let data = message.d;\n        if (message.b64) {\n            data = this.#base64ToUint8Array(data);\n        }\n\n        // Add to buffer\n        this.#buffer.push(data);\n\n        // Resolve waiting reader\n        if (this.#resolveNext) {\n            const resolve = this.#resolveNext;\n            this.#resolveNext = null;\n            resolve();\n        }\n    }\n\n    /**\n     * Marks stream as ended.\n     * \n     * @param {Object} [meta] - Final metadata.\n     */\n    end(meta) {\n        this.#ended = true;\n        if (meta) {\n            this.#meta = { ...this.#meta, ...meta };\n        }\n\n        // Resolve waiting reader\n        if (this.#resolveNext) {\n            const resolve = this.#resolveNext;\n            this.#resolveNext = null;\n            resolve();\n        }\n    }\n\n    /**\n     * Marks stream as errored.\n     * \n     * @param {string} reason - Error reason.\n     */\n    error(reason) {\n        this.#ended = true;\n        this.#error = new Error(reason);\n\n        if (this.#resolveNext) {\n            const resolve = this.#resolveNext;\n            this.#resolveNext = null;\n            resolve();\n        }\n    }\n\n    /**\n     * Async iterator for consuming stream.\n     * \n     * @returns {AsyncIterableIterator<any>}\n     */\n    async *[Symbol.asyncIterator]() {\n        while (true) {\n            // Return buffered data first\n            while (this.#buffer.length > 0) {\n                yield this.#buffer.shift();\n            }\n\n            // Check for end/error\n            if (this.#ended) {\n                if (this.#error) {\n                    throw this.#error;\n                }\n                return;\n            }\n\n            // Wait for more data\n            await new Promise(resolve => {\n                this.#resolveNext = resolve;\n            });\n        }\n    }\n\n    /**\n     * Collects all data into single result.\n     * \n     * @returns {Promise<Uint8Array | string>}\n     */\n    async collect() {\n        const chunks = [];\n        let isBinary = false;\n\n        for await (const chunk of this) {\n            chunks.push(chunk);\n            if (chunk instanceof Uint8Array) {\n                isBinary = true;\n            }\n        }\n\n        if (isBinary) {\n            // Combine binary chunks\n            const totalLength = chunks.reduce((acc, c) => acc + c.length, 0);\n            const result = new Uint8Array(totalLength);\n            let offset = 0;\n            for (const chunk of chunks) {\n                result.set(chunk, offset);\n                offset += chunk.length;\n            }\n            return result;\n        } else {\n            // Combine string chunks\n            return chunks.join('');\n        }\n    }\n\n    /**\n     * Decodes base64 to Uint8Array.\n     * \n     * @param {string} base64 \n     * @returns {Uint8Array}\n     */\n    #base64ToUint8Array(base64) {\n        const binary = atob(base64);\n        const bytes = new Uint8Array(binary.length);\n        for (let i = 0; i < binary.length; i++) {\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    }\n}\n\n/**\n * Stream manager for CrossBus.\n * Handles creating, sending, and receiving streams.\n * \n * @example\n * const streams = new StreamManager(bus);\n * \n * // Create and send stream\n * const stream = await streams.createStream('upload', 'peer-1', {\n *   meta: { filename: 'data.json' }\n * });\n * await stream.write(data);\n * await stream.end();\n * \n * // Receive streams\n * streams.onStream('upload', async (stream) => {\n *   const data = await stream.collect();\n * });\n */\nexport class StreamManager {\n    /** @type {Map<string, ReadableSignalStream>} */\n    #activeStreams = new Map();\n\n    /** @type {Map<string, Function>} */\n    #streamHandlers = new Map();\n\n    /** @type {Function} */\n    #sendFn;\n\n    /**\n     * Creates a StreamManager.\n     * \n     * @param {Function} sendFn - Function to send messages: (peerId, message) => Promise.\n     */\n    constructor(sendFn) {\n        this.#sendFn = sendFn;\n    }\n\n    /**\n     * Creates a writable stream to send to a peer.\n     * \n     * @param {string} name - Stream name/type.\n     * @param {string} peerId - Target peer ID.\n     * @param {StreamOptions & { meta?: Object }} [options] - Options.\n     * @returns {WritableSignalStream}\n     */\n    createStream(name, peerId, options = {}) {\n        const sendFn = async (message) => {\n            await this.#sendFn(peerId, message);\n        };\n\n        return new WritableSignalStream(sendFn, name, options);\n    }\n\n    /**\n     * Registers a handler for incoming streams.\n     * \n     * @param {string} name - Stream name to handle.\n     * @param {(stream: ReadableSignalStream) => Promise<void>} handler - Handler function.\n     * @returns {Function} Unregister function.\n     */\n    onStream(name, handler) {\n        this.#streamHandlers.set(name, handler);\n        return () => this.#streamHandlers.delete(name);\n    }\n\n    /**\n     * Handles incoming stream message.\n     * Call this from CrossBus message handler.\n     * \n     * @param {Object} message - Stream message.\n     * @param {string} peerId - Source peer ID.\n     */\n    handleMessage(message, peerId) {\n        if (message.t !== 'stream') return;\n\n        const streamId = message.sid;\n        const streamType = message.st;\n\n        switch (streamType) {\n            case 'open':\n                this.#handleOpen(streamId, message, peerId);\n                break;\n            case 'data':\n                this.#handleData(streamId, message);\n                break;\n            case 'end':\n                this.#handleEnd(streamId, message);\n                break;\n            case 'error':\n                this.#handleError(streamId, message);\n                break;\n        }\n    }\n\n    /**\n     * Handles stream open message.\n     */\n    #handleOpen(streamId, message, peerId) {\n        const handler = this.#streamHandlers.get(message.name);\n        if (!handler) {\n            console.warn(`[CrossBus] No handler for stream: ${message.name}`);\n            return;\n        }\n\n        const stream = new ReadableSignalStream(streamId, message.name, message.meta);\n        this.#activeStreams.set(streamId, stream);\n\n        // Call handler asynchronously\n        handler(stream).catch(err => {\n            console.error('[CrossBus] Stream handler error:', err);\n        });\n    }\n\n    /**\n     * Handles stream data message.\n     */\n    #handleData(streamId, message) {\n        const stream = this.#activeStreams.get(streamId);\n        if (!stream) return;\n\n        stream.push(message);\n    }\n\n    /**\n     * Handles stream end message.\n     */\n    #handleEnd(streamId, message) {\n        const stream = this.#activeStreams.get(streamId);\n        if (!stream) return;\n\n        stream.end(message.meta);\n        this.#activeStreams.delete(streamId);\n    }\n\n    /**\n     * Handles stream error message.\n     */\n    #handleError(streamId, message) {\n        const stream = this.#activeStreams.get(streamId);\n        if (!stream) return;\n\n        stream.error(message.reason);\n        this.#activeStreams.delete(streamId);\n    }\n\n    /**\n     * Gets count of active streams.\n     * @returns {number}\n     */\n    get activeStreamCount() {\n        return this.#activeStreams.size;\n    }\n}\n","/**\n * @fileoverview PostMessage transport for iframes, popups, and workers.\n * Handles message serialization, origin validation, and bidirectional communication.\n * @module transports/postmessage\n */\n\nimport {\n    PROTOCOL_MARKER,\n    PROTOCOL_VERSION,\n    isProtocolMessage,\n    findTransferables\n} from '../common/types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { getSerializer, detectPreferredContentType } from '../common/serialization.js';\n\n/**\n * @typedef {Window|Worker|ServiceWorker|MessagePort} PostMessageTarget\n * Target that supports postMessage API.\n */\n\n/**\n * @typedef {Object} PostMessageTransportOptions\n * @property {string} [targetOrigin='*'] - Expected origin for outgoing messages.\n * @property {string[]} [allowedOrigins=[]] - Allowed origins for incoming messages.\n *                                            Empty = same origin only.\n * @property {boolean} [autoTransfer=false] - Auto-detect and transfer transferable objects.\n * @property {string} [contentType='application/json'] - Serialization format.\n */\n\n/**\n * @typedef {Object} MessageSource\n * @property {string} origin - Origin of the message.\n * @property {PostMessageTarget} source - The window/worker that sent the message.\n */\n\n/**\n * @callback MessageHandler\n * @param {Object} message - The received protocol message.\n * @param {MessageSource} source - Info about the message source.\n */\n\n/**\n * PostMessage-based transport for cross-context communication.\n * \n * Supports:\n * - Window to Window (iframe, popup)\n * - Main thread to Worker\n * - Main thread to ServiceWorker\n * \n * @example\n * // Connect to iframe\n * const iframe = document.getElementById('widget');\n * const transport = new PostMessageTransport(iframe.contentWindow, {\n *   targetOrigin: 'https://widget.example.com',\n *   allowedOrigins: ['https://widget.example.com']\n * });\n * \n * transport.onMessage((msg, source) => {\n *   console.log('Received:', msg, 'from:', source.origin);\n * });\n * \n * transport.send({ type: 'greeting', payload: { hello: 'world' } });\n * \n * // Cleanup\n * transport.destroy();\n */\nexport class PostMessageTransport {\n    /** @type {PostMessageTarget|null} */\n    #target = null;\n\n    /** @type {string} */\n    #targetOrigin;\n\n    /** @type {Set<string>} */\n    #allowedOrigins;\n\n    /** @type {boolean} */\n    #autoTransfer;\n\n    /** @type {import('../common/serialization.js').Serializer} */\n    #serializer;\n\n    /** @type {string} */\n    #contentType;\n\n    /** @type {MessageHandler|null} */\n    #messageHandler = null;\n\n    /** @type {Function|null} */\n    #boundListener = null;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /**\n     * Checks if PostMessage API is available.\n     * \n     * @returns {boolean} True if postMessage is supported.\n     */\n    static isSupported() {\n        return typeof globalThis.postMessage === 'function' ||\n            typeof Window !== 'undefined';\n    }\n\n    /**\n     * Creates a new PostMessage transport.\n     * \n     * @param {PostMessageTarget} target - The window/worker to communicate with.\n     * @param {PostMessageTransportOptions} [options={}] - Configuration options.\n     * @throws {TypeError} If target is not a valid postMessage target.\n     */\n    constructor(target, options = {}) {\n        if (!this.#isValidTarget(target)) {\n            throw new TypeError('Target must support postMessage');\n        }\n\n        this.#target = target;\n        this.#targetOrigin = options.targetOrigin ?? '*';\n        this.#allowedOrigins = new Set(options.allowedOrigins ?? []);\n        this.#autoTransfer = options.autoTransfer ?? false;\n        this.#contentType = options.contentType ?? 'application/json';\n        this.#serializer = getSerializer(this.#contentType);\n\n        // Development security warning\n        const isDev = typeof process !== 'undefined'\n            ? process.env?.NODE_ENV !== 'production'\n            : typeof window !== 'undefined' && window.location?.hostname === 'localhost';\n\n        if (isDev && this.#targetOrigin === '*') {\n            console.warn(\n                '[CrossBus Security]  targetOrigin: \"*\" broadcasts to ANY window.\\n' +\n                'This is INSECURE in production. Use specific origin:\\n' +\n                '  targetOrigin: \"https://iframe-domain.com\"\\n' +\n                'Suppress this warning with NODE_ENV=production'\n            );\n        }\n\n        // Set up message listener\n        this.#boundListener = this.#handleMessage.bind(this);\n        this.#getListenerTarget().addEventListener('message', /** @type {EventListener} */(this.#boundListener));\n    }\n\n    /**\n     * Sends a message to the target.\n     * \n     * @param {Object} message - Protocol message to send.\n     * @param {Transferable[]} [transfer] - Transferable objects to pass.\n     * @throws {CrossBusError} If transport is destroyed or target is closed.\n     * \n     * @example\n     * // Simple send\n     * transport.send({ t: 'sig', id: '123', p: { data: 'value' } });\n     * \n     * // With transferable\n     * const buffer = new ArrayBuffer(1024);\n     * transport.send({ t: 'sig', id: '456', p: buffer }, [buffer]);\n     */\n    send(message, transfer) {\n        if (this.#destroyed) {\n            throw CrossBusError.from(ErrorCode.DESTROYED, {\n                context: 'PostMessageTransport.send'\n            });\n        }\n\n        // Check if window is closed\n        if (this.#isWindowClosed()) {\n            throw CrossBusError.from(ErrorCode.PEER_DISCONNECTED, {\n                reason: 'Target window is closed'\n            });\n        }\n\n        // Ensure message has protocol marker\n        const envelope = {\n            [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n            ...message\n        };\n\n        // Serialize if needed\n        // Note: PostMessage can handle objects natively. \n        // We only serialize if strictly requested (e.g. for consistency or size optimization)\n        // OR if the serializer is NOT JSON.\n        let dataToSend = envelope;\n        if (this.#contentType !== 'application/json') {\n            dataToSend = this.#serializer.serialize(envelope);\n        }\n\n        // Auto-detect transferables if enabled\n        let transferables = transfer;\n        if (this.#autoTransfer && !transfer) {\n            transferables = findTransferables(message);\n            if (transferables.length === 0) {\n                transferables = undefined;\n            }\n        }\n\n        // Send based on target type\n        if (this.#isWorker()) {\n            // Workers don't need origin\n            /** @type {Worker} */(this.#target).postMessage(dataToSend, /** @type {any} */(transferables));\n        } else {\n            // Windows need origin\n            /** @type {Window} */(this.#target).postMessage(envelope, this.#targetOrigin, transferables);\n        }\n    }\n\n    /**\n     * Registers a message handler.\n     * Only one handler can be registered; subsequent calls replace previous.\n     * \n     * @param {MessageHandler} handler - Function to handle incoming messages.\n     * \n     * @example\n     * transport.onMessage((msg, source) => {\n     *   if (msg.t === 'req') {\n     *     // Handle request\n     *   }\n     * });\n     */\n    onMessage(handler) {\n        if (typeof handler !== 'function') {\n            throw new TypeError('Handler must be a function');\n        }\n        this.#messageHandler = handler;\n    }\n\n    /**\n     * Removes the message handler.\n     */\n    offMessage() {\n        this.#messageHandler = null;\n    }\n\n    /**\n     * Destroys the transport, removing all listeners.\n     * After destruction, send() will throw.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n        this.#messageHandler = null;\n\n        if (this.#boundListener) {\n            this.#getListenerTarget().removeEventListener('message', /** @type {EventListener} */(this.#boundListener));\n            this.#boundListener = null;\n        }\n    }\n\n    /**\n     * Checks if transport has been destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n\n    /**\n     * Gets the target origin.\n     * @returns {string}\n     */\n    get targetOrigin() {\n        return this.#targetOrigin;\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Handles incoming message events.\n     * \n     * @param {MessageEvent} event\n     */\n    #handleMessage(event) {\n        // Skip if no handler\n        if (!this.#messageHandler) return;\n\n        // Get message data\n        let data = event.data;\n\n        // Skip non-protocol messages\n        if (!isProtocolMessage(data)) return;\n\n        // Validate origin (skip for workers which don't have origin)\n        if (event.origin && !this.#isOriginAllowed(event.origin)) {\n            console.warn(`[CrossBus] Blocked message from unauthorized origin: ${event.origin}`);\n            return;\n        }\n\n        // Validate source matches target (if target is a Window/MessagePort)\n        // We can't strictly validate for Workers as event.source might be null or different in some contexts\n        if (this.#target && 'postMessage' in this.#target && !this.#isWorker()) {\n            if (event.source !== this.#target) return;\n        }\n\n        // Invoke handler\n        try {\n            this.#messageHandler(data, {\n                origin: event.origin ?? 'worker',\n                source: /** @type {PostMessageTarget} */(/** @type {any} */(event.source ?? event.currentTarget))\n            });\n        } catch (error) {\n            console.error('[CrossBus] Message handler error:', error);\n        }\n    }\n\n    /**\n     * Checks if an origin is allowed.\n     * \n     * @param {string} origin\n     * @returns {boolean}\n     */\n    #isOriginAllowed(origin) {\n        // If no origins specified, only allow same origin\n        if (this.#allowedOrigins.size === 0) {\n            return origin === globalThis.location?.origin;\n        }\n\n        // Check for wildcard\n        if (this.#allowedOrigins.has('*')) {\n            return true;\n        }\n\n        // Check exact match\n        if (this.#allowedOrigins.has(origin)) {\n            return true;\n        }\n\n        // Check wildcard pattern (e.g., https://*.example.com)\n        for (const pattern of this.#allowedOrigins) {\n            if (pattern.includes('*')) {\n                // Use bounded quantifier to prevent ReDoS\n                const regex = new RegExp('^' + pattern\n                    .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')\n                    .replace(/\\\\\\*/g, '[a-zA-Z0-9.-]{0,253}') + '$');\n                if (regex.test(origin)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if target is a valid postMessage target.\n     * \n     * @param {*} target\n     * @returns {boolean}\n     */\n    #isValidTarget(target) {\n        if (!target) return false;\n        return typeof target.postMessage === 'function';\n    }\n\n    /**\n     * Checks if target is a Worker or ServiceWorker.\n     * \n     * @returns {boolean}\n     */\n    #isWorker() {\n        if (typeof Worker !== 'undefined' && this.#target instanceof Worker) {\n            return true;\n        }\n        if (typeof ServiceWorker !== 'undefined' && this.#target instanceof ServiceWorker) {\n            return true;\n        }\n        if (typeof MessagePort !== 'undefined' && this.#target instanceof MessagePort) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the target window is closed.\n     * \n     * @returns {boolean}\n     */\n    #isWindowClosed() {\n        if (this.#isWorker()) return false;\n        return /** @type {Window} */(this.#target).closed === true;\n    }\n\n    /**\n     * Gets the object to attach message listener to.\n     * For workers, we listen on the worker itself.\n     * For windows, we listen on the current window.\n     * \n     * @returns {EventTarget}\n     */\n    #getListenerTarget() {\n        // If inside worker, listen on self\n        if (typeof DedicatedWorkerGlobalScope !== 'undefined' &&\n            globalThis instanceof DedicatedWorkerGlobalScope) {\n            return globalThis;\n        }\n\n        // Main thread listening to worker - listen on worker\n        if (this.#isWorker()) {\n            return /** @type {EventTarget} */(/** @type {any} */(this.#target));\n        }\n\n        // Window communication - listen on current window\n        if (typeof window !== 'undefined') {\n            return window;\n        }\n\n        return globalThis;\n    }\n}\n","/**\n * @fileoverview BroadcastChannel transport for same-origin tab communication.\n * Uses the BroadcastChannel API for efficient pub/sub across browser contexts.\n * @module transports/broadcast-channel\n */\n\nimport {\n    PROTOCOL_MARKER,\n    PROTOCOL_VERSION,\n    isProtocolMessage\n} from '../common/types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { getSerializer, JSONSerializer } from '../common/serialization.js';\n\n/**\n * @typedef {Object} BroadcastChannelTransportOptions\n * @property {string} [channelName='crossbus:default'] - Name of the broadcast channel.\n * @property {string} [contentType='application/json'] - Serialization format.\n */\n\n/**\n * @typedef {Object} MessageContext\n * @property {string} origin - Always 'broadcast' for this transport.\n */\n\n/**\n * @callback MessageHandler\n * @param {Object} message - The received protocol message.\n * @param {MessageContext} context - Context information.\n */\n\n/**\n * BroadcastChannel-based transport for same-origin communication.\n * \n * Perfect for:\n * - Multiple tabs of the same app\n * - Communication without opening connections\n * - Pub/sub pattern across contexts\n * \n * Limitations:\n * - Same-origin only (no cross-origin)\n * - No guaranteed delivery order\n * - No acknowledgments (fire-and-forget)\n * \n * @example\n * // Create transport\n * const transport = new BroadcastChannelTransport({\n *   channelName: 'myapp:events'\n * });\n * \n * // Listen for messages\n * transport.onMessage((msg, ctx) => {\n *   console.log('Received:', msg);\n * });\n * \n * // Send message (to all other tabs)\n * transport.send({ type: 'notification', payload: { text: 'Hello!' } });\n * \n * // Cleanup\n * transport.destroy();\n */\nexport class BroadcastChannelTransport {\n    /** @type {BroadcastChannel} */\n    #channel;\n\n    /** @type {string} */\n    #channelName;\n\n    /** @type {import('../common/serialization.js').Serializer} */\n    #serializer;\n\n    /** @type {string} */\n    #contentType;\n\n    /** @type {MessageHandler|null} */\n    #messageHandler = null;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /**\n     * Checks if BroadcastChannel API is available.\n     * \n     * @returns {boolean} True if BroadcastChannel is supported.\n     */\n    static isSupported() {\n        return typeof BroadcastChannel !== 'undefined';\n    }\n\n    /**\n     * Creates a new BroadcastChannel transport.\n     * \n     * @param {BroadcastChannelTransportOptions} [options={}] - Configuration.\n     * @throws {CrossBusError} If BroadcastChannel is not supported.\n     */\n    constructor(options = {}) {\n        if (!BroadcastChannelTransport.isSupported()) {\n            throw CrossBusError.from(ErrorCode.UNSUPPORTED, {\n                api: 'BroadcastChannel'\n            });\n        }\n\n        this.#channelName = options.channelName ?? 'crossbus:default';\n        this.#channel = new BroadcastChannel(this.#channelName);\n        this.#contentType = options.contentType ?? 'application/json';\n        this.#serializer = getSerializer(this.#contentType);\n\n        // Set up message handler\n        this.#channel.onmessage = this.#handleMessage.bind(this);\n        this.#channel.onmessageerror = this.#handleError.bind(this);\n    }\n\n    /**\n     * Sends a message to all other tabs/windows.\n     * \n     * @param {Object} message - Protocol message to send.\n     * @throws {CrossBusError} If transport is destroyed.\n     * \n     * @example\n     * transport.send({\n     *   t: 'broadcast',\n     *   id: 'abc123',\n     *   p: { event: 'user:login' }\n     * });\n     */\n    send(message) {\n        if (this.#destroyed) {\n            throw CrossBusError.from(ErrorCode.DESTROYED, {\n                context: 'BroadcastChannelTransport.send'\n            });\n        }\n\n        // Ensure message has protocol marker\n        const envelope = {\n            [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n            ...message\n        };\n\n        let dataToSend = envelope;\n        if (this.#contentType !== 'application/json') {\n            dataToSend = this.#serializer.serialize(envelope);\n        }\n\n        this.#channel.postMessage(dataToSend);\n    }\n\n    /**\n     * Registers a message handler.\n     * Only one handler can be registered; subsequent calls replace previous.\n     * \n     * @param {MessageHandler} handler - Function to handle incoming messages.\n     */\n    onMessage(handler) {\n        if (typeof handler !== 'function') {\n            throw new TypeError('Handler must be a function');\n        }\n        this.#messageHandler = handler;\n    }\n\n    /**\n     * Removes the message handler.\n     */\n    offMessage() {\n        this.#messageHandler = null;\n    }\n\n    /**\n     * Destroys the transport, closing the channel.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n        this.#messageHandler = null;\n\n        if (this.#channel) {\n            this.#channel.close();\n            this.#channel = /** @type {any} */(null);\n        }\n    }\n\n    /**\n     * Gets the channel name.\n     * @returns {string}\n     */\n    get channelName() {\n        return this.#channelName;\n    }\n\n    /**\n     * Checks if transport has been destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Handles incoming message events.\n     * \n     * @param {MessageEvent} event\n     */\n    #handleMessage(event) {\n        // Skip if no handler\n        if (!this.#messageHandler) return;\n\n        // Deserialize if binary (convert to string first)\n        let data = event.data;\n        if (data instanceof ArrayBuffer || data instanceof Uint8Array) {\n            try {\n                const text = new TextDecoder().decode(data instanceof ArrayBuffer ? new Uint8Array(data) : data);\n                data = JSONSerializer.deserialize(text);\n            } catch (e) {\n                console.warn('[CrossBus] Failed to deserialize binary message', e);\n                return;\n            }\n        }\n\n        // Skip non-protocol messages\n        if (!isProtocolMessage(data)) return;\n\n        // Invoke handler\n        try {\n            this.#messageHandler(data, {\n                origin: 'broadcast'\n            });\n        } catch (error) {\n            console.error('[CrossBus] BroadcastChannel handler error:', error);\n        }\n    }\n\n    /**\n     * Handles message errors (e.g., deserialization failures).\n     * \n     * @param {MessageEvent} event\n     */\n    #handleError(event) {\n        console.error('[CrossBus] BroadcastChannel message error:', event);\n    }\n}\n","/**\n * @fileoverview MessageChannel transport for direct 1:1 peer communication.\n * Uses the MessageChannel API for efficient, low-latency communication.\n * @module transports/message-channel\n */\n\nimport {\n    PROTOCOL_MARKER,\n    PROTOCOL_VERSION,\n    isProtocolMessage,\n    findTransferables\n} from '../common/types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\nimport { getSerializer } from '../common/serialization.js';\n\n/**\n * @typedef {Object} MessageChannelTransportOptions\n * @property {boolean} [autoTransfer=false] - Auto-detect and transfer transferable objects.\n * @property {string} [contentType='application/json'] - Serialization format.\n */\n\n/**\n * @typedef {Object} ChannelPair\n * @property {MessagePort} local - Local port (we listen on this).\n * @property {MessagePort} remote - Remote port (send this to other context).\n */\n\n/**\n * @typedef {Object} MessageContext\n * @property {string} origin - Always 'channel' for this transport.\n */\n\n/**\n * @callback MessageHandler\n * @param {Object} message - The received protocol message.\n * @param {MessageContext} context - Context information.\n */\n\n/**\n * MessageChannel-based transport for direct peer-to-peer communication.\n * \n * This transport creates a direct communication channel that bypasses\n * the hub routing, providing lower latency for high-frequency peer pairs.\n * \n * Use cases:\n * - Direct iframe  worker communication\n * - High-frequency data streams\n * - Bypassing hub for performance\n * \n * @example\n * // On hub side: create channel and send to peer\n * const transport = new MessageChannelTransport();\n * iframe.contentWindow.postMessage(\n *   { type: 'channel', port: transport.remotePort },\n *   '*',\n *   [transport.remotePort]\n * );\n * \n * // On peer side: wrap received port\n * window.addEventListener('message', (e) => {\n *   if (e.data.type === 'channel') {\n *     const transport = MessageChannelTransport.fromPort(e.data.port);\n *     transport.onMessage((msg) => console.log('Received:', msg));\n *   }\n * });\n */\nexport class MessageChannelTransport {\n    /** @type {MessagePort} */\n    #localPort;\n\n    /** @type {MessagePort|null} */\n    #remotePort;\n\n    /** @type {boolean} */\n    #autoTransfer;\n\n    /** @type {import('../common/serialization.js').Serializer} */\n    #serializer;\n\n    /** @type {string} */\n    #contentType;\n\n    /** @type {MessageHandler|null} */\n    #messageHandler = null;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /** @type {boolean} */\n    #isInitiator;\n\n    /**\n     * Checks if MessageChannel API is available.\n     * \n     * @returns {boolean} True if MessageChannel is supported.\n     */\n    static isSupported() {\n        return typeof MessageChannel !== 'undefined';\n    }\n\n    /**\n     * Creates a MessageChannelTransport from an existing port.\n     * Use this when receiving a port from another context.\n     * \n     * @param {MessagePort} port - The received port.\n     * @param {MessageChannelTransportOptions} [options={}] - Configuration.\n     * @returns {MessageChannelTransport}\n     */\n    static fromPort(port, options = {}) {\n        if (!(port instanceof MessagePort)) {\n            throw new TypeError('Port must be a MessagePort');\n        }\n\n        const transport = Object.create(MessageChannelTransport.prototype);\n        transport.#localPort = port;\n        transport.#remotePort = null; // Not available when wrapping existing port\n        transport.#autoTransfer = options.autoTransfer ?? false;\n        transport.#contentType = options.contentType ?? 'application/json';\n        transport.#serializer = getSerializer(transport.#contentType);\n        transport.#destroyed = false;\n        transport.#isInitiator = false;\n        transport.#messageHandler = null;\n\n        // Set up message handler\n        transport.#localPort.onmessage = transport.#handleMessage.bind(transport);\n        transport.#localPort.onmessageerror = transport.#handleError.bind(transport);\n\n        return transport;\n    }\n\n    /**\n     * Creates a new MessageChannel transport (as initiator).\n     * The remote port should be sent to the other context via postMessage.\n     * \n     * @param {MessageChannelTransportOptions} [options={}] - Configuration.\n     * @throws {CrossBusError} If MessageChannel is not supported.\n     */\n    constructor(options = {}) {\n        if (!MessageChannelTransport.isSupported()) {\n            throw CrossBusError.from(ErrorCode.UNSUPPORTED, {\n                api: 'MessageChannel'\n            });\n        }\n\n        const channel = new MessageChannel();\n        this.#localPort = channel.port1;\n        this.#remotePort = channel.port2;\n        this.#autoTransfer = options.autoTransfer ?? false;\n        this.#contentType = options.contentType ?? 'application/json';\n        this.#serializer = getSerializer(this.#contentType);\n        this.#isInitiator = true;\n\n        // Set up message handler\n        this.#localPort.onmessage = this.#handleMessage.bind(this);\n        this.#localPort.onmessageerror = this.#handleError.bind(this);\n    }\n\n    /**\n     * Gets the remote port to send to the other context.\n     * This port can only be accessed once and becomes null after transfer.\n     * \n     * @returns {MessagePort|null} The remote port, or null if already transferred.\n     */\n    get remotePort() {\n        return this.#remotePort;\n    }\n\n    /**\n     * Marks the remote port as transferred (called automatically when used).\n     */\n    markRemoteTransferred() {\n        this.#remotePort = null;\n    }\n\n    /**\n     * Checks if this transport was created as the channel initiator.\n     * @returns {boolean}\n     */\n    get isInitiator() {\n        return this.#isInitiator;\n    }\n\n    /**\n     * Sends a message to the connected peer.\n     * \n     * @param {Object} message - Protocol message to send.\n     * @param {Transferable[]} [transfer] - Transferable objects to pass.\n     * @throws {CrossBusError} If transport is destroyed.\n     */\n    send(message, transfer) {\n        if (this.#destroyed) {\n            throw CrossBusError.from(ErrorCode.DESTROYED, {\n                context: 'MessageChannelTransport.send'\n            });\n        }\n\n        // Ensure message has protocol marker\n        const envelope = {\n            [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n            ...message\n        };\n\n        let dataToSend = envelope;\n        if (this.#contentType !== 'application/json') {\n            dataToSend = this.#serializer.serialize(envelope);\n        }\n\n        // Auto-detect transferables if enabled\n        let transferables = transfer;\n        if (this.#autoTransfer && !transfer) {\n            transferables = findTransferables(message);\n            if (transferables.length === 0) {\n                transferables = undefined;\n            }\n        }\n\n        this.#localPort.postMessage(dataToSend, /** @type {any} */(transferables));\n    }\n\n    /**\n     * Registers a message handler.\n     * Only one handler can be registered; subsequent calls replace previous.\n     * \n     * @param {MessageHandler} handler - Function to handle incoming messages.\n     */\n    onMessage(handler) {\n        if (typeof handler !== 'function') {\n            throw new TypeError('Handler must be a function');\n        }\n        this.#messageHandler = handler;\n    }\n\n    /**\n     * Removes the message handler.\n     */\n    offMessage() {\n        this.#messageHandler = null;\n    }\n\n    /**\n     * Destroys the transport, closing ports.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n        this.#messageHandler = null;\n\n        if (this.#localPort) {\n            this.#localPort.close();\n            this.#localPort = /** @type {any} */(null);\n        }\n\n        if (this.#remotePort) {\n            this.#remotePort.close();\n            this.#remotePort = null;\n        }\n    }\n\n    /**\n     * Checks if transport has been destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Handles incoming message events.\n     * \n     * @param {MessageEvent} event\n     */\n    #handleMessage(event) {\n        // Skip if no handler\n        if (!this.#messageHandler) return;\n\n        // Get message data\n        let data = event.data;\n\n        // Skip non-protocol messages\n        if (!isProtocolMessage(data)) return;\n\n        // Invoke handler\n        try {\n            this.#messageHandler(data, {\n                origin: 'channel'\n            });\n        } catch (error) {\n            console.error('[CrossBus] MessageChannel handler error:', error);\n        }\n    }\n\n    /**\n     * Handles message errors.\n     * \n     * @param {MessageEvent} event\n     */\n    #handleError(event) {\n        console.error('[CrossBus] MessageChannel error:', event);\n    }\n}\n","/**\n * @fileoverview SharedWorker transport for tab communication via shared state.\n * Uses SharedWorker API for efficient cross-tab communication with shared context.\n * @module transports/shared-worker\n */\n\nimport {\n    PROTOCOL_MARKER,\n    PROTOCOL_VERSION,\n    isProtocolMessage\n} from '../common/types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\n\n/**\n * @typedef {Object} SharedWorkerTransportOptions\n * @property {string} [workerUrl] - URL to the SharedWorker script.\n * @property {string} [name] - Optional name for the SharedWorker.\n */\n\n/**\n * @typedef {Object} MessageContext\n * @property {string} origin - Always 'sharedworker' for this transport.\n */\n\n/**\n * @callback MessageHandler\n * @param {Object} message - The received protocol message.\n * @param {MessageContext} context - Context information.\n */\n\n/**\n * SharedWorker-based transport for tab communication.\n * \n * SharedWorkers persist across page refreshes and are shared between\n * all tabs/windows of the same origin. This enables:\n * - Shared state across tabs\n * - Single connection to backend (via worker)\n * - Efficient broadcast to all tabs\n * \n * @example\n * // Create transport\n * const transport = new SharedWorkerTransport({\n *   workerUrl: '/crossbus-worker.js'\n * });\n * \n * // Listen for messages\n * transport.onMessage((msg, ctx) => {\n *   console.log('Received:', msg);\n * });\n * \n * // Send message (goes through shared worker to all tabs)\n * transport.send({ t: 'sig', p: { event: 'user:action' } });\n * \n * // Cleanup\n * transport.destroy();\n */\nexport class SharedWorkerTransport {\n    /** @type {SharedWorker|null} */\n    #worker = null;\n\n    /** @type {MessagePort|null} */\n    #port = null;\n\n    /** @type {string} */\n    #workerUrl;\n\n    /** @type {MessageHandler|null} */\n    #messageHandler = null;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /**\n     * Checks if SharedWorker API is available.\n     * \n     * @returns {boolean} True if SharedWorker is supported.\n     */\n    static isSupported() {\n        return typeof SharedWorker !== 'undefined';\n    }\n\n    /**\n     * Creates a new SharedWorker transport.\n     * \n     * @param {SharedWorkerTransportOptions} [options={}] - Configuration.\n     * @throws {CrossBusError} If SharedWorker is not supported.\n     */\n    constructor(options = {}) {\n        if (!SharedWorkerTransport.isSupported()) {\n            throw CrossBusError.from(ErrorCode.UNSUPPORTED, {\n                api: 'SharedWorker'\n            });\n        }\n\n        this.#workerUrl = options.workerUrl ?? '/crossbus-shared-worker.js';\n\n        // Create SharedWorker\n        this.#worker = new SharedWorker(this.#workerUrl, options.name);\n        this.#port = this.#worker.port;\n\n        // Set up message handler on port\n        this.#port.onmessage = this.#handleMessage.bind(this);\n        this.#port.onmessageerror = this.#handleError.bind(this);\n\n        // Handle worker errors\n        this.#worker.onerror = this.#handleWorkerError.bind(this);\n\n        // Start the port (required for SharedWorker)\n        this.#port.start();\n    }\n\n    /**\n     * Sends a message through the SharedWorker.\n     * \n     * @param {Object} message - Protocol message to send.\n     * @param {Transferable[]} [transfer] - Transferable objects.\n     * @throws {CrossBusError} If transport is destroyed.\n     */\n    send(message, transfer) {\n        if (this.#destroyed) {\n            throw CrossBusError.from(ErrorCode.DESTROYED, {\n                context: 'SharedWorkerTransport.send'\n            });\n        }\n\n        // Ensure message has protocol marker\n        const envelope = {\n            [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n            ...message\n        };\n\n        if (!this.#port) return;\n\n        if (transfer && transfer.length > 0) {\n            this.#port.postMessage(envelope, transfer);\n        } else {\n            this.#port.postMessage(envelope);\n        }\n    }\n\n    /**\n     * Registers a message handler.\n     * Only one handler can be registered; subsequent calls replace previous.\n     * \n     * @param {MessageHandler} handler - Function to handle incoming messages.\n     */\n    onMessage(handler) {\n        if (typeof handler !== 'function') {\n            throw new TypeError('Handler must be a function');\n        }\n        this.#messageHandler = handler;\n    }\n\n    /**\n     * Removes the message handler.\n     */\n    offMessage() {\n        this.#messageHandler = null;\n    }\n\n    /**\n     * Destroys the transport, closing the port.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n        this.#messageHandler = null;\n\n        if (this.#port) {\n            this.#port.close();\n            this.#port = null;\n        }\n\n        this.#worker = null;\n    }\n\n    /**\n     * Gets the worker URL.\n     * @returns {string}\n     */\n    get workerUrl() {\n        return this.#workerUrl;\n    }\n\n    /**\n     * Checks if transport has been destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Handles incoming messages from the SharedWorker.\n     * \n     * @param {MessageEvent} event\n     */\n    #handleMessage(event) {\n        // Skip if no handler\n        if (!this.#messageHandler) return;\n\n        // Skip non-protocol messages\n        if (!isProtocolMessage(event.data)) return;\n\n        // Invoke handler\n        try {\n            this.#messageHandler(event.data, {\n                origin: 'sharedworker'\n            });\n        } catch (error) {\n            console.error('[CrossBus] SharedWorker handler error:', error);\n        }\n    }\n\n    /**\n     * Handles message errors.\n     * \n     * @param {MessageEvent} event\n     */\n    #handleError(event) {\n        console.error('[CrossBus] SharedWorker message error:', event);\n    }\n\n    /**\n     * Handles worker-level errors.\n     * \n     * @param {ErrorEvent} event\n     */\n    #handleWorkerError(event) {\n        console.error('[CrossBus] SharedWorker error:', event.message);\n    }\n}\n","/**\n * @fileoverview ServiceWorker transport for offline-capable communication.\n * Uses ServiceWorker API for background sync and offline messaging.\n * @module transports/service-worker\n */\n\nimport {\n    PROTOCOL_MARKER,\n    PROTOCOL_VERSION,\n    isProtocolMessage\n} from '../common/types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\n\n/**\n * @typedef {Object} ServiceWorkerTransportOptions\n * @property {number} [timeout=5000] - Timeout waiting for ready state.\n */\n\n/**\n * @typedef {Object} MessageContext\n * @property {string} origin - Always 'serviceworker' for this transport.\n */\n\n/**\n * @callback MessageHandler\n * @param {Object} message - The received protocol message.\n * @param {MessageContext} context - Context information.\n */\n\n/**\n * ServiceWorker-based transport for offline-capable communication.\n * \n * ServiceWorkers run in the background and can:\n * - Handle messages even when page is not focused\n * - Queue messages for offline delivery\n * - Sync state across all tabs\n * \n * @example\n * const transport = new ServiceWorkerTransport();\n * \n * // Wait for ServiceWorker to be ready\n * await transport.ready;\n * \n * // Listen for messages\n * transport.onMessage((msg, ctx) => {\n *   console.log('Received from SW:', msg);\n * });\n * \n * // Send message to ServiceWorker\n * transport.send({ t: 'sig', id: 'abc', p: { event: 'sync' } });\n * \n * // Cleanup\n * transport.destroy();\n */\nexport class ServiceWorkerTransport {\n    /** @type {ServiceWorker|null} */\n    #controller = null;\n\n    /** @type {MessageHandler|null} */\n    #messageHandler = null;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /** @type {Promise<void>} */\n    #readyPromise;\n\n    /** @type {Function|null} */\n    #boundMessageHandler = null;\n\n    /**\n     * Checks if ServiceWorker API is available.\n     * \n     * @returns {boolean} True if ServiceWorker is supported.\n     */\n    static isSupported() {\n        return typeof navigator !== 'undefined' &&\n            'serviceWorker' in navigator;\n    }\n\n    /**\n     * Creates a new ServiceWorker transport.\n     * \n     * @param {ServiceWorkerTransportOptions} [options={}] - Configuration.\n     * @throws {CrossBusError} If ServiceWorker is not supported.\n     */\n    constructor(options = {}) {\n        if (!ServiceWorkerTransport.isSupported()) {\n            throw CrossBusError.from(ErrorCode.UNSUPPORTED, {\n                api: 'ServiceWorker'\n            });\n        }\n\n        // Initialize ready promise\n        this.#readyPromise = this.#initialize();\n    }\n\n    /**\n     * Promise that resolves when transport is ready.\n     * @returns {Promise<void>}\n     */\n    get ready() {\n        return this.#readyPromise;\n    }\n\n    /**\n     * Initializes the ServiceWorker connection.\n     * \n     */\n    async #initialize() {\n        // Wait for ServiceWorker to be ready\n        const registration = await navigator.serviceWorker.ready;\n\n        this.#controller = registration.active || navigator.serviceWorker.controller;\n\n        // Set up message handler\n        this.#boundMessageHandler = this.#handleMessage.bind(this);\n        navigator.serviceWorker.addEventListener('message', /** @type {EventListener} */(this.#boundMessageHandler));\n    }\n\n    /**\n     * Sends a message to the ServiceWorker.\n     * \n     * @param {Object} message - Protocol message to send.\n     * @param {Transferable[]} [transfer] - Transferable objects.\n     * @throws {CrossBusError} If transport is destroyed or no controller.\n     */\n    send(message, transfer) {\n        if (this.#destroyed) {\n            throw CrossBusError.from(ErrorCode.DESTROYED, {\n                context: 'ServiceWorkerTransport.send'\n            });\n        }\n\n        if (!this.#controller) {\n            throw CrossBusError.from(ErrorCode.NOT_CONNECTED, {\n                context: 'ServiceWorkerTransport.send',\n                reason: 'No active ServiceWorker'\n            });\n        }\n\n        // Ensure message has protocol marker\n        const envelope = {\n            [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n            ...message\n        };\n\n        if (transfer && transfer.length > 0) {\n            this.#controller.postMessage(envelope, transfer);\n        } else {\n            this.#controller.postMessage(envelope);\n        }\n    }\n\n    /**\n     * Registers a message handler.\n     * \n     * @param {MessageHandler} handler - Function to handle incoming messages.\n     */\n    onMessage(handler) {\n        if (typeof handler !== 'function') {\n            throw new TypeError('Handler must be a function');\n        }\n        this.#messageHandler = handler;\n    }\n\n    /**\n     * Removes the message handler.\n     */\n    offMessage() {\n        this.#messageHandler = null;\n    }\n\n    /**\n     * Destroys the transport.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n        this.#messageHandler = null;\n\n        if (this.#boundMessageHandler) {\n            navigator.serviceWorker.removeEventListener('message', /** @type {EventListener} */(this.#boundMessageHandler));\n            this.#boundMessageHandler = null;\n        }\n\n        this.#controller = null;\n    }\n\n    /**\n     * Checks if transport has been destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n\n    // \n    // Private methods\n    // \n\n    /**\n     * Handles incoming messages from the ServiceWorker.\n     * \n     * @param {MessageEvent} event\n     */\n    #handleMessage(event) {\n        // Skip if no handler\n        if (!this.#messageHandler) return;\n\n        // Skip non-protocol messages\n        if (!isProtocolMessage(event.data)) return;\n\n        // Invoke handler\n        try {\n            this.#messageHandler(event.data, {\n                origin: 'serviceworker'\n            });\n        } catch (error) {\n            console.error('[CrossBus] ServiceWorker handler error:', error);\n        }\n    }\n}\n","/**\n * @fileoverview Native Bridge transport for Android/iOS WebView communication.\n * Enables CrossBus to communicate with native mobile apps through WebView bridges.\n * @module transports/native-bridge\n */\n\nimport {\n    PROTOCOL_MARKER,\n    PROTOCOL_VERSION,\n    isProtocolMessage\n} from '../common/types.js';\nimport { CrossBusError, ErrorCode } from '../common/errors.js';\n\n/**\n * @typedef {'android' | 'ios' | 'none'} BridgeType\n */\n\n/**\n * @typedef {Object} NativeBridgeTransportOptions\n * @property {string} [androidInterface='CrossBus'] - Name of Android JavascriptInterface.\n * @property {string} [iosHandler='crossbus'] - Name of iOS WKScriptMessageHandler.\n * @property {number} [initTimeout=5000] - Timeout waiting for native bridge (ms).\n * @property {number} [heartbeatInterval=30000] - Heartbeat interval (ms), 0 to disable.\n * @property {boolean} [queueWhileInit=true] - Queue messages while waiting for bridge.\n */\n\n/**\n * @callback MessageHandler\n * @param {Object} message - The received protocol message.\n * @param {{ bridgeType: BridgeType }} source - Bridge type info.\n */\n\n/**\n * Native Bridge transport for WebView  Native communication.\n * \n * Supports:\n * - Android WebView via JavascriptInterface\n * - iOS WKWebView via WKScriptMessageHandler\n * \n * @example\n * // In WebView context\n * const transport = new NativeBridgeTransport();\n * \n * transport.onMessage((msg, source) => {\n *   console.log('From native:', msg, 'via:', source.bridgeType);\n * });\n * \n * // Send to native\n * transport.send({ type: 'greeting', payload: { hello: 'native' } });\n * \n * // Cleanup\n * transport.destroy();\n */\nexport class NativeBridgeTransport {\n    /** @type {BridgeType} */\n    #bridgeType = 'none';\n\n    /** @type {string} */\n    #androidInterface;\n\n    /** @type {string} */\n    #iosHandler;\n\n    /** @type {MessageHandler|null} */\n    #messageHandler = null;\n\n    /** @type {boolean} */\n    #destroyed = false;\n\n    /** @type {boolean} */\n    #ready = false;\n\n    /** @type {Array<Object>} */\n    #messageQueue = [];\n\n    /** @type {boolean} */\n    #queueWhileInit;\n\n    /** @type {ReturnType<typeof setInterval>|null} */\n    #heartbeatTimer = null;\n\n    /** @type {number} */\n    #heartbeatInterval;\n\n    /** @type {Promise<void>} */\n    #readyPromise;\n\n    /** @type {((value?: void) => void)|undefined} */\n    #resolveReady;\n\n    /**\n     * Detects which native bridge is available.\n     * \n     * @returns {BridgeType} The detected bridge type.\n     */\n    static detectBridge() {\n        // Check for Android bridge (customizable name, default 'CrossBus')\n        if (globalThis.CrossBus && typeof globalThis.CrossBus.postMessage === 'function') {\n            return 'android';\n        }\n        // Also check common Android bridge patterns\n        if (globalThis.AndroidBridge && typeof globalThis.AndroidBridge.postMessage === 'function') {\n            return 'android';\n        }\n\n        // iOS: WKWebView injects webkit.messageHandlers\n        if (globalThis.webkit?.messageHandlers?.crossbus) {\n            return 'ios';\n        }\n\n        return 'none';\n    }\n\n    /**\n     * Checks if any native bridge is available.\n     * \n     * @returns {boolean} True if a native bridge is detected.\n     */\n    static isSupported() {\n        return NativeBridgeTransport.detectBridge() !== 'none';\n    }\n\n    /**\n     * Creates a new Native Bridge transport.\n     * \n     * @param {NativeBridgeTransportOptions} [options={}] - Configuration options.\n     */\n    constructor(options = {}) {\n        this.#androidInterface = options.androidInterface ?? 'CrossBus';\n        this.#iosHandler = options.iosHandler ?? 'crossbus';\n        this.#queueWhileInit = options.queueWhileInit ?? true;\n        this.#heartbeatInterval = options.heartbeatInterval ?? 30000;\n\n        // Create ready promise\n        this.#readyPromise = new Promise((resolve) => {\n            this.#resolveReady = resolve;\n        });\n\n        // Detect and initialize bridge\n        this.#initBridge(options.initTimeout ?? 5000);\n    }\n\n    /**\n     * Initializes the native bridge connection.\n     * \n     * @param {number} timeout - Timeout in ms.\n     */\n    async #initBridge(timeout) {\n        const startTime = Date.now();\n\n        // Poll for bridge availability\n        const checkBridge = () => {\n            this.#bridgeType = NativeBridgeTransport.detectBridge();\n\n            if (this.#bridgeType !== 'none') {\n                this.#onBridgeReady();\n                return;\n            }\n\n            if (Date.now() - startTime < timeout) {\n                setTimeout(checkBridge, 50);\n            } else {\n                // Timeout - no bridge found, but don't error\n                // Could be running in regular browser\n                console.warn('[CrossBus] No native bridge detected after timeout');\n                this.#ready = true;\n                this.#resolveReady?.();\n            }\n        };\n\n        checkBridge();\n\n        // Set up global callback for native  JS messages\n        this.#setupNativeCallback();\n    }\n\n    /**\n     * Called when bridge is detected and ready.\n     */\n    #onBridgeReady() {\n        this.#ready = true;\n        this.#resolveReady?.();\n\n        // Flush queued messages\n        this.#flushQueue();\n\n        // Start heartbeat if enabled\n        if (this.#heartbeatInterval > 0) {\n            this.#startHeartbeat();\n        }\n    }\n\n    /**\n     * Sets up callback for native  JS communication.\n     */\n    #setupNativeCallback() {\n        // Native should call this global function to send messages to JS\n        const callbackName = '__crossbus_receive__';\n\n        globalThis[callbackName] = (messageStr) => {\n            if (this.#destroyed || !this.#messageHandler) return;\n\n            try {\n                const data = typeof messageStr === 'string'\n                    ? JSON.parse(messageStr)\n                    : messageStr;\n\n                if (!isProtocolMessage(data)) return;\n\n                this.#messageHandler(data, { bridgeType: this.#bridgeType });\n            } catch (e) {\n                console.error('[CrossBus] Failed to parse native message:', e);\n            }\n        };\n    }\n\n    /**\n     * Sends a message to the native side.\n     * \n     * @param {Object} message - Protocol message to send.\n     * @throws {CrossBusError} If transport is destroyed.\n     */\n    send(message) {\n        if (this.#destroyed) {\n            throw CrossBusError.from(ErrorCode.DESTROYED, {\n                context: 'NativeBridgeTransport.send'\n            });\n        }\n\n        // Ensure message has protocol marker\n        const envelope = {\n            [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n            ...message\n        };\n\n        // Queue if not ready\n        if (!this.#ready && this.#queueWhileInit) {\n            this.#messageQueue.push(envelope);\n            return;\n        }\n\n        this.#sendToNative(envelope);\n    }\n\n    /**\n     * Actually sends message to native bridge.\n     * \n     * @param {Object} envelope - Message envelope.\n     */\n    #sendToNative(envelope) {\n        const jsonStr = JSON.stringify(envelope);\n\n        try {\n            if (this.#bridgeType === 'android') {\n                // Try custom interface name first\n                const bridge = globalThis[this.#androidInterface] || globalThis.AndroidBridge;\n                if (bridge?.postMessage) {\n                    bridge.postMessage(jsonStr);\n                }\n            } else if (this.#bridgeType === 'ios') {\n                // iOS WKWebView\n                const handler = globalThis.webkit?.messageHandlers?.[this.#iosHandler];\n                if (handler?.postMessage) {\n                    handler.postMessage(envelope); // iOS can take objects directly\n                }\n            }\n            // If bridgeType is 'none', silently drop (or could throw)\n        } catch (e) {\n            console.error('[CrossBus] Failed to send to native:', e);\n        }\n    }\n\n    /**\n     * Flushes queued messages after bridge is ready.\n     */\n    #flushQueue() {\n        while (this.#messageQueue.length > 0) {\n            const msg = this.#messageQueue.shift();\n            this.#sendToNative(msg);\n        }\n    }\n\n    /**\n     * Starts heartbeat to keep native connection alive.\n     */\n    #startHeartbeat() {\n        this.#heartbeatTimer = setInterval(() => {\n            if (this.#destroyed) return;\n\n            this.#sendToNative({\n                [PROTOCOL_MARKER]: PROTOCOL_VERSION,\n                t: 'hb', // heartbeat\n                ts: Date.now()\n            });\n        }, this.#heartbeatInterval);\n    }\n\n    /**\n     * Registers a message handler.\n     * \n     * @param {MessageHandler} handler - Function to handle incoming messages.\n     */\n    onMessage(handler) {\n        if (typeof handler !== 'function') {\n            throw new TypeError('Handler must be a function');\n        }\n        this.#messageHandler = handler;\n    }\n\n    /**\n     * Removes the message handler.\n     */\n    offMessage() {\n        this.#messageHandler = null;\n    }\n\n    /**\n     * Destroys the transport, cleaning up resources.\n     */\n    destroy() {\n        if (this.#destroyed) return;\n\n        this.#destroyed = true;\n        this.#messageHandler = null;\n        this.#messageQueue = [];\n\n        if (this.#heartbeatTimer) {\n            clearInterval(this.#heartbeatTimer);\n            this.#heartbeatTimer = null;\n        }\n\n        // Clean up global callback\n        delete globalThis['__crossbus_receive__'];\n    }\n\n    /**\n     * Gets whether the transport is destroyed.\n     * @returns {boolean}\n     */\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n\n    /**\n     * Gets the detected bridge type.\n     * @returns {BridgeType}\n     */\n    get bridgeType() {\n        return this.#bridgeType;\n    }\n\n    /**\n     * Gets whether the bridge is ready.\n     * @returns {boolean}\n     */\n    get isReady() {\n        return this.#ready;\n    }\n\n    /**\n     * Promise that resolves when bridge is ready.\n     * @returns {Promise<void>}\n     */\n    get ready() {\n        return this.#readyPromise;\n    }\n}\n","/**\n * @fileoverview WebSocket transport for CrossBus.\n * Enables communication with a server via WebSocket.\n * @module transports/websocket\n */\n\nimport { uuid } from '../common/utils.js';\nimport { PROTOCOL_MARKER, PROTOCOL_VERSION } from '../common/types.js';\n\n/**\n * @typedef {Object} WebSocketTransportOptions\n * @property {string} url - WebSocket server URL (ws:// or wss://)\n * @property {string} [peerId] - Local peer ID\n * @property {boolean} [autoReconnect=true] - Auto-reconnect on disconnect\n * @property {number} [reconnectDelayMs=1000] - Base delay for reconnection\n * @property {number} [maxReconnectDelayMs=30000] - Max delay with exponential backoff\n * @property {number} [heartbeatIntervalMs=30000] - Heartbeat interval (0 to disable)\n * @property {Object} [protocols] - WebSocket subprotocols\n */\n\n/**\n * WebSocket transport for server communication.\n * \n * @example\n * const transport = new WebSocketTransport({\n *   url: 'wss://api.example.com/crossbus',\n *   peerId: 'client-1'\n * });\n * \n * transport.onMessage((msg) => console.log('Received:', msg));\n * transport.onStateChange((state) => console.log('State:', state));\n * \n * await transport.connect();\n * transport.send({ type: 'hello', payload: { name: 'client' } });\n */\nexport class WebSocketTransport {\n    /** @type {string} */\n    #url;\n\n    /** @type {string} */\n    #peerId;\n\n    /** @type {WebSocket|null} */\n    #socket = null;\n\n    /** @type {boolean} */\n    #autoReconnect;\n\n    /** @type {number} */\n    #reconnectDelayMs;\n\n    /** @type {number} */\n    #maxReconnectDelayMs;\n\n    /** @type {number} */\n    #currentReconnectDelay;\n\n    /** @type {number} */\n    #heartbeatIntervalMs;\n\n    /** @type {ReturnType<typeof setInterval>|null} */\n    #heartbeatTimer = null;\n\n    /** @type {ReturnType<typeof setTimeout>|null} */\n    #reconnectTimer = null;\n\n    /** @type {((message: Object) => void)|null} */\n    #messageHandler = null;\n\n    /** @type {((state: 'connecting'|'connected'|'disconnected'|'error') => void)|null} */\n    #stateHandler = null;\n\n    /** @type {'connecting'|'connected'|'disconnected'|'error'} */\n    #state = 'disconnected';\n\n    /** @type {Object[]} */\n    #messageQueue = [];\n\n    /** @type {boolean} */\n    #intentionalClose = false;\n\n    /**\n     * Creates a new WebSocket transport.\n     * @param {WebSocketTransportOptions} options\n     */\n    constructor(options) {\n        this.#url = options.url;\n        this.#peerId = options.peerId ?? uuid();\n        this.#autoReconnect = options.autoReconnect ?? true;\n        this.#reconnectDelayMs = options.reconnectDelayMs ?? 1000;\n        this.#maxReconnectDelayMs = options.maxReconnectDelayMs ?? 30000;\n        this.#currentReconnectDelay = this.#reconnectDelayMs;\n        this.#heartbeatIntervalMs = options.heartbeatIntervalMs ?? 30000;\n    }\n\n    /** @returns {string} */\n    get peerId() {\n        return this.#peerId;\n    }\n\n    /** @returns {'connecting'|'connected'|'disconnected'|'error'} */\n    get state() {\n        return this.#state;\n    }\n\n    /** @returns {boolean} */\n    get isConnected() {\n        return this.#state === 'connected' && this.#socket?.readyState === WebSocket.OPEN;\n    }\n\n    /**\n     * Connects to the WebSocket server.\n     * @returns {Promise<void>}\n     */\n    async connect() {\n        if (this.#socket && this.#socket.readyState === WebSocket.OPEN) {\n            return;\n        }\n\n        this.#intentionalClose = false;\n        this.#setState('connecting');\n\n        return new Promise((resolve, reject) => {\n            try {\n                this.#socket = new WebSocket(this.#url);\n\n                this.#socket.onopen = () => {\n                    this.#setState('connected');\n                    this.#currentReconnectDelay = this.#reconnectDelayMs;\n                    this.#flushQueue();\n                    this.#startHeartbeat();\n                    resolve();\n                };\n\n                this.#socket.onmessage = (event) => {\n                    this.#handleMessage(event);\n                };\n\n                this.#socket.onclose = (event) => {\n                    this.#stopHeartbeat();\n                    this.#setState('disconnected');\n\n                    if (!this.#intentionalClose && this.#autoReconnect) {\n                        this.#scheduleReconnect();\n                    }\n                };\n\n                this.#socket.onerror = (error) => {\n                    this.#setState('error');\n                    if (this.#state === 'connecting') {\n                        reject(new Error('WebSocket connection failed'));\n                    }\n                };\n            } catch (e) {\n                this.#setState('error');\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     * Disconnects from the server.\n     */\n    disconnect() {\n        this.#intentionalClose = true;\n        this.#stopHeartbeat();\n\n        if (this.#reconnectTimer) {\n            clearTimeout(this.#reconnectTimer);\n            this.#reconnectTimer = null;\n        }\n\n        if (this.#socket) {\n            this.#socket.close(1000, 'Client disconnect');\n            this.#socket = null;\n        }\n\n        this.#setState('disconnected');\n    }\n\n    /**\n     * Sends a message to the server.\n     * @param {Object} message - Message to send\n     * @returns {boolean} Whether the message was sent immediately\n     */\n    send(message) {\n        const envelope = {\n            _cb: PROTOCOL_VERSION,\n            _m: PROTOCOL_MARKER,\n            id: uuid(),\n            from: this.#peerId,\n            timestamp: Date.now(),\n            ...message\n        };\n\n        if (this.isConnected && this.#socket) {\n            this.#socket.send(JSON.stringify(envelope));\n            return true;\n        } else {\n            // Queue for later\n            this.#messageQueue.push(envelope);\n            return false;\n        }\n    }\n\n    /**\n     * Sets the message handler.\n     * @param {(message: Object) => void} handler\n     */\n    onMessage(handler) {\n        this.#messageHandler = handler;\n    }\n\n    /**\n     * Sets the state change handler.\n     * @param {(state: string) => void} handler\n     */\n    onStateChange(handler) {\n        this.#stateHandler = handler;\n    }\n\n    /**\n     * Handles incoming messages.\n     */\n    #handleMessage(event) {\n        try {\n            const data = JSON.parse(event.data);\n\n            // Handle pong (heartbeat response)\n            if (data.type === 'pong') {\n                return;\n            }\n\n            if (this.#messageHandler) {\n                this.#messageHandler(data);\n            }\n        } catch (e) {\n            console.error('[WebSocketTransport] Failed to parse message:', e);\n        }\n    }\n\n    /**\n     * Flushes queued messages.\n     */\n    #flushQueue() {\n        while (this.#messageQueue.length > 0 && this.isConnected && this.#socket) {\n            const message = this.#messageQueue.shift();\n            if (message) {\n                this.#socket.send(JSON.stringify(message));\n            }\n        }\n    }\n\n    /**\n     * Updates and emits state.\n     */\n    #setState(state) {\n        if (this.#state !== state) {\n            this.#state = state;\n            if (this.#stateHandler) {\n                this.#stateHandler(state);\n            }\n        }\n    }\n\n    /**\n     * Starts heartbeat timer.\n     */\n    #startHeartbeat() {\n        if (this.#heartbeatIntervalMs <= 0) return;\n\n        this.#heartbeatTimer = setInterval(() => {\n            if (this.isConnected && this.#socket) {\n                this.#socket.send(JSON.stringify({ type: 'ping', from: this.#peerId }));\n            }\n        }, this.#heartbeatIntervalMs);\n    }\n\n    /**\n     * Stops heartbeat timer.\n     */\n    #stopHeartbeat() {\n        if (this.#heartbeatTimer) {\n            clearInterval(this.#heartbeatTimer);\n            this.#heartbeatTimer = null;\n        }\n    }\n\n    /**\n     * Schedules a reconnection attempt.\n     */\n    #scheduleReconnect() {\n        if (this.#reconnectTimer) return;\n\n        this.#reconnectTimer = setTimeout(async () => {\n            this.#reconnectTimer = null;\n\n            try {\n                await this.connect();\n            } catch {\n                // Exponential backoff\n                this.#currentReconnectDelay = Math.min(\n                    this.#currentReconnectDelay * 2,\n                    this.#maxReconnectDelayMs\n                );\n\n                if (this.#autoReconnect && !this.#intentionalClose) {\n                    this.#scheduleReconnect();\n                }\n            }\n        }, this.#currentReconnectDelay);\n    }\n\n    /**\n     * Destroys the transport.\n     */\n    destroy() {\n        this.disconnect();\n        this.#messageHandler = null;\n        this.#stateHandler = null;\n        this.#messageQueue = [];\n    }\n}\n","/**\n * @fileoverview Vector Clock implementation for causal ordering.\n * \n * Vector clocks track logical time across distributed processes,\n * enabling detection of causal relationships between events.\n * \n * @module ordering/vector-clock\n */\n\n/**\n * Vector Clock for tracking causal order in distributed systems.\n * \n * Each node maintains a counter for every known node. When sending\n * a message, the sender increments its own counter and includes\n * the entire clock. When receiving, the receiver updates its clock\n * by taking the max of each component.\n * \n * @example\n * const clock = new VectorClock('node-1');\n * clock.tick(); // Increment before sending\n * const message = { data, clock: clock.toJSON() };\n * \n * // On receive:\n * const remoteClock = VectorClock.fromJSON(message.clock);\n * if (localClock.canDeliver(remoteClock, senderId)) {\n *   localClock.update(remoteClock);\n *   deliver(message);\n * }\n */\nexport class VectorClock {\n    /** @type {string} */\n    #ownId;\n\n    /** @type {Map<string, number>} */\n    #counters;\n\n    /**\n     * Creates a new vector clock.\n     * \n     * @param {string} ownId - This node's unique identifier\n     * @param {Object<string, number>} [initial={}] - Initial counter values\n     */\n    constructor(ownId, initial = {}) {\n        this.#ownId = ownId;\n        this.#counters = new Map(Object.entries(initial));\n\n        // Ensure own entry exists\n        if (!this.#counters.has(ownId)) {\n            this.#counters.set(ownId, 0);\n        }\n    }\n\n    /**\n     * Gets this node's ID.\n     * @returns {string}\n     */\n    get ownId() {\n        return this.#ownId;\n    }\n\n    /**\n     * Gets the counter value for a node.\n     * \n     * @param {string} nodeId - Node identifier\n     * @returns {number} Counter value (0 if unknown)\n     */\n    get(nodeId) {\n        return this.#counters.get(nodeId) ?? 0;\n    }\n\n    /**\n     * Increments this node's counter (call before sending).\n     * \n     * @returns {number} New counter value\n     */\n    tick() {\n        const current = this.get(this.#ownId);\n        const next = current + 1;\n        this.#counters.set(this.#ownId, next);\n        return next;\n    }\n\n    /**\n     * Updates this clock with values from another clock.\n     * Takes the max of each component (merge operation).\n     * \n     * @param {VectorClock} other - Clock to merge from\n     */\n    update(other) {\n        for (const [nodeId, value] of other.#counters) {\n            const current = this.get(nodeId);\n            if (value > current) {\n                this.#counters.set(nodeId, value);\n            }\n        }\n    }\n\n    /**\n     * Checks if this clock happened-before another.\n     * A happened-before B iff all(A[i] <= B[i]) and exists(A[j] < B[j])\n     * \n     * @param {VectorClock} other - Clock to compare against\n     * @returns {boolean} True if this clock causally precedes other\n     */\n    happenedBefore(other) {\n        let atLeastOneSmaller = false;\n        const allNodeIds = new Set([...this.#counters.keys(), ...other.#counters.keys()]);\n\n        for (const nodeId of allNodeIds) {\n            const thisVal = this.get(nodeId);\n            const otherVal = other.get(nodeId);\n\n            if (thisVal > otherVal) {\n                return false; // This has a greater component\n            }\n            if (thisVal < otherVal) {\n                atLeastOneSmaller = true;\n            }\n        }\n\n        return atLeastOneSmaller;\n    }\n\n    /**\n     * Checks if this clock is concurrent with another.\n     * Concurrent means neither happened-before the other.\n     * \n     * @param {VectorClock} other - Clock to compare against\n     * @returns {boolean} True if clocks are concurrent\n     */\n    isConcurrentWith(other) {\n        return !this.happenedBefore(other) &&\n            !other.happenedBefore(this) &&\n            !this.equals(other);\n    }\n\n    /**\n     * Checks if two clocks are identical.\n     * \n     * @param {VectorClock} other - Clock to compare against\n     * @returns {boolean} True if clocks have identical values\n     */\n    equals(other) {\n        const allNodeIds = new Set([...this.#counters.keys(), ...other.#counters.keys()]);\n\n        for (const nodeId of allNodeIds) {\n            if (this.get(nodeId) !== other.get(nodeId)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if a message with the given clock can be delivered.\n     * \n     * Delivery condition: For the sender's component, the message clock\n     * should be exactly one more than our current knowledge. For all other\n     * components, the message clock should be <= our current knowledge.\n     * \n     * @param {VectorClock} msgClock - Clock attached to incoming message\n     * @param {string} senderId - ID of the message sender\n     * @returns {boolean} True if message can be delivered without breaking causal order\n     */\n    canDeliver(msgClock, senderId) {\n        const senderSeq = msgClock.get(senderId);\n        const ourKnowledge = this.get(senderId);\n\n        // Sender's sequence should be next in order (exactly +1)\n        if (senderSeq !== ourKnowledge + 1) {\n            return false;\n        }\n\n        // All other components should be <= what we know\n        for (const [nodeId, value] of msgClock.#counters) {\n            if (nodeId === senderId) continue;\n            if (value > this.get(nodeId)) {\n                return false; // We're missing messages from another node\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Creates a copy of this clock.\n     * \n     * @returns {VectorClock} Cloned clock\n     */\n    clone() {\n        const counters = Object.fromEntries(this.#counters);\n        return new VectorClock(this.#ownId, counters);\n    }\n\n    /**\n     * Serializes to JSON-compatible object.\n     * \n     * @returns {{ ownId: string, counters: Object<string, number> }}\n     */\n    toJSON() {\n        return {\n            ownId: this.#ownId,\n            counters: Object.fromEntries(this.#counters)\n        };\n    }\n\n    /**\n     * Deserializes from JSON object.\n     * \n     * @param {{ ownId: string, counters: Object<string, number> }} json\n     * @returns {VectorClock}\n     */\n    static fromJSON(json) {\n        return new VectorClock(json.ownId, json.counters);\n    }\n\n    /**\n     * Returns human-readable representation.\n     * @returns {string}\n     */\n    toString() {\n        const entries = [...this.#counters.entries()]\n            .map(([k, v]) => `${k}:${v}`)\n            .join(', ');\n        return `VectorClock(${this.#ownId}){${entries}}`;\n    }\n}\n","/**\n * @fileoverview Causal Orderer for message delivery with causal consistency.\n * \n * Buffers out-of-order messages and delivers them only when their\n * causal dependencies have been satisfied.\n * \n * @module ordering/causal-orderer\n */\n\nimport { VectorClock } from './vector-clock.js';\n\n/**\n * @typedef {Object} CausalOrdererOptions\n * @property {Function} [onDeliver] - Callback when message is delivered\n * @property {number} [maxBufferSize=1000] - Maximum buffered messages\n * @property {Function} [onBufferOverflow] - Called when buffer is full\n */\n\n/**\n * @typedef {Object} BufferedMessage\n * @property {string} senderId - Message sender ID\n * @property {Object} message - Original message\n * @property {VectorClock} clock - Message's vector clock\n */\n\n/**\n * Causal Orderer ensures messages are delivered in causal order.\n * \n * When a message arrives out of order (missing dependencies), it's\n * buffered until its dependencies are satisfied. This guarantees\n * that if message B was sent after seeing message A, then B will\n * be delivered after A at all receivers.\n * \n * @example\n * const orderer = new CausalOrderer('my-node', {\n *   onDeliver: (msg) => processMessage(msg)\n * });\n * \n * // When receiving a message:\n * orderer.receive(senderId, message);\n * \n * // When sending:\n * const clock = orderer.tick();\n * send({ ...data, clock: clock.toJSON() });\n */\nexport class CausalOrderer {\n    /** @type {string} */\n    #ownId;\n\n    /** @type {VectorClock} */\n    #clock;\n\n    /** @type {BufferedMessage[]} */\n    #buffer;\n\n    /** @type {Function} */\n    #onDeliver;\n\n    /** @type {number} */\n    #maxBufferSize;\n\n    /** @type {Function|null} */\n    #onBufferOverflow;\n\n    /**\n     * Creates a new CausalOrderer.\n     * \n     * @param {string} ownId - This node's unique identifier\n     * @param {CausalOrdererOptions} options - Configuration options\n     */\n    constructor(ownId, options = {}) {\n        this.#ownId = ownId;\n        this.#clock = new VectorClock(ownId);\n        this.#buffer = [];\n        this.#onDeliver = options.onDeliver || (() => { });\n        this.#maxBufferSize = options.maxBufferSize ?? 1000;\n        this.#onBufferOverflow = options.onBufferOverflow || null;\n    }\n\n    /**\n     * Gets this node's ID.\n     * @returns {string}\n     */\n    get ownId() {\n        return this.#ownId;\n    }\n\n    /**\n     * Gets the current buffer size.\n     * @returns {number}\n     */\n    get bufferSize() {\n        return this.#buffer.length;\n    }\n\n    /**\n     * Receives a message and delivers it if deps are satisfied,\n     * otherwise buffers it.\n     * \n     * @param {string} senderId - ID of the message sender\n     * @param {Object} message - Message with clock property\n     */\n    receive(senderId, message) {\n        const msgClock = VectorClock.fromJSON(message.clock);\n\n        if (this.#clock.canDeliver(msgClock, senderId)) {\n            this.#deliver(senderId, message, msgClock);\n            this.#tryDeliverBuffered();\n        } else {\n            this.#bufferMessage(senderId, message, msgClock);\n        }\n    }\n\n    /**\n     * Delivers a message and updates local clock.\n     * \n     * @param {string} senderId\n     * @param {Object} message\n     * @param {VectorClock} msgClock\n     */\n    #deliver(senderId, message, msgClock) {\n        // Update local clock with received clock\n        this.#clock.update(msgClock);\n\n        // Invoke delivery callback\n        this.#onDeliver(message);\n    }\n\n    /**\n     * Buffers a message for later delivery.\n     * \n     * @param {string} senderId\n     * @param {Object} message\n     * @param {VectorClock} clock\n     */\n    #bufferMessage(senderId, message, clock) {\n        if (this.#buffer.length >= this.#maxBufferSize) {\n            if (this.#onBufferOverflow) {\n                this.#onBufferOverflow({\n                    senderId,\n                    message,\n                    bufferSize: this.#buffer.length\n                });\n            }\n            return; // Drop message if buffer full\n        }\n\n        this.#buffer.push({ senderId, message, clock });\n    }\n\n    /**\n     * Tries to deliver buffered messages whose deps are now satisfied.\n     * Repeats until no more messages can be delivered.\n     */\n    #tryDeliverBuffered() {\n        let delivered = true;\n\n        while (delivered) {\n            delivered = false;\n\n            for (let i = this.#buffer.length - 1; i >= 0; i--) {\n                const { senderId, message, clock } = this.#buffer[i];\n\n                if (this.#clock.canDeliver(clock, senderId)) {\n                    // Remove from buffer\n                    this.#buffer.splice(i, 1);\n                    // Deliver\n                    this.#deliver(senderId, message, clock);\n                    delivered = true;\n                }\n            }\n        }\n    }\n\n    /**\n     * Increments local clock for sending a message.\n     * Returns the clock to attach to outgoing message.\n     * \n     * @returns {VectorClock} Clock to include in message\n     */\n    tick() {\n        this.#clock.tick();\n        return this.#clock.clone();\n    }\n\n    /**\n     * Gets a copy of the current vector clock.\n     * \n     * @returns {VectorClock}\n     */\n    getVectorClock() {\n        return this.#clock.clone();\n    }\n\n    /**\n     * Clears the buffer (e.g., on disconnect).\n     */\n    clear() {\n        this.#buffer = [];\n    }\n}\n"],"names":["isProtocolMessage","obj","PROTOCOL_MARKER","id","type","t","findTransferables","value","found","Set","Array","from","ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas","ReadableStream","WritableStream","TransformStream","isTransferable","add","isArray","item","key","Object","keys","createMessage","payload","meta","freeze","PROTOCOL_PREFIX","version","crypto","randomUUID","timestamp","Date","now","createResponseMessage","requestId","data","sourcePeerId","success","error","MessageType","RESPONSE","source","isCrossBusError","err","CrossBusError","isRetryable","retryable","uuid","replace","c","r","Math","random","toString","isCloneable","Node","WeakMap","WeakSet","deferred","Promise","withResolvers","resolve","reject","promise","res","rej","sleep","ms","signal","aborted","reason","Error","timeoutId","setTimeout","addEventListener","clearTimeout","once","withTimeout","message","race","_","detectPeerType","target","Worker","ServiceWorker","Window","HTMLIFrameElement","DedicatedWorkerGlobalScope","ts","iso","toISOString","createPresence","bus","options","presence","PresenceManager","async","peerId","on","ctx","handleMessage","getSerializer","contentType","serializers","get","JSONSerializer","LISTENERS","Symbol","SUB_COUNTER","MAX_LISTENERS","FAST_CACHE","DEFAULT_SOURCE","origin","globalThis","location","EventEmitter","constructor","this","Map","create","setMaxListeners","n","getMaxListeners","name","handler","TypeError","entry","priority","mode","has","set","listeners","length","push","lo","hi","mid","splice","map","e","active","subscription","signalName","unsubscribe","removeListener","onFast","filter","h","offFast","cache","idx","indexOf","findIndex","off","removedCount","remainingCount","undefined","delete","initialLength","filtered","emitSync","callbacks","len","i","emit","exactListeners","hasWildcard","event","messageId","then","matchingEntries","getMatchingListeners","toRemove","hasListeners","listenerCount","getSignalNames","clear","globalWildcard","namespaceWildcard","colonIdx","wildcardPattern","slice","sources","entries","Boolean","results","sort","a","b","createFastEmitter","events","cb","PROTOCOL_VERSION","SIGNAL","REQUEST","ACK","HANDSHAKE","HANDSHAKE_INIT","HANDSHAKE_ACK","HANDSHAKE_COMPLETE","PING","PONG","BYE","BROADCAST","HandshakePhase","INIT","INIT_SENT","ACK_SENT","DONE","PeerStatus","CONNECTING","CONNECTED","DISCONNECTED","RECONNECTING","FAILED","PeerType","IFRAME","WORKER","SERVICE_WORKER","WINDOW","PORT","DeliveryStatus","LOCAL","SENT","ACKED","QUEUED","TIMEOUT","ErrorCode","HANDSHAKE_TIMEOUT","HANDSHAKE_REJECTED","ORIGIN_FORBIDDEN","PEER_EXISTS","PEER_NOT_FOUND","PEER_DISCONNECTED","RECONNECT_FAILED","UNSUPPORTED","NOT_CONNECTED","ACK_TIMEOUT","RESPONSE_TIMEOUT","QUEUE_FULL","INVALID_MESSAGE","VERSION_MISMATCH","CLONE_ERROR","TRANSFER_ERROR","MESSAGE_TOO_LARGE","UNREACHABLE","TTL_EXCEEDED","NO_ROUTE","NO_HANDLER","HANDLER_ERROR","HANDLER_TIMEOUT","HANDLER_EXISTS","SEND_FAILED","CHANNEL_FAILED","CHANNEL_CLOSED","MAX_PEERS","MAX_PENDING","DESTROYED","CIRCUIT_OPEN","PAYLOAD_TOO_LARGE","RATE_LIMITED","UNAUTHORIZED","INVALID_PAYLOAD","ERROR_META","suggestion","code","details","cause","super","captureStackTrace","wrap","toJSON","MessageRouter","peers","messageSeq","peerSeq","peerCache","sendFnCache","peerIds","addPeer","sendFn","status","connectedAt","removePeer","peer","getPeer","getPeerIds","peerCount","size","route","routeUnicast","excludeArr","exclude","routeBroadcast","broadcast","includeArr","include","delivered","failed","envelope","createEnvelope","getSequence","setPeerStatus","clearPeers","messageToSend","_cb","seq","p","PendingRequests","pending","requestCounter","defaultTimeout","maxPending","targetPeer","handlerName","current","max","timeout","createdAt","defaultValue","timeoutPromise","catch","response","originalError","cancel","cancelForPeer","count","cancelAll","getRequestIds","getForPeer","requests","values","Handshake","localPeerId","capabilities","pendingHandshakes","config","createInitMessage","handshakeId","createAckMessage","initMessage","accept","createCompleteMessage","confirmed","initiate","initMsg","phase","startTime","validateFn","handleInit","handleAck","handleComplete","hasPending","remotePeer","peerInfo","OriginValidator","exactOrigins","patterns","allowAll","selfOrigin","allowed","addOrigin","isAllowed","pattern","test","allow","disallow","getAllowed","includes","createPattern","escaped","RegExp","OriginValidatorPresets","sameOrigin","fromList","origins","CrossBus","isHub","router","pendingRequests","handshake","originValidator","handlers","inboundHooks","outboundHooks","requestTimeout","maxPayloadSize","maxPendingRequests","strictMode","rateLimitCounters","handlerOptions","debug","debugPrefix","destroyed","handshakeTimeout","allowedOrigins","emitSecurityWarnings","log","assertNotDestroyed","destPeerId","dest","createSignalMessage","runHooks","direction","result","request","createRequestMessage","broadcastRequest","ignoreErrors","promises","requestPromise","all","handle","allowedPeers","rateLimit","validatePayload","unhandle","hasHandler","addInboundHook","hookFn","fn","removeInboundHook","addOutboundHook","removeOutboundHook","index","addTransport","transport","send","onMessage","destroy","replyFn","msgType","handlerOrName","dataContent","innerMsg","hookContext","handleSignal","handleRequest","handleResponse","isDestroyed","securityCheck","checkHandlerSecurity","context","hooks","process","env","NODE_ENV","window","hostname","checkRateLimit","limit","maxPerSecond","counter","resetAt","uptime","healthCheck","connectedCount","memory","memoryUsage","mem","heapUsed","heapTotal","rss","total","ids","createSecure","diagnose","issues","suggestions","warnings","handlerCount","pendingCount","WritableSignalStream","streamId","chunkSize","ended","opened","open","st","write","isBase64","arrayBufferToBase64","Uint8Array","chunks","chunkString","chunk","d","b64","JSON","stringify","end","finalMeta","abort","sid","str","bytes","binary","String","fromCharCode","btoa","ReadableSignalStream","buffer","resolveNext","base64ToUint8Array","asyncIterator","shift","collect","isBinary","totalLength","reduce","acc","offset","join","base64","atob","charCodeAt","StreamManager","activeStreams","streamHandlers","createStream","onStream","handleOpen","handleData","handleEnd","handleError","stream","activeStreamCount","heartbeatInterval","heartbeatTimer","cleanupTimer","autoStart","start","onlineCount","sendPresence","setInterval","cleanupOfflinePeers","stop","clearInterval","setStatus","setMeta","getOnlinePeers","getAllPeers","isOnline","fromPeerId","pt","presenceType","handleJoin","handleLeave","handleUpdate","isNew","lastSeen","wasOffline","threshold","parse","PostMessageTransport","targetOrigin","autoTransfer","serializer","messageHandler","boundListener","isSupported","postMessage","isValidTarget","bind","getListenerTarget","transfer","isWindowClosed","dataToSend","serialize","transferables","isWorker","offMessage","removeEventListener","isOriginAllowed","currentTarget","closed","BroadcastChannelTransport","channel","channelName","BroadcastChannel","api","onmessage","onmessageerror","close","text","TextDecoder","decode","deserialize","MessageChannelTransport","localPort","remotePort","isInitiator","MessageChannel","fromPort","port","prototype","port1","port2","markRemoteTransferred","SharedWorkerTransport","worker","workerUrl","SharedWorker","onerror","handleWorkerError","ServiceWorkerTransport","controller","readyPromise","boundMessageHandler","navigator","initialize","ready","registration","serviceWorker","NativeBridgeTransport","bridgeType","androidInterface","iosHandler","messageQueue","queueWhileInit","resolveReady","detectBridge","AndroidBridge","webkit","messageHandlers","crossbus","initBridge","initTimeout","checkBridge","onBridgeReady","setupNativeCallback","flushQueue","startHeartbeat","messageStr","sendToNative","jsonStr","bridge","msg","isReady","WebSocketTransport","url","socket","autoReconnect","reconnectDelayMs","maxReconnectDelayMs","currentReconnectDelay","heartbeatIntervalMs","reconnectTimer","stateHandler","state","intentionalClose","isConnected","readyState","WebSocket","OPEN","connect","setState","onopen","onclose","stopHeartbeat","scheduleReconnect","disconnect","_m","onStateChange","min","VectorClock","ownId","counters","initial","nodeId","tick","next","update","other","happenedBefore","atLeastOneSmaller","allNodeIds","thisVal","otherVal","isConcurrentWith","equals","canDeliver","msgClock","senderId","clone","fromEntries","fromJSON","json","k","v","CausalOrderer","clock","onDeliver","maxBufferSize","onBufferOverflow","bufferSize","receive","deliver","tryDeliverBuffered","bufferMessage","getVectorClock"],"mappings":"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"}