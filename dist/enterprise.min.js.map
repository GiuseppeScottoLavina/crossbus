{"version":3,"file":"enterprise.min.js","sources":["../src/common/utils.js","../src/enterprise/tracing.js","../src/enterprise/metrics.js","../src/enterprise/backpressure.js","../src/enterprise/versioning.js"],"sourcesContent":["/**\n * @fileoverview Utility functions shared across modules.\n * @module common/utils\n */\n\n/**\n * Generates a UUID v4.\n * Uses crypto.randomUUID() when available, falls back to manual generation.\n * \n * @returns {string} UUID v4 string.\n */\nexport function uuid() {\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback for older browsers\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n\n/**\n * Checks if data can be structured cloned.\n * \n * @param {*} data - Data to check.\n * @returns {boolean} True if cloneable.\n */\nexport function isCloneable(data) {\n    if (data === null || data === undefined) return true;\n\n    const type = typeof data;\n\n    // Primitives are always cloneable\n    if (type === 'boolean' || type === 'number' || type === 'string') {\n        return true;\n    }\n\n    // Functions and symbols are not cloneable\n    if (type === 'function' || type === 'symbol') {\n        return false;\n    }\n\n    // Check for DOM nodes\n    if (typeof Node !== 'undefined' && data instanceof Node) {\n        return false;\n    }\n\n    // Check for WeakMap/WeakSet\n    if (data instanceof WeakMap || data instanceof WeakSet) {\n        return false;\n    }\n\n    // For objects/arrays, we'd need to recursively check\n    // For performance, we assume they're cloneable and let postMessage fail\n    return true;\n}\n\n/**\n * Creates a deferred promise (Promise.withResolvers polyfill).\n * Uses native Promise.withResolvers() when available (ES2024+).\n * \n * @template T\n * @returns {{promise: Promise<T>, resolve: (value: T) => void, reject: (reason: any) => void}}\n */\nexport function deferred() {\n    // Use native Promise.withResolvers if available (ES2024+, ~10x faster)\n    // @ts-ignore\n    if (typeof Promise.withResolvers === 'function') {\n        // @ts-ignore\n        return Promise.withResolvers();\n    }\n    // Fallback for older engines\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    // @ts-ignore\n    return { promise, resolve, reject };\n}\n\n/**\n * Creates a promise that resolves after a timeout.\n * \n * @param {number} ms - Timeout in milliseconds.\n * @param {AbortSignal} [signal] - Optional abort signal.\n * @returns {Promise<void>}\n */\nexport function sleep(ms, signal) {\n    return new Promise((resolve, reject) => {\n        if (signal?.aborted) {\n            reject(signal.reason ?? new Error('Aborted'));\n            return;\n        }\n\n        const timeoutId = setTimeout(resolve, ms);\n\n        if (signal) {\n            signal.addEventListener('abort', () => {\n                clearTimeout(timeoutId);\n                reject(signal.reason ?? new Error('Aborted'));\n            }, { once: true });\n        }\n    });\n}\n\n/**\n * Creates a promise that rejects after a timeout.\n * \n * @template T\n * @param {Promise<T>} promise - Promise to race against.\n * @param {number} ms - Timeout in milliseconds.\n * @param {string} [message='Operation timed out'] - Timeout error message.\n * @returns {Promise<T>}\n */\nexport function withTimeout(promise, ms, message = 'Operation timed out') {\n    return Promise.race([\n        promise,\n        new Promise((_, reject) => {\n            setTimeout(() => reject(new Error(message)), ms);\n        })\n    ]);\n}\n\n\n\n/**\n * Detects the type of a peer target.\n * \n * @param {*} target - Target to check.\n * @returns {'iframe'|'worker'|'sw'|'window'|'port'|'unknown'}\n */\nexport function detectPeerType(target) {\n    // MessagePort\n    if (target instanceof MessagePort) {\n        return 'port';\n    }\n\n    // Worker\n    if (typeof Worker !== 'undefined' && target instanceof Worker) {\n        return 'worker';\n    }\n\n    // ServiceWorker\n    if (typeof ServiceWorker !== 'undefined' && target instanceof ServiceWorker) {\n        return 'sw';\n    }\n\n    // Window (iframe or popup)\n    if (typeof Window !== 'undefined' && target instanceof Window) {\n        return 'window';\n    }\n\n    // HTMLIFrameElement\n    if (typeof HTMLIFrameElement !== 'undefined' && target instanceof HTMLIFrameElement) {\n        return 'iframe';\n    }\n\n    // DedicatedWorkerGlobalScope (inside worker)\n    if (typeof DedicatedWorkerGlobalScope !== 'undefined' &&\n        target instanceof DedicatedWorkerGlobalScope) {\n        return 'worker';\n    }\n\n    return 'unknown';\n}\n\n\n\n/**\n * Creates a frozen timestamp object.\n * \n * @returns {{timestamp: number, iso: string}}\n */\nexport function timestamp() {\n    const ts = Date.now();\n    return Object.freeze({\n        timestamp: ts,\n        iso: new Date(ts).toISOString()\n    });\n}\n\n\n","/**\n * @fileoverview Distributed tracing for CrossBus.\n * W3C Trace Context compatible for cross-context message tracing.\n * @module enterprise/tracing\n */\n\nimport { uuid } from '../common/utils.js';\n\n/**\n * @typedef {Object} SpanContext\n * @property {string} traceId - 32-char hex trace ID\n * @property {string} spanId - 16-char hex span ID\n * @property {string} [parentSpanId] - Parent span ID\n * @property {number} traceFlags - Trace flags (1 = sampled)\n */\n\n/**\n * @typedef {Object} SpanEvent\n * @property {string} name - Event name\n * @property {number} timestamp - Unix timestamp in ms\n * @property {Object} [attributes] - Event attributes\n */\n\n/**\n * @typedef {'unset'|'ok'|'error'} SpanStatus\n */\n\n/**\n * Represents a single span in a distributed trace.\n */\nexport class Span {\n    /** @type {SpanContext} */\n    #context;\n\n    /** @type {string} */\n    #name;\n\n    /** @type {number} */\n    #startTime;\n\n    /** @type {number|null} */\n    #endTime = null;\n\n    /** @type {SpanStatus} */\n    #status = 'unset';\n\n    /** @type {string|null} */\n    #statusMessage = null;\n\n    /** @type {SpanEvent[]} */\n    #events = [];\n\n    /** @type {Object} */\n    #attributes = {};\n\n    /** @type {Tracer} */\n    #tracer;\n\n    /**\n     * @param {Tracer} tracer - Parent tracer\n     * @param {string} name - Span name\n     * @param {SpanContext} context - Span context\n     */\n    constructor(tracer, name, context) {\n        this.#tracer = tracer;\n        this.#name = name;\n        this.#context = context;\n        this.#startTime = Date.now();\n    }\n\n    /** @returns {SpanContext} */\n    get context() {\n        return this.#context;\n    }\n\n    /** @returns {string} */\n    get name() {\n        return this.#name;\n    }\n\n    /** @returns {boolean} */\n    get isEnded() {\n        return this.#endTime !== null;\n    }\n\n    /**\n     * Sets a span attribute.\n     * @param {string} key - Attribute key\n     * @param {string|number|boolean} value - Attribute value\n     * @returns {this}\n     */\n    setAttribute(key, value) {\n        if (!this.isEnded) {\n            this.#attributes[key] = value;\n        }\n        return this;\n    }\n\n    /**\n     * Sets multiple attributes.\n     * @param {Object} attributes - Key-value pairs\n     * @returns {this}\n     */\n    setAttributes(attributes) {\n        if (!this.isEnded) {\n            Object.assign(this.#attributes, attributes);\n        }\n        return this;\n    }\n\n    /**\n     * Adds an event to the span.\n     * @param {string} name - Event name\n     * @param {Object} [attributes] - Event attributes\n     * @returns {this}\n     */\n    addEvent(name, attributes) {\n        if (!this.isEnded) {\n            this.#events.push({\n                name,\n                timestamp: Date.now(),\n                attributes\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Sets the span status.\n     * @param {SpanStatus} status - Status code\n     * @param {string} [message] - Status message (for errors)\n     * @returns {this}\n     */\n    setStatus(status, message) {\n        if (!this.isEnded) {\n            this.#status = status;\n            this.#statusMessage = message ?? null;\n        }\n        return this;\n    }\n\n    /**\n     * Records an exception on the span.\n     * @param {Error} error - The exception\n     * @returns {this}\n     */\n    recordException(error) {\n        this.addEvent('exception', {\n            'exception.type': error.name,\n            'exception.message': error.message,\n            'exception.stacktrace': error.stack\n        });\n        this.setStatus('error', error.message);\n        return this;\n    }\n\n    /**\n     * Ends the span.\n     */\n    end() {\n        if (!this.isEnded) {\n            this.#endTime = Date.now();\n            this.#tracer._onSpanEnd(this);\n        }\n    }\n\n    /**\n     * Returns the W3C traceparent header value.\n     * @returns {string}\n     */\n    toTraceparent() {\n        const version = '00';\n        const flags = this.#context.traceFlags.toString(16).padStart(2, '0');\n        return `${version}-${this.#context.traceId}-${this.#context.spanId}-${flags}`;\n    }\n\n    /**\n     * Exports the span as a JSON object.\n     * @returns {Object}\n     */\n    toJSON() {\n        return {\n            traceId: this.#context.traceId,\n            spanId: this.#context.spanId,\n            parentSpanId: this.#context.parentSpanId,\n            name: this.#name,\n            startTime: this.#startTime,\n            endTime: this.#endTime,\n            duration: this.#endTime ? this.#endTime - this.#startTime : null,\n            status: this.#status,\n            statusMessage: this.#statusMessage,\n            attributes: { ...this.#attributes },\n            events: [...this.#events]\n        };\n    }\n}\n\n/**\n * Distributed tracer for CrossBus.\n * \n * @example\n * const tracer = new Tracer('my-service');\n * \n * const span = tracer.startSpan('user:save');\n * span.setAttribute('user.id', 123);\n * span.addEvent('validated');\n * \n * try {\n *   await saveUser();\n *   span.setStatus('ok');\n * } catch (e) {\n *   span.recordException(e);\n * } finally {\n *   span.end();\n * }\n */\nexport class Tracer {\n    /** @type {string} */\n    #serviceName;\n\n    /** @type {Map<string, Span[]>} Traces by traceId */\n    #traces = new Map();\n\n    /** @type {Span[]} All completed spans */\n    #completedSpans = [];\n\n    /** @type {number} Max completed spans to keep */\n    #maxSpans;\n\n    /** @type {boolean} Whether to sample (record) traces */\n    #sampled;\n\n    /** @type {((span: Span) => void)[]} */\n    #spanEndCallbacks = [];\n\n    /**\n     * Creates a new tracer.\n     * @param {string} [serviceName='crossbus'] - Service name for traces\n     * @param {Object} [options={}] - Tracer options\n     * @param {number} [options.maxSpans=1000] - Max completed spans to keep\n     * @param {boolean} [options.sampled=true] - Whether to record traces\n     */\n    constructor(serviceName = 'crossbus', options = {}) {\n        this.#serviceName = serviceName;\n        this.#maxSpans = options.maxSpans ?? 1000;\n        this.#sampled = options.sampled ?? true;\n    }\n\n    /**\n     * Starts a new span.\n     * @param {string} name - Span name (e.g., 'user:save', 'widget:init')\n     * @param {Object} [options={}] - Span options\n     * @param {Span} [options.parent] - Parent span for context propagation\n     * @param {Object} [options.attributes] - Initial attributes\n     * @returns {Span}\n     */\n    startSpan(name, options = {}) {\n        const parent = options.parent;\n\n        const context = {\n            traceId: parent?.context.traceId ?? this.#generateTraceId(),\n            spanId: this.#generateSpanId(),\n            parentSpanId: parent?.context.spanId,\n            traceFlags: this.#sampled ? 1 : 0\n        };\n\n        const span = new Span(this, name, context);\n\n        if (options.attributes) {\n            span.setAttributes(options.attributes);\n        }\n\n        // Add to active traces\n        if (!this.#traces.has(context.traceId)) {\n            this.#traces.set(context.traceId, []);\n        }\n        const traceSpans = this.#traces.get(context.traceId);\n        if (traceSpans) {\n            traceSpans.push(span);\n        }\n\n        return span;\n    }\n\n    /**\n     * Creates a span from a W3C traceparent header.\n     * @param {string} name - Span name\n     * @param {string} traceparent - W3C traceparent header value\n     * @returns {Span}\n     */\n    startSpanFromTraceparent(name, traceparent) {\n        const context = this.parseTraceparent(traceparent);\n        if (!context) {\n            return this.startSpan(name);\n        }\n\n        const span = new Span(this, name, {\n            traceId: context.traceId,\n            spanId: this.#generateSpanId(),\n            parentSpanId: context.spanId,\n            traceFlags: context.traceFlags\n        });\n\n        if (!this.#traces.has(context.traceId)) {\n            this.#traces.set(context.traceId, []);\n        }\n        const traceSpans = this.#traces.get(context.traceId);\n        if (traceSpans) {\n            traceSpans.push(span);\n        }\n\n        return span;\n    }\n\n    /**\n     * Parses a W3C traceparent header.\n     * @param {string} traceparent - Header value\n     * @returns {SpanContext|null}\n     */\n    parseTraceparent(traceparent) {\n        if (!traceparent || typeof traceparent !== 'string') {\n            return null;\n        }\n\n        const parts = traceparent.split('-');\n        if (parts.length !== 4) {\n            return null;\n        }\n\n        const [version, traceId, spanId, flags] = parts;\n\n        // Validate format\n        if (version !== '00' || traceId.length !== 32 || spanId.length !== 16) {\n            return null;\n        }\n\n        return {\n            traceId,\n            spanId,\n            traceFlags: parseInt(flags, 16)\n        };\n    }\n\n    /**\n     * Gets all spans for a trace.\n     * @param {string} traceId - Trace ID\n     * @returns {Span[]}\n     */\n    getTrace(traceId) {\n        return this.#traces.get(traceId) ?? [];\n    }\n\n    /**\n     * Gets all completed spans.\n     * @returns {Span[]}\n     */\n    getCompletedSpans() {\n        return [...this.#completedSpans];\n    }\n\n    /**\n     * Exports traces in JSON format.\n     * @param {Object} [options={}] - Export options\n     * @param {string} [options.traceId] - Export specific trace only\n     * @returns {Object}\n     */\n    exportTraces(options = {}) {\n        const spans = options.traceId\n            ? this.getTrace(options.traceId)\n            : this.#completedSpans;\n\n        return {\n            serviceName: this.#serviceName,\n            exportedAt: new Date().toISOString(),\n            spanCount: spans.length,\n            spans: spans.map(s => s.toJSON())\n        };\n    }\n\n    /**\n     * Clears all traces.\n     */\n    clear() {\n        this.#traces.clear();\n        this.#completedSpans = [];\n    }\n\n    /**\n     * Registers a callback for when spans end.\n     * @param {(span: Span) => void} callback\n     * @returns {() => void} Unsubscribe function\n     */\n    onSpanEnd(callback) {\n        this.#spanEndCallbacks.push(callback);\n        return () => {\n            const idx = this.#spanEndCallbacks.indexOf(callback);\n            if (idx !== -1) this.#spanEndCallbacks.splice(idx, 1);\n        };\n    }\n\n    /**\n     * Internal: Called when a span ends.\n     * @param {Span} span\n     */\n    _onSpanEnd(span) {\n        this.#completedSpans.push(span);\n\n        // Trim if over limit\n        if (this.#completedSpans.length > this.#maxSpans) {\n            this.#completedSpans.shift();\n        }\n\n        // Notify callbacks\n        for (const cb of this.#spanEndCallbacks) {\n            try {\n                cb(span);\n            } catch (e) {\n                console.error('[Tracer] Span end callback error:', e);\n            }\n        }\n    }\n\n    /**\n     * Generates a 32-char hex trace ID.\n     * @returns {string}\n     */\n    #generateTraceId() {\n        return uuid().replace(/-/g, '');\n    }\n\n    /**\n     * Generates a 16-char hex span ID.\n     * @returns {string}\n     */\n    #generateSpanId() {\n        return uuid().replace(/-/g, '').slice(0, 16);\n    }\n}\n\n/**\n * Creates a CrossBus plugin that automatically traces messages.\n * \n * @param {Tracer} tracer - Tracer instance\n * @returns {Object} Plugin with inbound/outbound hooks\n * \n * @example\n * const tracer = new Tracer('my-app');\n * const unhook = bus.addOutboundHook(tracingPlugin(tracer).outbound);\n */\nexport function tracingPlugin(tracer) {\n    return {\n        /**\n         * Outbound hook: adds traceparent header to messages\n         */\n        outbound: (payload, context) => {\n            const span = tracer.startSpan(`${context.type}:${context.handlerName || 'signal'}`, {\n                attributes: {\n                    'crossbus.type': context.type,\n                    'crossbus.direction': 'outbound',\n                    'crossbus.peer': context.peerId\n                }\n            });\n\n            // Add traceparent to payload metadata\n            const tracedPayload = {\n                ...payload,\n                _trace: span.toTraceparent()\n            };\n\n            span.end();\n            return tracedPayload;\n        },\n\n        /**\n         * Inbound hook: extracts traceparent and creates child span\n         */\n        inbound: (payload, context) => {\n            if (payload && payload._trace) {\n                const span = tracer.startSpanFromTraceparent(\n                    `${context.type}:${context.handlerName || 'signal'}`,\n                    payload._trace\n                );\n                span.setAttributes({\n                    'crossbus.type': context.type,\n                    'crossbus.direction': 'inbound',\n                    'crossbus.peer': context.peerId\n                });\n                span.end();\n\n                // Remove trace metadata from payload\n                const { _trace, ...cleanPayload } = payload;\n                return cleanPayload;\n            }\n            return payload;\n        }\n    };\n}\n\n/**\n * Default global tracer instance.\n */\nexport const globalTracer = new Tracer('crossbus');\n","/**\n * @fileoverview Metrics and telemetry for CrossBus.\n * Provides counters, histograms, and event hooks for monitoring.\n * @module enterprise/metrics\n */\n\n/**\n * @typedef {Object} MetricEvent\n * @property {string} name - Metric name\n * @property {string} type - 'counter' | 'histogram' | 'gauge'\n * @property {number} value - Metric value\n * @property {Object} [labels] - Metric labels\n * @property {number} timestamp - Unix timestamp in ms\n */\n\n/**\n * @typedef {Object} HistogramBucket\n * @property {number} le - Less than or equal boundary\n * @property {number} count - Count in bucket\n */\n\n/**\n * Simple histogram implementation for latency tracking.\n */\nclass Histogram {\n    /** @type {number[]} */\n    #boundaries;\n\n    /** @type {number[]} */\n    #buckets;\n\n    /** @type {number} */\n    #sum = 0;\n\n    /** @type {number} */\n    #count = 0;\n\n    /**\n     * @param {number[]} boundaries - Bucket boundaries (e.g., [0.005, 0.01, 0.025, 0.05, 0.1])\n     */\n    constructor(boundaries = [0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]) {\n        this.#boundaries = [...boundaries].sort((a, b) => a - b);\n        this.#buckets = new Array(this.#boundaries.length + 1).fill(0);\n    }\n\n    /**\n     * Records a value.\n     * @param {number} value - Value to record (in seconds for latency)\n     */\n    observe(value) {\n        this.#sum += value;\n        this.#count++;\n\n        // Find bucket\n        for (let i = 0; i < this.#boundaries.length; i++) {\n            if (value <= this.#boundaries[i]) {\n                this.#buckets[i]++;\n                return;\n            }\n        }\n        // +Inf bucket\n        this.#buckets[this.#buckets.length - 1]++;\n    }\n\n    /**\n     * Gets histogram data.\n     */\n    getData() {\n        const buckets = this.#boundaries.map((le, i) => ({\n            le,\n            count: this.#buckets[i]\n        }));\n        buckets.push({ le: Infinity, count: this.#buckets[this.#buckets.length - 1] });\n\n        return {\n            buckets,\n            sum: this.#sum,\n            count: this.#count\n        };\n    }\n\n    /**\n     * Calculates percentile.\n     * @param {number} p - Percentile (0-1)\n     */\n    percentile(p) {\n        if (this.#count === 0) return 0;\n\n        const target = p * this.#count;\n        let cumulative = 0;\n\n        for (let i = 0; i < this.#buckets.length; i++) {\n            cumulative += this.#buckets[i];\n            if (cumulative >= target) {\n                return i < this.#boundaries.length ? this.#boundaries[i] : Infinity;\n            }\n        }\n        return Infinity;\n    }\n\n    reset() {\n        this.#buckets.fill(0);\n        this.#sum = 0;\n        this.#count = 0;\n    }\n}\n\n/**\n * Metrics collector for CrossBus.\n * \n * @example\n * const metrics = new Metrics();\n * \n * // Subscribe to metric events\n * metrics.on('metric', (event) => {\n *   console.log(event.name, event.value);\n * });\n * \n * // Use as CrossBus plugin\n * bus.addOutboundHook(metrics.outboundHook);\n * bus.addInboundHook(metrics.inboundHook);\n */\nexport class Metrics {\n    /** @type {Map<string, number>} */\n    #counters = new Map();\n\n    /** @type {Map<string, Histogram>} */\n    #histograms = new Map();\n\n    /** @type {Map<string, number>} */\n    #gauges = new Map();\n\n    /** @type {((event: MetricEvent) => void)[]} */\n    #listeners = [];\n\n    /** @type {string} */\n    #prefix;\n\n    /** @type {Map<string, number>} Request start times for latency tracking */\n    #requestStarts = new Map();\n\n    /**\n     * Creates a new metrics collector.\n     * @param {Object} [options={}] - Options\n     * @param {string} [options.prefix='crossbus'] - Metric name prefix\n     */\n    constructor(options = {}) {\n        this.#prefix = options.prefix ?? 'crossbus';\n\n        // Initialize default histograms\n        this.#histograms.set('latency', new Histogram());\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Counter methods\n    // ─────────────────────────────────────────────────────────────────\n\n    /**\n     * Increments a counter.\n     * @param {string} name - Counter name\n     * @param {number} [value=1] - Increment value\n     * @param {Object} [labels={}] - Labels\n     */\n    increment(name, value = 1, labels = {}) {\n        const key = this.#makeKey(name, labels);\n        const current = this.#counters.get(key) ?? 0;\n        this.#counters.set(key, current + value);\n\n        this.#emit({\n            name: `${this.#prefix}_${name}`,\n            type: 'counter',\n            value: current + value,\n            labels,\n            timestamp: Date.now()\n        });\n    }\n\n    /**\n     * Gets a counter value.\n     * @param {string} name - Counter name\n     * @param {Object} [labels={}] - Labels\n     * @returns {number}\n     */\n    getCounter(name, labels = {}) {\n        return this.#counters.get(this.#makeKey(name, labels)) ?? 0;\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Histogram methods\n    // ─────────────────────────────────────────────────────────────────\n\n    /**\n     * Records a histogram observation.\n     * @param {string} name - Histogram name\n     * @param {number} value - Value to record\n     * @param {Object} [labels={}] - Labels\n     */\n    observe(name, value, labels = {}) {\n        const key = this.#makeKey(name, labels);\n        if (!this.#histograms.has(key)) {\n            this.#histograms.set(key, new Histogram());\n        }\n        const histogram = this.#histograms.get(key);\n        if (histogram) {\n            histogram.observe(value);\n        }\n\n        this.#emit({\n            name: `${this.#prefix}_${name}`,\n            type: 'histogram',\n            value,\n            labels,\n            timestamp: Date.now()\n        });\n    }\n\n    /**\n     * Gets histogram data.\n     * @param {string} name - Histogram name\n     * @param {Object} [labels={}] - Labels\n     */\n    getHistogram(name, labels = {}) {\n        const histogram = this.#histograms.get(this.#makeKey(name, labels));\n        return histogram?.getData() ?? { buckets: [], sum: 0, count: 0 };\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Gauge methods\n    // ─────────────────────────────────────────────────────────────────\n\n    /**\n     * Sets a gauge value.\n     * @param {string} name - Gauge name\n     * @param {number} value - Value\n     * @param {Object} [labels={}] - Labels\n     */\n    set(name, value, labels = {}) {\n        const key = this.#makeKey(name, labels);\n        this.#gauges.set(key, value);\n\n        this.#emit({\n            name: `${this.#prefix}_${name}`,\n            type: 'gauge',\n            value,\n            labels,\n            timestamp: Date.now()\n        });\n    }\n\n    /**\n     * Gets a gauge value.\n     * @param {string} name - Gauge name\n     * @param {Object} [labels={}] - Labels\n     * @returns {number}\n     */\n    getGauge(name, labels = {}) {\n        return this.#gauges.get(this.#makeKey(name, labels)) ?? 0;\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Event subscription\n    // ─────────────────────────────────────────────────────────────────\n\n    /**\n     * Subscribes to metric events.\n     * @param {'metric'} event - Event type\n     * @param {(event: MetricEvent) => void} callback - Callback\n     * @returns {() => void} Unsubscribe function\n     */\n    on(event, callback) {\n        if (event === 'metric') {\n            this.#listeners.push(callback);\n            return () => {\n                const idx = this.#listeners.indexOf(callback);\n                if (idx !== -1) this.#listeners.splice(idx, 1);\n            };\n        }\n        return () => { };\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // CrossBus hooks\n    // ─────────────────────────────────────────────────────────────────\n\n    /**\n     * Outbound hook for CrossBus.\n     * Tracks messages sent and request starts.\n     */\n    get outboundHook() {\n        return (payload, context) => {\n            this.increment('messages_sent_total', 1, { type: context.type });\n\n            // Track request start time\n            if (context.type === 'request' && payload?.id) {\n                this.#requestStarts.set(payload.id, Date.now());\n            }\n\n            return payload;\n        };\n    }\n\n    /**\n     * Inbound hook for CrossBus.\n     * Tracks messages received and response latency.\n     */\n    get inboundHook() {\n        return (payload, context) => {\n            this.increment('messages_received_total', 1, { type: context.type });\n\n            // Track response latency\n            if (context.type === 'response' && payload?.requestId) {\n                const startTime = this.#requestStarts.get(payload.requestId);\n                if (startTime) {\n                    const latencyMs = Date.now() - startTime;\n                    this.observe('latency_seconds', latencyMs / 1000);\n                    this.#requestStarts.delete(payload.requestId);\n                }\n            }\n\n            return payload;\n        };\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Export\n    // ─────────────────────────────────────────────────────────────────\n\n    /**\n     * Exports all metrics in Prometheus text format.\n     * @returns {string}\n     */\n    toPrometheus() {\n        const lines = [];\n\n        // Counters\n        for (const [key, value] of this.#counters) {\n            lines.push(`${this.#prefix}_${key} ${value}`);\n        }\n\n        // Gauges\n        for (const [key, value] of this.#gauges) {\n            lines.push(`${this.#prefix}_${key} ${value}`);\n        }\n\n        // Histograms\n        for (const [key, histogram] of this.#histograms) {\n            const data = histogram.getData();\n            for (const bucket of data.buckets) {\n                const le = bucket.le === Infinity ? '+Inf' : bucket.le;\n                lines.push(`${this.#prefix}_${key}_bucket{le=\"${le}\"} ${bucket.count}`);\n            }\n            lines.push(`${this.#prefix}_${key}_sum ${data.sum}`);\n            lines.push(`${this.#prefix}_${key}_count ${data.count}`);\n        }\n\n        return lines.join('\\n');\n    }\n\n    /**\n     * Exports all metrics as JSON.\n     * @returns {Object}\n     */\n    toJSON() {\n        const counters = {};\n        for (const [key, value] of this.#counters) {\n            counters[key] = value;\n        }\n\n        const gauges = {};\n        for (const [key, value] of this.#gauges) {\n            gauges[key] = value;\n        }\n\n        const histograms = {};\n        for (const [key, histogram] of this.#histograms) {\n            histograms[key] = histogram.getData();\n        }\n\n        return {\n            exportedAt: new Date().toISOString(),\n            prefix: this.#prefix,\n            counters,\n            gauges,\n            histograms\n        };\n    }\n\n    /**\n     * Resets all metrics.\n     */\n    reset() {\n        this.#counters.clear();\n        this.#gauges.clear();\n        for (const histogram of this.#histograms.values()) {\n            histogram.reset();\n        }\n        this.#requestStarts.clear();\n    }\n\n    // ─────────────────────────────────────────────────────────────────\n    // Private helpers\n    // ─────────────────────────────────────────────────────────────────\n\n    /**\n     * Creates a unique key from name and labels.\n     */\n    #makeKey(name, labels) {\n        if (Object.keys(labels).length === 0) {\n            return name;\n        }\n        const labelStr = Object.entries(labels)\n            .sort(([a], [b]) => a.localeCompare(b))\n            .map(([k, v]) => `${k}=\"${v}\"`)\n            .join(',');\n        return `${name}{${labelStr}}`;\n    }\n\n    /**\n     * Emits a metric event.\n     */\n    #emit(event) {\n        for (const listener of this.#listeners) {\n            try {\n                listener(event);\n            } catch (e) {\n                console.error('[Metrics] Listener error:', e);\n            }\n        }\n    }\n}\n\n/**\n * Default global metrics instance.\n */\nexport const globalMetrics = new Metrics();\n","/**\n * @fileoverview Backpressure and flow control for CrossBus.\n * Prevents slow receivers from causing memory issues.\n * @module enterprise/backpressure\n */\n\n/**\n * @typedef {'drop-oldest'|'drop-newest'|'reject'|'pause'} BackpressureStrategy\n */\n\n/**\n * @typedef {Object} QueueStats\n * @property {number} size - Current queue size\n * @property {number} maxSize - Maximum queue size\n * @property {number} dropped - Messages dropped\n * @property {number} processed - Messages processed\n * @property {boolean} isPaused - Whether queue is paused\n */\n\n/**\n * Per-peer message queue with backpressure support.\n */\nclass PeerQueue {\n    /** @type {Object[]} */\n    #queue = [];\n\n    /** @type {number} */\n    #maxSize;\n\n    /** @type {BackpressureStrategy} */\n    #strategy;\n\n    /** @type {number} */\n    #dropped = 0;\n\n    /** @type {number} */\n    #processed = 0;\n\n    /** @type {boolean} */\n    #paused = false;\n\n    /** @type {((message: Object) => void)|null} */\n    #sendFn = null;\n\n    /** @type {string} */\n    // #peerId;\n\n    /**\n     * @param {string} peerId - Peer ID\n     * @param {Object} options - Queue options\n     * @param {number} options.maxSize - Maximum queue size\n     * @param {BackpressureStrategy} options.strategy - Backpressure strategy\n     */\n    constructor(peerId, options) {\n        // this.#peerId = peerId;\n        this.#maxSize = options.maxSize;\n        this.#strategy = options.strategy;\n    }\n\n    /**\n     * Sets the send function.\n     * @param {(message: Object) => void} sendFn\n     */\n    setSendFn(sendFn) {\n        this.#sendFn = sendFn;\n    }\n\n    /**\n     * Enqueues a message.\n     * @param {Object} message - Message to enqueue\n     * @returns {{ success: boolean, queued: boolean, dropped: boolean }}\n     */\n    enqueue(message) {\n        // If not paused and queue is empty, send immediately\n        if (!this.#paused && this.#queue.length === 0 && this.#sendFn) {\n            try {\n                this.#sendFn(message);\n                this.#processed++;\n                return { success: true, queued: false, dropped: false };\n            } catch {\n                // Send failed, queue the message\n            }\n        }\n\n        // Check if queue is full\n        if (this.#queue.length >= this.#maxSize) {\n            return this.#handleBackpressure(message);\n        }\n\n        // Add to queue\n        this.#queue.push(message);\n        return { success: true, queued: true, dropped: false };\n    }\n\n    /**\n     * Handles backpressure when queue is full.\n     */\n    #handleBackpressure(message) {\n        switch (this.#strategy) {\n            case 'drop-oldest':\n                this.#queue.shift();\n                this.#queue.push(message);\n                this.#dropped++;\n                return { success: true, queued: true, dropped: true };\n\n            case 'drop-newest':\n                this.#dropped++;\n                return { success: false, queued: false, dropped: true };\n\n            case 'reject':\n                return { success: false, queued: false, dropped: false };\n\n            case 'pause':\n                this.#paused = true;\n                return { success: false, queued: false, dropped: false };\n\n            default:\n                return { success: false, queued: false, dropped: false };\n        }\n    }\n\n    /**\n     * Processes queued messages.\n     * @param {number} [count] - Max messages to process (default: all)\n     * @returns {number} Number of messages processed\n     */\n    flush(count) {\n        if (!this.#sendFn) return 0;\n\n        const toProcess = count ?? this.#queue.length;\n        let processed = 0;\n\n        for (let i = 0; i < toProcess && this.#queue.length > 0; i++) {\n            const message = this.#queue.shift();\n            try {\n                this.#sendFn(message);\n                processed++;\n                this.#processed++;\n            } catch {\n                // Put back at front of queue\n                this.#queue.unshift(message);\n                break;\n            }\n        }\n\n        return processed;\n    }\n\n    /**\n     * Resumes a paused queue.\n     */\n    resume() {\n        this.#paused = false;\n        this.flush();\n    }\n\n    /**\n     * Pauses the queue.\n     */\n    pause() {\n        this.#paused = true;\n    }\n\n    /**\n     * Clears the queue.\n     */\n    clear() {\n        this.#queue = [];\n    }\n\n    /**\n     * Gets queue statistics.\n     * @returns {QueueStats}\n     */\n    getStats() {\n        return {\n            size: this.#queue.length,\n            maxSize: this.#maxSize,\n            dropped: this.#dropped,\n            processed: this.#processed,\n            isPaused: this.#paused\n        };\n    }\n}\n\n/**\n * Backpressure controller for CrossBus.\n * Manages per-peer message queues with configurable strategies.\n * \n * @example\n * const bp = new BackpressureController({\n *   maxQueueSize: 100,\n *   strategy: 'drop-oldest'\n * });\n * \n * // Wrap peer send functions\n * const wrappedSend = bp.wrap('widget-1', originalSendFn);\n * \n * // Check if peer is slow\n * if (bp.getStats('widget-1').size > 50) {\n *   console.warn('widget-1 is falling behind');\n * }\n */\nexport class BackpressureController {\n    /** @type {Map<string, PeerQueue>} */\n    #queues = new Map();\n\n    /** @type {number} */\n    #defaultMaxSize;\n\n    /** @type {BackpressureStrategy} */\n    #defaultStrategy;\n\n    /** @type {((peerId: string, stats: QueueStats) => void)[]} */\n    #backpressureListeners = [];\n\n    /** @type {number} */\n    #checkInterval;\n\n    /** @type {ReturnType<typeof setInterval>|null} */\n    #intervalId = null;\n\n    /**\n     * Creates a new backpressure controller.\n     * @param {Object} [options={}] - Options\n     * @param {number} [options.maxQueueSize=100] - Default max queue size\n     * @param {BackpressureStrategy} [options.strategy='drop-oldest'] - Default strategy\n     * @param {number} [options.checkIntervalMs=1000] - Interval to check queues\n     */\n    constructor(options = {}) {\n        this.#defaultMaxSize = options.maxQueueSize ?? 100;\n        this.#defaultStrategy = options.strategy ?? 'drop-oldest';\n        this.#checkInterval = options.checkIntervalMs ?? 1000;\n    }\n\n    /**\n     * Wraps a peer's send function with backpressure control.\n     * @param {string} peerId - Peer ID\n     * @param {(message: Object) => void} sendFn - Original send function\n     * @param {Object} [options={}] - Per-peer options\n     * @param {number} [options.maxQueueSize] - Max queue size for this peer\n     * @param {BackpressureStrategy} [options.strategy] - Strategy for this peer\n     * @returns {(message: Object) => { success: boolean, queued: boolean, dropped: boolean }}\n     */\n    wrap(peerId, sendFn, options = {}) {\n        const queue = new PeerQueue(peerId, {\n            maxSize: options.maxQueueSize ?? this.#defaultMaxSize,\n            strategy: options.strategy ?? this.#defaultStrategy\n        });\n        queue.setSendFn(sendFn);\n        this.#queues.set(peerId, queue);\n\n        this.#startMonitoring();\n\n        return (message) => queue.enqueue(message);\n    }\n\n    /**\n     * Configures backpressure for a specific peer.\n     * @param {string} peerId - Peer ID\n     * @param {Object} options - Options\n     */\n    configure(peerId, options) {\n        let queue = this.#queues.get(peerId);\n        if (!queue) {\n            queue = new PeerQueue(peerId, {\n                maxSize: options.maxQueueSize ?? this.#defaultMaxSize,\n                strategy: options.strategy ?? this.#defaultStrategy\n            });\n            this.#queues.set(peerId, queue);\n        }\n    }\n\n    /**\n     * Flushes queued messages for a peer.\n     * @param {string} peerId - Peer ID\n     * @param {number} [count] - Max messages to flush\n     * @returns {number} Messages processed\n     */\n    flush(peerId, count) {\n        return this.#queues.get(peerId)?.flush(count) ?? 0;\n    }\n\n    /**\n     * Flushes all queues.\n     * @returns {number} Total messages processed\n     */\n    flushAll() {\n        let total = 0;\n        for (const queue of this.#queues.values()) {\n            total += queue.flush();\n        }\n        return total;\n    }\n\n    /**\n     * Pauses a peer's queue.\n     * @param {string} peerId - Peer ID\n     */\n    pause(peerId) {\n        this.#queues.get(peerId)?.pause();\n    }\n\n    /**\n     * Resumes a peer's queue.\n     * @param {string} peerId - Peer ID\n     */\n    resume(peerId) {\n        this.#queues.get(peerId)?.resume();\n    }\n\n    /**\n     * Gets stats for a peer.\n     * @param {string} peerId - Peer ID\n     * @returns {QueueStats|null}\n     */\n    getStats(peerId) {\n        return this.#queues.get(peerId)?.getStats() ?? null;\n    }\n\n    /**\n     * Gets stats for all peers.\n     * @returns {Object<string, QueueStats>}\n     */\n    getAllStats() {\n        /** @type {Object<string, QueueStats>} */\n        const stats = {};\n        for (const [peerId, queue] of this.#queues) {\n            stats[peerId] = queue.getStats();\n        }\n        return stats;\n    }\n\n    /**\n     * Subscribes to backpressure events.\n     * @param {(peerId: string, stats: QueueStats) => void} callback\n     * @returns {() => void} Unsubscribe function\n     */\n    onBackpressure(callback) {\n        this.#backpressureListeners.push(callback);\n        return () => {\n            const idx = this.#backpressureListeners.indexOf(callback);\n            if (idx !== -1) this.#backpressureListeners.splice(idx, 1);\n        };\n    }\n\n    /**\n     * Removes a peer's queue.\n     * @param {string} peerId - Peer ID\n     */\n    remove(peerId) {\n        const queue = this.#queues.get(peerId);\n        if (queue) {\n            queue.clear();\n            this.#queues.delete(peerId);\n        }\n    }\n\n    /**\n     * Clears all queues and stops monitoring.\n     */\n    destroy() {\n        if (this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = null;\n        }\n        for (const queue of this.#queues.values()) {\n            queue.clear();\n        }\n        this.#queues.clear();\n        this.#backpressureListeners = [];\n    }\n\n    /**\n     * Starts monitoring queues for backpressure.\n     */\n    #startMonitoring() {\n        if (this.#intervalId) return;\n\n        this.#intervalId = setInterval(() => {\n            for (const [peerId, queue] of this.#queues) {\n                const stats = queue.getStats();\n                // Notify if queue is over 50% full or paused\n                if (stats.size > stats.maxSize * 0.5 || stats.isPaused) {\n                    for (const listener of this.#backpressureListeners) {\n                        try {\n                            listener(peerId, stats);\n                        } catch (e) {\n                            console.error('[Backpressure] Listener error:', e);\n                        }\n                    }\n                }\n            }\n        }, this.#checkInterval);\n    }\n}\n","/**\n * @fileoverview Message versioning for CrossBus.\n * Supports schema evolution with migration functions.\n * @module enterprise/versioning\n */\n\n/**\n * @typedef {Object} VersionedMessage\n * @property {number} _v - Message version\n * @property {Object} payload - Message payload\n */\n\n/**\n * @typedef {(oldPayload: Object) => Object} MigrationFn\n */\n\n/**\n * Message versioning system for CrossBus.\n * Handles schema evolution with automatic migrations.\n * \n * @example\n * const versioning = new MessageVersioning();\n * \n * // Register migrations\n * versioning.registerMigration('user:updated', 1, 2, (old) => ({\n *   ...old,\n *   fullName: `${old.firstName} ${old.lastName}`\n * }));\n * \n * // Migrate a message\n * const migrated = versioning.migrate('user:updated', oldPayload, 1, 2);\n */\nexport class MessageVersioning {\n    /** @type {Map<string, Map<string, MigrationFn>>} Type -> \"from:to\" -> migrator */\n    #migrations = new Map();\n\n    /** @type {Map<string, number>} Type -> current version */\n    #currentVersions = new Map();\n\n    /** @type {number} */\n    #defaultVersion;\n\n    /**\n     * Creates a new versioning system.\n     * @param {Object} [options={}] - Options\n     * @param {number} [options.defaultVersion=1] - Default version for new messages\n     */\n    constructor(options = {}) {\n        this.#defaultVersion = options.defaultVersion ?? 1;\n    }\n\n    /**\n     * Registers a migration from one version to another.\n     * @param {string} type - Message type (e.g., 'user:updated')\n     * @param {number} fromVersion - Source version\n     * @param {number} toVersion - Target version\n     * @param {MigrationFn} migrateFn - Migration function\n     */\n    registerMigration(type, fromVersion, toVersion, migrateFn) {\n        if (!this.#migrations.has(type)) {\n            this.#migrations.set(type, new Map());\n        }\n        const typeMigrations = this.#migrations.get(type);\n        if (typeMigrations) {\n            typeMigrations.set(`${fromVersion}:${toVersion}`, migrateFn);\n        }\n    }\n\n    /**\n     * Sets the current version for a message type.\n     * @param {string} type - Message type\n     * @param {number} version - Current version\n     */\n    setCurrentVersion(type, version) {\n        this.#currentVersions.set(type, version);\n    }\n\n    /**\n     * Gets the current version for a message type.\n     * @param {string} type - Message type\n     * @returns {number}\n     */\n    getCurrentVersion(type) {\n        return this.#currentVersions.get(type) ?? this.#defaultVersion;\n    }\n\n    /**\n     * Migrates a payload from one version to another.\n     * @param {string} type - Message type\n     * @param {Object} payload - Payload to migrate\n     * @param {number} fromVersion - Source version\n     * @param {number} toVersion - Target version\n     * @returns {Object} Migrated payload\n     * @throws {Error} If no migration path exists\n     */\n    migrate(type, payload, fromVersion, toVersion) {\n        if (fromVersion === toVersion) {\n            return payload;\n        }\n\n        const migrations = this.#migrations.get(type);\n        if (!migrations) {\n            throw new Error(`No migrations registered for type: ${type}`);\n        }\n\n        // Find migration path\n        let current = payload;\n        let currentVersion = fromVersion;\n\n        while (currentVersion !== toVersion) {\n            const nextVersion = currentVersion < toVersion ? currentVersion + 1 : currentVersion - 1;\n            const key = `${currentVersion}:${nextVersion}`;\n            const migrateFn = migrations.get(key);\n\n            if (!migrateFn) {\n                throw new Error(`No migration path from v${currentVersion} to v${nextVersion} for type: ${type}`);\n            }\n\n            current = migrateFn(current);\n            currentVersion = nextVersion;\n        }\n\n        return current;\n    }\n\n    /**\n     * Checks if a message needs migration.\n     * @param {string} type - Message type\n     * @param {number} version - Message version\n     * @returns {boolean}\n     */\n    needsMigration(type, version) {\n        return version !== this.getCurrentVersion(type);\n    }\n\n    /**\n     * Creates a versioned message.\n     * @param {string} type - Message type\n     * @param {Object} payload - Message payload\n     * @param {number} [version] - Version (defaults to current)\n     * @returns {VersionedMessage}\n     */\n    createMessage(type, payload, version) {\n        return {\n            _v: version ?? this.getCurrentVersion(type),\n            ...payload\n        };\n    }\n\n    /**\n     * Extracts version from a message.\n     * @param {Object} message - Message\n     * @returns {number}\n     */\n    getVersion(message) {\n        return message?._v ?? this.#defaultVersion;\n    }\n\n    /**\n     * Creates a CrossBus hook for automatic version migration.\n     * @returns {(payload: Object, context: Object) => Object}\n     */\n    createInboundHook() {\n        return (payload, context) => {\n            if (!payload || typeof payload !== 'object') {\n                return payload;\n            }\n\n            const version = this.getVersion(payload);\n            const type = context.handlerName || context.type;\n            const currentVersion = this.getCurrentVersion(type);\n\n            if (version !== currentVersion && this.#migrations.has(type)) {\n                try {\n                    const { _v, ...rest } = payload;\n                    const migrated = this.migrate(type, rest, version, currentVersion);\n                    return { _v: currentVersion, ...migrated };\n                } catch (e) {\n                    console.warn(`[Versioning] Migration failed for ${type}: ${e instanceof Error ? e.message : String(e)}`);\n                    return payload;\n                }\n            }\n\n            return payload;\n        };\n    }\n\n    /**\n     * Creates a CrossBus hook for automatic version stamping.\n     * @returns {(payload: Object, context: Object) => Object}\n     */\n    createOutboundHook() {\n        return (payload, context) => {\n            if (!payload || typeof payload !== 'object') {\n                return payload;\n            }\n\n            // Don't overwrite existing version\n            if (payload._v !== undefined) {\n                return payload;\n            }\n\n            const type = context.handlerName || context.type;\n            const version = this.getCurrentVersion(type);\n\n            return { _v: version, ...payload };\n        };\n    }\n\n    /**\n     * Gets all registered migrations.\n     * @returns {Object}\n     */\n    getMigrations() {\n        const result = {};\n        for (const [type, migrations] of this.#migrations) {\n            result[type] = Array.from(migrations.keys());\n        }\n        return result;\n    }\n\n    /**\n     * Clears all migrations.\n     */\n    clear() {\n        this.#migrations.clear();\n        this.#currentVersions.clear();\n    }\n}\n\n/**\n * Default global versioning instance.\n */\nexport const globalVersioning = new MessageVersioning();\n"],"names":["uuid","crypto","randomUUID","replace","c","r","Math","random","toString","tracingPlugin","tracer","payload","context","span","startSpan","type","handlerName","attributes","peerId","tracedPayload","_trace","toTraceparent","end","startSpanFromTraceparent","setAttributes","t","cleanPayload","Span","name","startTime","endTime","status","statusMessage","events","constructor","this","Date","now","isEnded","setAttribute","key","value","Object","assign","addEvent","push","timestamp","setStatus","message","recordException","error","stack","_onSpanEnd","flags","traceFlags","padStart","traceId","spanId","toJSON","parentSpanId","duration","Tracer","serviceName","traces","Map","completedSpans","maxSpans","sampled","spanEndCallbacks","options","parent","generateTraceId","generateSpanId","has","set","traceSpans","get","traceparent","parseTraceparent","parts","split","length","version","parseInt","getTrace","getCompletedSpans","exportTraces","spans","exportedAt","toISOString","spanCount","map","s","clear","onSpanEnd","callback","idx","indexOf","splice","shift","cb","e","slice","globalTracer","Histogram","boundaries","buckets","sum","count","sort","a","b","Array","fill","observe","i","getData","le","Infinity","percentile","p","target","cumulative","reset","Metrics","counters","histograms","gauges","listeners","prefix","requestStarts","increment","labels","makeKey","current","emit","getCounter","histogram","getHistogram","getGauge","on","event","outboundHook","id","inboundHook","requestId","latencyMs","delete","toPrometheus","lines","data","bucket","join","values","keys","entries","localeCompare","k","v","listener","globalMetrics","PeerQueue","queue","maxSize","strategy","dropped","processed","paused","sendFn","setSendFn","enqueue","success","queued","handleBackpressure","flush","toProcess","unshift","resume","pause","getStats","size","isPaused","BackpressureController","queues","defaultMaxSize","defaultStrategy","backpressureListeners","checkInterval","intervalId","maxQueueSize","checkIntervalMs","wrap","startMonitoring","configure","flushAll","total","getAllStats","stats","onBackpressure","remove","destroy","clearInterval","setInterval","MessageVersioning","migrations","currentVersions","defaultVersion","registerMigration","fromVersion","toVersion","migrateFn","typeMigrations","setCurrentVersion","getCurrentVersion","migrate","Error","currentVersion","nextVersion","needsMigration","createMessage","_v","getVersion","createInboundHook","h","rest","createOutboundHook","undefined","getMigrations","result","from","globalVersioning"],"mappings":"AAWO,SAASA,IACZ,MAAsB,oBAAXC,QAA0BA,OAAOC,WACjCD,OAAOC,aAGX,uCAAuCC,QAAQ,QAAUC,IAC5D,MAAMC,EAAoB,GAAhBC,KAAKC,SAAgB,EAE/B,OADgB,MAANH,EAAYC,EAAS,EAAJA,EAAU,GAC5BG,SAAS,KAE1B,CC4aO,SAASC,EAAcC,GAC1B,MAAO,CAIH,QAiBA,CAjBWC,EAASC,GAChB,MAAMC,EAAOH,EAAOI,UAAU,GAAGF,EAAQG,QAAQH,EAAQI,aAAe,WAAY,CAChFC,WAAY,CACR,gBAAiBL,EAAQG,KACzB,qBAAsB,WACtB,gBAAiBH,EAAQM,UAK3BC,EAAgB,IACfR,EACHS,EAAQP,EAAKQ,iBAIjB,OADAR,EAAKS,MACEH,GAMX,OAkBA,CAlBUR,EAASC,GACf,GAAID,GAAWA,EAAQS,EAAQ,CAC3B,MAAMP,EAAOH,EAAOa,yBAChB,GAAGX,EAAQG,QAAQH,EAAQI,aAAe,WAC1CL,EAAQS,GAEZP,EAAKW,cAAc,CACf,gBAAiBZ,EAAQG,KACzB,qBAAsB,UACtB,gBAAiBH,EAAQM,SAE7BL,EAAKS,MAGL,MAAMG,EAAEL,KAAWM,GAAiBf,EACpC,OAAOe,CACX,CACA,OAAOf,GAGnB,CAldO,MAAMgB,EAETf,GAGAgB,GAGAC,GAGAC,GAAW,KAGXC,GAAU,QAGVC,GAAiB,KAGjBC,GAAU,GAGVhB,GAAc,CAAA,EAGdP,GAOA,WAAAwB,CAAYxB,EAAQkB,EAAMhB,GACtBuB,MAAKzB,EAAUA,EACfyB,MAAKP,EAAQA,EACbO,MAAKvB,EAAWA,EAChBuB,MAAKN,EAAaO,KAAKC,KAC3B,CAGA,WAAIzB,GACA,OAAOuB,MAAKvB,CAChB,CAGA,QAAIgB,GACA,OAAOO,MAAKP,CAChB,CAGA,WAAIU,GACA,OAAyB,OAAlBH,MAAKL,CAChB,CAQA,YAAAS,CAAaC,EAAKC,GAId,OAHKN,KAAKG,UACNH,MAAKlB,EAAYuB,GAAOC,GAErBN,IACX,CAOA,aAAAX,CAAcP,GAIV,OAHKkB,KAAKG,SACNI,OAAOC,OAAOR,MAAKlB,EAAaA,GAE7BkB,IACX,CAQA,QAAAS,CAAShB,EAAMX,GAQX,OAPKkB,KAAKG,SACNH,MAAKF,EAAQY,KAAK,CACdjB,OACAkB,UAAWV,KAAKC,MAChBpB,eAGDkB,IACX,CAQA,SAAAY,CAAUhB,EAAQiB,GAKd,OAJKb,KAAKG,UACNH,MAAKJ,EAAUA,EACfI,MAAKH,EAAiBgB,GAAW,MAE9Bb,IACX,CAOA,eAAAc,CAAgBC,GAOZ,OANAf,KAAKS,SAAS,YAAa,CACvB,iBAAkBM,EAAMtB,KACxB,oBAAqBsB,EAAMF,QAC3B,uBAAwBE,EAAMC,QAElChB,KAAKY,UAAU,QAASG,EAAMF,SACvBb,IACX,CAKA,GAAAb,GACSa,KAAKG,UACNH,MAAKL,EAAWM,KAAKC,MACrBF,MAAKzB,EAAQ0C,EAAWjB,MAEhC,CAMA,aAAAd,GACI,MACMgC,EAAQlB,MAAKvB,EAAS0C,WAAW9C,SAAS,IAAI+C,SAAS,EAAG,KAChE,MAAO,MAAcpB,MAAKvB,EAAS4C,WAAWrB,MAAKvB,EAAS6C,UAAUJ,GAC1E,CAMA,MAAAK,GACI,MAAO,CACHF,QAASrB,MAAKvB,EAAS4C,QACvBC,OAAQtB,MAAKvB,EAAS6C,OACtBE,aAAcxB,MAAKvB,EAAS+C,aAC5B/B,KAAMO,MAAKP,EACXC,UAAWM,MAAKN,EAChBC,QAASK,MAAKL,EACd8B,SAAUzB,MAAKL,EAAWK,MAAKL,EAAWK,MAAKN,EAAa,KAC5DE,OAAQI,MAAKJ,EACbC,cAAeG,MAAKH,EACpBf,WAAY,IAAKkB,MAAKlB,GACtBgB,OAAQ,IAAIE,MAAKF,GAEzB,EAsBG,MAAM4B,EAETC,GAGAC,GAAU,IAAIC,IAGdC,GAAkB,GAGlBC,GAGAC,GAGAC,GAAoB,GASpB,WAAAlC,CAAY4B,EAAc,WAAYO,EAAU,CAAA,GAC5ClC,MAAK2B,EAAeA,EACpB3B,MAAK+B,EAAYG,EAAQH,UAAY,IACrC/B,MAAKgC,EAAWE,EAAQF,UAAW,CACvC,CAUA,SAAArD,CAAUc,EAAMyC,EAAU,IACtB,MAAMC,EAASD,EAAQC,OAEjB1D,EAAU,CACZ4C,QAASc,GAAQ1D,QAAQ4C,SAAWrB,MAAKoC,IACzCd,OAAQtB,MAAKqC,IACbb,aAAcW,GAAQ1D,QAAQ6C,OAC9BH,WAAYnB,MAAKgC,EAAW,EAAI,GAG9BtD,EAAO,IAAIc,EAAKQ,KAAMP,EAAMhB,GAE9ByD,EAAQpD,YACRJ,EAAKW,cAAc6C,EAAQpD,YAI1BkB,MAAK4B,EAAQU,IAAI7D,EAAQ4C,UAC1BrB,MAAK4B,EAAQW,IAAI9D,EAAQ4C,QAAS,IAEtC,MAAMmB,EAAaxC,MAAK4B,EAAQa,IAAIhE,EAAQ4C,SAK5C,OAJImB,GACAA,EAAW9B,KAAKhC,GAGbA,CACX,CAQA,wBAAAU,CAAyBK,EAAMiD,GAC3B,MAAMjE,EAAUuB,KAAK2C,iBAAiBD,GACtC,IAAKjE,EACD,OAAOuB,KAAKrB,UAAUc,GAG1B,MAAMf,EAAO,IAAIc,EAAKQ,KAAMP,EAAM,CAC9B4B,QAAS5C,EAAQ4C,QACjBC,OAAQtB,MAAKqC,IACbb,aAAc/C,EAAQ6C,OACtBH,WAAY1C,EAAQ0C,aAGnBnB,MAAK4B,EAAQU,IAAI7D,EAAQ4C,UAC1BrB,MAAK4B,EAAQW,IAAI9D,EAAQ4C,QAAS,IAEtC,MAAMmB,EAAaxC,MAAK4B,EAAQa,IAAIhE,EAAQ4C,SAK5C,OAJImB,GACAA,EAAW9B,KAAKhC,GAGbA,CACX,CAOA,gBAAAiE,CAAiBD,GACb,IAAKA,GAAsC,iBAAhBA,EACvB,OAAO,KAGX,MAAME,EAAQF,EAAYG,MAAM,KAChC,GAAqB,IAAjBD,EAAME,OACN,OAAO,KAGX,MAAOC,EAAS1B,EAASC,EAAQJ,GAAS0B,EAG1C,MAAgB,OAAZG,GAAuC,KAAnB1B,EAAQyB,QAAmC,KAAlBxB,EAAOwB,OAC7C,KAGJ,CACHzB,UACAC,SACAH,WAAY6B,SAAS9B,EAAO,IAEpC,CAOA,QAAA+B,CAAS5B,GACL,OAAOrB,MAAK4B,EAAQa,IAAIpB,IAAY,EACxC,CAMA,iBAAA6B,GACI,MAAO,IAAIlD,MAAK8B,EACpB,CAQA,YAAAqB,CAAajB,EAAU,IACnB,MAAMkB,EAAQlB,EAAQb,QAChBrB,KAAKiD,SAASf,EAAQb,SACtBrB,MAAK8B,EAEX,MAAO,CACHH,YAAa3B,MAAK2B,EAClB0B,YAAY,IAAIpD,MAAOqD,cACvBC,UAAWH,EAAMN,OACjBM,MAAOA,EAAMI,IAAIC,GAAKA,EAAElC,UAEhC,CAKA,KAAAmC,GACI1D,MAAK4B,EAAQ8B,QACb1D,MAAK8B,EAAkB,EAC3B,CAOA,SAAA6B,CAAUC,GAEN,OADA5D,MAAKiC,EAAkBvB,KAAKkD,GACrB,KACH,MAAMC,EAAM7D,MAAKiC,EAAkB6B,QAAQF,IAC/B,IAARC,GAAY7D,MAAKiC,EAAkB8B,OAAOF,EAAK,GAE3D,CAMA,CAAA5C,CAAWvC,GACPsB,MAAK8B,EAAgBpB,KAAKhC,GAGtBsB,MAAK8B,EAAgBgB,OAAS9C,MAAK+B,GACnC/B,MAAK8B,EAAgBkC,QAIzB,IAAK,MAAMC,KAAMjE,MAAKiC,EAClB,IACIgC,EAAGvF,EACP,CAAE,MAAOwF,GAET,CAER,CAMA,EAAA9B,GACI,OAAOvE,IAAOG,QAAQ,KAAM,GAChC,CAMA,EAAAqE,GACI,OAAOxE,IAAOG,QAAQ,KAAM,IAAImG,MAAM,EAAG,GAC7C,EAiEQ,MAACC,EAAe,IAAI1C,EAAO,YC7dvC,MAAM2C,EAEFC,GAGAC,GAGAC,GAAO,EAGPC,GAAS,EAKT,WAAA1E,CAAYuE,EAAa,CAAC,KAAO,KAAO,IAAM,KAAO,IAAM,GAAK,IAAM,GAAK,EAAG,IAAK,EAAG,KAClFtE,MAAKsE,EAAc,IAAIA,GAAYI,KAAK,CAACC,EAAGC,IAAMD,EAAIC,GACtD5E,MAAKuE,EAAW,IAAIM,MAAM7E,MAAKsE,EAAYxB,OAAS,GAAGgC,KAAK,EAChE,CAMA,OAAAC,CAAQzE,GACJN,MAAKwE,GAAQlE,EACbN,MAAKyE,IAGL,IAAK,IAAIO,EAAI,EAAGA,EAAIhF,MAAKsE,EAAYxB,OAAQkC,IACzC,GAAI1E,GAASN,MAAKsE,EAAYU,GAE1B,YADAhF,MAAKuE,EAASS,KAKtBhF,MAAKuE,EAASvE,MAAKuE,EAASzB,OAAS,IACzC,CAKA,OAAAmC,GACI,MAAMV,EAAUvE,MAAKsE,EAAYd,IAAI,CAAC0B,EAAIF,KAAC,CACvCE,KACAT,MAAOzE,MAAKuE,EAASS,MAIzB,OAFAT,EAAQ7D,KAAK,CAAEwE,GAAIC,IAAUV,MAAOzE,MAAKuE,EAASvE,MAAKuE,EAASzB,OAAS,KAElE,CACHyB,UACAC,IAAKxE,MAAKwE,EACVC,MAAOzE,MAAKyE,EAEpB,CAMA,UAAAW,CAAWC,GACP,GAAoB,IAAhBrF,MAAKyE,EAAc,OAAO,EAE9B,MAAMa,EAASD,EAAIrF,MAAKyE,EACxB,IAAIc,EAAa,EAEjB,IAAK,IAAIP,EAAI,EAAGA,EAAIhF,MAAKuE,EAASzB,OAAQkC,IAEtC,GADAO,GAAcvF,MAAKuE,EAASS,GACxBO,GAAcD,EACd,OAAON,EAAIhF,MAAKsE,EAAYxB,OAAS9C,MAAKsE,EAAYU,GAAKG,IAGnE,OAAOA,GACX,CAEA,KAAAK,GACIxF,MAAKuE,EAASO,KAAK,GACnB9E,MAAKwE,EAAO,EACZxE,MAAKyE,EAAS,CAClB,EAkBG,MAAMgB,EAETC,GAAY,IAAI7D,IAGhB8D,GAAc,IAAI9D,IAGlB+D,GAAU,IAAI/D,IAGdgE,GAAa,GAGbC,GAGAC,GAAiB,IAAIlE,IAOrB,WAAA9B,CAAYmC,EAAU,IAClBlC,MAAK8F,EAAU5D,EAAQ4D,QAAU,WAGjC9F,MAAK2F,EAAYpD,IAAI,UAAW,IAAI8B,EACxC,CAYA,SAAA2B,CAAUvG,EAAMa,EAAQ,EAAG2F,EAAS,CAAA,GAChC,MAAM5F,EAAML,MAAKkG,EAASzG,EAAMwG,GAC1BE,EAAUnG,MAAK0F,EAAUjD,IAAIpC,IAAQ,EAC3CL,MAAK0F,EAAUnD,IAAIlC,EAAK8F,EAAU7F,GAElCN,MAAKoG,EAAM,CACP3G,KAAM,GAAGO,MAAK8F,KAAWrG,IACzBb,KAAM,UACN0B,MAAO6F,EAAU7F,EACjB2F,SACAtF,UAAWV,KAAKC,OAExB,CAQA,UAAAmG,CAAW5G,EAAMwG,EAAS,IACtB,OAAOjG,MAAK0F,EAAUjD,IAAIzC,MAAKkG,EAASzG,EAAMwG,KAAY,CAC9D,CAYA,OAAAlB,CAAQtF,EAAMa,EAAO2F,EAAS,CAAA,GAC1B,MAAM5F,EAAML,MAAKkG,EAASzG,EAAMwG,GAC3BjG,MAAK2F,EAAYrD,IAAIjC,IACtBL,MAAK2F,EAAYpD,IAAIlC,EAAK,IAAIgE,GAElC,MAAMiC,EAAYtG,MAAK2F,EAAYlD,IAAIpC,GACnCiG,GACAA,EAAUvB,QAAQzE,GAGtBN,MAAKoG,EAAM,CACP3G,KAAM,GAAGO,MAAK8F,KAAWrG,IACzBb,KAAM,YACN0B,QACA2F,SACAtF,UAAWV,KAAKC,OAExB,CAOA,YAAAqG,CAAa9G,EAAMwG,EAAS,IACxB,MAAMK,EAAYtG,MAAK2F,EAAYlD,IAAIzC,MAAKkG,EAASzG,EAAMwG,IAC3D,OAAOK,GAAWrB,WAAa,CAAEV,QAAS,GAAIC,IAAK,EAAGC,MAAO,EACjE,CAYA,GAAAlC,CAAI9C,EAAMa,EAAO2F,EAAS,CAAA,GACtB,MAAM5F,EAAML,MAAKkG,EAASzG,EAAMwG,GAChCjG,MAAK4F,EAAQrD,IAAIlC,EAAKC,GAEtBN,MAAKoG,EAAM,CACP3G,KAAM,GAAGO,MAAK8F,KAAWrG,IACzBb,KAAM,QACN0B,QACA2F,SACAtF,UAAWV,KAAKC,OAExB,CAQA,QAAAsG,CAAS/G,EAAMwG,EAAS,IACpB,OAAOjG,MAAK4F,EAAQnD,IAAIzC,MAAKkG,EAASzG,EAAMwG,KAAY,CAC5D,CAYA,EAAAQ,CAAGC,EAAO9C,GACN,MAAc,WAAV8C,GACA1G,MAAK6F,EAAWnF,KAAKkD,GACd,KACH,MAAMC,EAAM7D,MAAK6F,EAAW/B,QAAQF,IACxB,IAARC,GAAY7D,MAAK6F,EAAW9B,OAAOF,EAAK,KAG7C,MACX,CAUA,gBAAI8C,GACA,MAAO,CAACnI,EAASC,KACbuB,KAAKgG,UAAU,sBAAuB,EAAG,CAAEpH,KAAMH,EAAQG,OAGpC,YAAjBH,EAAQG,MAAsBJ,GAASoI,IACvC5G,MAAK+F,EAAexD,IAAI/D,EAAQoI,GAAI3G,KAAKC,OAGtC1B,EAEf,CAMA,eAAIqI,GACA,MAAO,CAACrI,EAASC,KAIb,GAHAuB,KAAKgG,UAAU,0BAA2B,EAAG,CAAEpH,KAAMH,EAAQG,OAGxC,aAAjBH,EAAQG,MAAuBJ,GAASsI,UAAW,CACnD,MAAMpH,EAAYM,MAAK+F,EAAetD,IAAIjE,EAAQsI,WAClD,GAAIpH,EAAW,CACX,MAAMqH,EAAY9G,KAAKC,MAAQR,EAC/BM,KAAK+E,QAAQ,kBAAmBgC,EAAY,KAC5C/G,MAAK+F,EAAeiB,OAAOxI,EAAQsI,UACvC,CACJ,CAEA,OAAOtI,EAEf,CAUA,YAAAyI,GACI,MAAMC,EAAQ,GAGd,IAAK,MAAO7G,EAAKC,KAAUN,MAAK0F,EAC5BwB,EAAMxG,KAAK,GAAGV,MAAK8F,KAAWzF,KAAOC,KAIzC,IAAK,MAAOD,EAAKC,KAAUN,MAAK4F,EAC5BsB,EAAMxG,KAAK,GAAGV,MAAK8F,KAAWzF,KAAOC,KAIzC,IAAK,MAAOD,EAAKiG,KAActG,MAAK2F,EAAa,CAC7C,MAAMwB,EAAOb,EAAUrB,UACvB,IAAK,MAAMmC,KAAUD,EAAK5C,QAEtB2C,EAAMxG,KAAK,GAAGV,MAAK8F,KAAWzF,gBADnB+G,EAAOlC,KAAOC,IAAW,OAASiC,EAAOlC,QACIkC,EAAO3C,SAEnEyC,EAAMxG,KAAK,GAAGV,MAAK8F,KAAWzF,SAAW8G,EAAK3C,OAC9C0C,EAAMxG,KAAK,GAAGV,MAAK8F,KAAWzF,WAAa8G,EAAK1C,QACpD,CAEA,OAAOyC,EAAMG,KAAK,KACtB,CAMA,MAAA9F,GACI,MAAMmE,EAAW,CAAA,EACjB,IAAK,MAAOrF,EAAKC,KAAUN,MAAK0F,EAC5BA,EAASrF,GAAOC,EAGpB,MAAMsF,EAAS,CAAA,EACf,IAAK,MAAOvF,EAAKC,KAAUN,MAAK4F,EAC5BA,EAAOvF,GAAOC,EAGlB,MAAMqF,EAAa,CAAA,EACnB,IAAK,MAAOtF,EAAKiG,KAActG,MAAK2F,EAChCA,EAAWtF,GAAOiG,EAAUrB,UAGhC,MAAO,CACH5B,YAAY,IAAIpD,MAAOqD,cACvBwC,OAAQ9F,MAAK8F,EACbJ,WACAE,SACAD,aAER,CAKA,KAAAH,GACIxF,MAAK0F,EAAUhC,QACf1D,MAAK4F,EAAQlC,QACb,IAAK,MAAM4C,KAAatG,MAAK2F,EAAY2B,SACrChB,EAAUd,QAEdxF,MAAK+F,EAAerC,OACxB,CASA,EAAAwC,CAASzG,EAAMwG,GACX,OAAmC,IAA/B1F,OAAOgH,KAAKtB,GAAQnD,OACbrD,EAMJ,GAAGA,KAJOc,OAAOiH,QAAQvB,GAC3BvB,KAAK,EAAEC,IAAKC,KAAOD,EAAE8C,cAAc7C,IACnCpB,IAAI,EAAEkE,EAAGC,KAAO,GAAGD,MAAMC,MACzBN,KAAK,OAEd,CAKA,EAAAjB,CAAMM,GACF,IAAK,MAAMkB,KAAY5H,MAAK6F,EACxB,IACI+B,EAASlB,EACb,CAAE,MAAOxC,GAET,CAER,EAMQ,MAAC2D,EAAgB,IAAIpC,EC5ZjC,MAAMqC,EAEFC,GAAS,GAGTC,GAGAC,GAGAC,GAAW,EAGXC,GAAa,EAGbC,IAAU,EAGVC,GAAU,KAWV,WAAAtI,CAAYhB,EAAQmD,GAEhBlC,MAAKgI,EAAW9F,EAAQ8F,QACxBhI,MAAKiI,EAAY/F,EAAQ+F,QAC7B,CAMA,SAAAK,CAAUD,GACNrI,MAAKqI,EAAUA,CACnB,CAOA,OAAAE,CAAQ1H,GAEJ,IAAKb,MAAKoI,GAAkC,IAAvBpI,MAAK+H,EAAOjF,QAAgB9C,MAAKqI,EAClD,IAGI,OAFArI,MAAKqI,EAAQxH,GACbb,MAAKmI,IACE,CAAEK,SAAS,EAAMC,QAAQ,EAAOP,SAAS,EACpD,CAAE,MAEF,CAIJ,OAAIlI,MAAK+H,EAAOjF,QAAU9C,MAAKgI,EACpBhI,MAAK0I,EAAoB7H,IAIpCb,MAAK+H,EAAOrH,KAAKG,GACV,CAAE2H,SAAS,EAAMC,QAAQ,EAAMP,SAAS,GACnD,CAKA,EAAAQ,CAAoB7H,GAChB,OAAQb,MAAKiI,GACT,IAAK,cAID,OAHAjI,MAAK+H,EAAO/D,QACZhE,MAAK+H,EAAOrH,KAAKG,GACjBb,MAAKkI,IACE,CAAEM,SAAS,EAAMC,QAAQ,EAAMP,SAAS,GAEnD,IAAK,cAED,OADAlI,MAAKkI,IACE,CAAEM,SAAS,EAAOC,QAAQ,EAAOP,SAAS,GAErD,IAAK,SAOL,QACI,MAAO,CAAEM,SAAS,EAAOC,QAAQ,EAAOP,SAAS,GALrD,IAAK,QAED,OADAlI,MAAKoI,GAAU,EACR,CAAEI,SAAS,EAAOC,QAAQ,EAAOP,SAAS,GAK7D,CAOA,KAAAS,CAAMlE,GACF,IAAKzE,MAAKqI,EAAS,OAAO,EAE1B,MAAMO,EAAYnE,GAASzE,MAAK+H,EAAOjF,OACvC,IAAIqF,EAAY,EAEhB,IAAK,IAAInD,EAAI,EAAGA,EAAI4D,GAAa5I,MAAK+H,EAAOjF,OAAS,EAAGkC,IAAK,CAC1D,MAAMnE,EAAUb,MAAK+H,EAAO/D,QAC5B,IACIhE,MAAKqI,EAAQxH,GACbsH,IACAnI,MAAKmI,GACT,CAAE,MAEEnI,MAAK+H,EAAOc,QAAQhI,GACpB,KACJ,CACJ,CAEA,OAAOsH,CACX,CAKA,MAAAW,GACI9I,MAAKoI,GAAU,EACfpI,KAAK2I,OACT,CAKA,KAAAI,GACI/I,MAAKoI,GAAU,CACnB,CAKA,KAAA1E,GACI1D,MAAK+H,EAAS,EAClB,CAMA,QAAAiB,GACI,MAAO,CACHC,KAAMjJ,MAAK+H,EAAOjF,OAClBkF,QAAShI,MAAKgI,EACdE,QAASlI,MAAKkI,EACdC,UAAWnI,MAAKmI,EAChBe,SAAUlJ,MAAKoI,EAEvB,EAqBG,MAAMe,EAETC,GAAU,IAAIvH,IAGdwH,GAGAC,GAGAC,GAAyB,GAGzBC,GAGAC,GAAc,KASd,WAAA1J,CAAYmC,EAAU,IAClBlC,MAAKqJ,EAAkBnH,EAAQwH,cAAgB,IAC/C1J,MAAKsJ,EAAmBpH,EAAQ+F,UAAY,cAC5CjI,MAAKwJ,EAAiBtH,EAAQyH,iBAAmB,GACrD,CAWA,IAAAC,CAAK7K,EAAQsJ,EAAQnG,EAAU,CAAA,GAC3B,MAAM6F,EAAQ,IAAID,EAAU/I,EAAQ,CAChCiJ,QAAS9F,EAAQwH,cAAgB1J,MAAKqJ,EACtCpB,SAAU/F,EAAQ+F,UAAYjI,MAAKsJ,IAOvC,OALAvB,EAAMO,UAAUD,GAChBrI,MAAKoJ,EAAQ7G,IAAIxD,EAAQgJ,GAEzB/H,MAAK6J,IAEGhJ,GAAYkH,EAAMQ,QAAQ1H,EACtC,CAOA,SAAAiJ,CAAU/K,EAAQmD,GACd,IAAI6F,EAAQ/H,MAAKoJ,EAAQ3G,IAAI1D,GACxBgJ,IACDA,EAAQ,IAAID,EAAU/I,EAAQ,CAC1BiJ,QAAS9F,EAAQwH,cAAgB1J,MAAKqJ,EACtCpB,SAAU/F,EAAQ+F,UAAYjI,MAAKsJ,IAEvCtJ,MAAKoJ,EAAQ7G,IAAIxD,EAAQgJ,GAEjC,CAQA,KAAAY,CAAM5J,EAAQ0F,GACV,OAAOzE,MAAKoJ,EAAQ3G,IAAI1D,IAAS4J,MAAMlE,IAAU,CACrD,CAMA,QAAAsF,GACI,IAAIC,EAAQ,EACZ,IAAK,MAAMjC,KAAS/H,MAAKoJ,EAAQ9B,SAC7B0C,GAASjC,EAAMY,QAEnB,OAAOqB,CACX,CAMA,KAAAjB,CAAMhK,GACFiB,MAAKoJ,EAAQ3G,IAAI1D,IAASgK,OAC9B,CAMA,MAAAD,CAAO/J,GACHiB,MAAKoJ,EAAQ3G,IAAI1D,IAAS+J,QAC9B,CAOA,QAAAE,CAASjK,GACL,OAAOiB,MAAKoJ,EAAQ3G,IAAI1D,IAASiK,YAAc,IACnD,CAMA,WAAAiB,GAEI,MAAMC,EAAQ,CAAA,EACd,IAAK,MAAOnL,EAAQgJ,KAAU/H,MAAKoJ,EAC/Bc,EAAMnL,GAAUgJ,EAAMiB,WAE1B,OAAOkB,CACX,CAOA,cAAAC,CAAevG,GAEX,OADA5D,MAAKuJ,EAAuB7I,KAAKkD,GAC1B,KACH,MAAMC,EAAM7D,MAAKuJ,EAAuBzF,QAAQF,IACpC,IAARC,GAAY7D,MAAKuJ,EAAuBxF,OAAOF,EAAK,GAEhE,CAMA,MAAAuG,CAAOrL,GACH,MAAMgJ,EAAQ/H,MAAKoJ,EAAQ3G,IAAI1D,GAC3BgJ,IACAA,EAAMrE,QACN1D,MAAKoJ,EAAQpC,OAAOjI,GAE5B,CAKA,OAAAsL,GACQrK,MAAKyJ,IACLa,cAActK,MAAKyJ,GACnBzJ,MAAKyJ,EAAc,MAEvB,IAAK,MAAM1B,KAAS/H,MAAKoJ,EAAQ9B,SAC7BS,EAAMrE,QAEV1D,MAAKoJ,EAAQ1F,QACb1D,MAAKuJ,EAAyB,EAClC,CAKA,EAAAM,GACQ7J,MAAKyJ,IAETzJ,MAAKyJ,EAAcc,YAAY,KAC3B,IAAK,MAAOxL,EAAQgJ,KAAU/H,MAAKoJ,EAAS,CACxC,MAAMc,EAAQnC,EAAMiB,WAEpB,GAAIkB,EAAMjB,KAAuB,GAAhBiB,EAAMlC,SAAiBkC,EAAMhB,SAC1C,IAAK,MAAMtB,KAAY5H,MAAKuJ,EACxB,IACI3B,EAAS7I,EAAQmL,EACrB,CAAE,MAAOhG,GAET,CAGZ,GACDlE,MAAKwJ,GACZ,EC1WG,MAAMgB,EAETC,GAAc,IAAI5I,IAGlB6I,GAAmB,IAAI7I,IAGvB8I,GAOA,WAAA5K,CAAYmC,EAAU,IAClBlC,MAAK2K,EAAkBzI,EAAQyI,gBAAkB,CACrD,CASA,iBAAAC,CAAkBhM,EAAMiM,EAAaC,EAAWC,GACvC/K,MAAKyK,EAAYnI,IAAI1D,IACtBoB,MAAKyK,EAAYlI,IAAI3D,EAAM,IAAIiD,KAEnC,MAAMmJ,EAAiBhL,MAAKyK,EAAYhI,IAAI7D,GACxCoM,GACAA,EAAezI,IAAI,GAAGsI,KAAeC,IAAaC,EAE1D,CAOA,iBAAAE,CAAkBrM,EAAMmE,GACpB/C,MAAK0K,EAAiBnI,IAAI3D,EAAMmE,EACpC,CAOA,iBAAAmI,CAAkBtM,GACd,OAAOoB,MAAK0K,EAAiBjI,IAAI7D,IAASoB,MAAK2K,CACnD,CAWA,OAAAQ,CAAQvM,EAAMJ,EAASqM,EAAaC,GAChC,GAAID,IAAgBC,EAChB,OAAOtM,EAGX,MAAMiM,EAAazK,MAAKyK,EAAYhI,IAAI7D,GACxC,IAAK6L,EACD,MAAM,IAAIW,MAAM,sCAAsCxM,KAI1D,IAAIuH,EAAU3H,EACV6M,EAAiBR,EAErB,KAAOQ,IAAmBP,GAAW,CACjC,MAAMQ,EAAcD,EAAiBP,EAAYO,EAAiB,EAAIA,EAAiB,EAEjFN,EAAYN,EAAWhI,IADjB,GAAG4I,KAAkBC,KAGjC,IAAKP,EACD,MAAM,IAAIK,MAAM,2BAA2BC,SAAsBC,eAAyB1M,KAG9FuH,EAAU4E,EAAU5E,GACpBkF,EAAiBC,CACrB,CAEA,OAAOnF,CACX,CAQA,cAAAoF,CAAe3M,EAAMmE,GACjB,OAAOA,IAAY/C,KAAKkL,kBAAkBtM,EAC9C,CASA,aAAA4M,CAAc5M,EAAMJ,EAASuE,GACzB,MAAO,CACH0I,EAAI1I,GAAW/C,KAAKkL,kBAAkBtM,MACnCJ,EAEX,CAOA,UAAAkN,CAAW7K,GACP,OAAOA,GAAS4K,GAAMzL,MAAK2K,CAC/B,CAMA,iBAAAgB,GACI,MAAO,CAACnN,EAASC,KACb,IAAKD,GAA8B,iBAAZA,EACnB,OAAOA,EAGX,MAAMuE,EAAU/C,KAAK0L,WAAWlN,GAC1BI,EAAOH,EAAQI,aAAeJ,EAAQG,KACtCyM,EAAiBrL,KAAKkL,kBAAkBtM,GAE9C,GAAImE,IAAYsI,GAAkBrL,MAAKyK,EAAYnI,IAAI1D,GACnD,IACI,MAAMgN,EAAEH,KAAOI,GAASrN,EAExB,MAAO,CAAEiN,EAAIJ,KADIrL,KAAKmL,QAAQvM,EAAMiN,EAAM9I,EAASsI,GAEvD,CAAE,MAAOnH,GAEL,OAAO1F,CACX,CAGJ,OAAOA,EAEf,CAMA,kBAAAsN,GACI,MAAO,CAACtN,EAASC,IACRD,GAA8B,iBAAZA,OAKJuN,IAAfvN,EAAQiN,EACDjN,EAMJ,CAAEiN,EAFOzL,KAAKkL,kBADRzM,EAAQI,aAAeJ,EAAQG,SAGnBJ,GAXdA,CAanB,CAMA,aAAAwN,GACI,MAAMC,EAAS,CAAA,EACf,IAAK,MAAOrN,EAAM6L,KAAezK,MAAKyK,EAClCwB,EAAOrN,GAAQiG,MAAMqH,KAAKzB,EAAWlD,QAEzC,OAAO0E,CACX,CAKA,KAAAvI,GACI1D,MAAKyK,EAAY/G,QACjB1D,MAAK0K,EAAiBhH,OAC1B,EAMQ,MAACyI,EAAmB,IAAI3B"}