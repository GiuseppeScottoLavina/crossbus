function e(e){return null!==e&&"object"==typeof e&&1===e[T]&&"string"==typeof e.id&&("string"==typeof e.type||"string"==typeof e.t)}function t(e,s=new Set){if(null==e)return Array.from(s);if((e=>e instanceof ArrayBuffer||e instanceof MessagePort||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!=typeof ReadableStream&&e instanceof ReadableStream||"undefined"!=typeof WritableStream&&e instanceof WritableStream||"undefined"!=typeof TransformStream&&e instanceof TransformStream)(e))return s.add(e),Array.from(s);if(Array.isArray(e))for(const r of e)t(r,s);else if("object"==typeof e)for(const r of Object.keys(e))t(e[r],s);return Array.from(s)}function s(e,t,s={},r=null){return Object.freeze({[T]:1,version:1,id:r||crypto.randomUUID(),type:e,timestamp:Date.now(),payload:Object.freeze({...t}),meta:Object.freeze({...s})})}function r(e,t,r,i=!0,n=null){return s(S.RESPONSE,{requestId:e,data:t,source:r,success:i,error:n})}function i(e){return e instanceof k}function n(e){return e instanceof k&&e.retryable}function o(){return"undefined"!=typeof crypto&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)})}function a(e){if(null==e)return!0;const t=typeof e;return"boolean"===t||"number"===t||"string"===t||"function"!==t&&"symbol"!==t&&!("undefined"!=typeof Node&&e instanceof Node)&&!(e instanceof WeakMap||e instanceof WeakSet)}function h(){if("function"==typeof Promise.withResolvers)return Promise.withResolvers();let e,t;return{promise:new Promise((s,r)=>{e=s,t=r}),resolve:e,reject:t}}function c(e,t){return new Promise((s,r)=>{if(t?.aborted)return void r(t.reason??new Error("Aborted"));const i=setTimeout(s,e);t&&t.addEventListener("abort",()=>{clearTimeout(i),r(t.reason??new Error("Aborted"))},{once:!0})})}function l(e,t,s="Operation timed out"){return Promise.race([e,new Promise((e,r)=>{setTimeout(()=>r(new Error(s)),t)})])}function u(e){return e instanceof MessagePort?"port":"undefined"!=typeof Worker&&e instanceof Worker?"worker":"undefined"!=typeof ServiceWorker&&e instanceof ServiceWorker?"sw":"undefined"!=typeof Window&&e instanceof Window?"window":"undefined"!=typeof HTMLIFrameElement&&e instanceof HTMLIFrameElement?"iframe":"undefined"!=typeof DedicatedWorkerGlobalScope&&e instanceof DedicatedWorkerGlobalScope?"worker":"unknown"}function d(){const e=Date.now();return Object.freeze({timestamp:e,iso:new Date(e).toISOString()})}function f(e,t={}){const s=new W(async t=>{await e.signal("__presence__",t)},{peerId:e.peerId,...t});return e.on("__presence__",(e,t)=>{s.handleMessage(e,t?.peerId??e.peerId)}),s}function g(e){return F.get(e)||B}const p=Symbol("listeners"),m=Symbol("subCounter"),y=Symbol("maxListeners"),w=Symbol("fastCache"),E=Object.freeze({peerId:"self",origin:void 0!==globalThis.location?globalThis.location.origin:"unknown",type:"local"});class b{constructor(){this[p]=new Map,this[m]=0,this[y]=10,this[w]=Object.create(null)}setMaxListeners(e){return this[y]=e,this}getMaxListeners(){return this[y]}on(e,t,s={}){if("string"!=typeof e)throw new TypeError("Signal name must be a string");if("function"!=typeof t)throw new TypeError("Handler must be a function");const r="sub_"+ ++this[m],i={id:r,handler:t,priority:s.priority??0,mode:s.mode??"async",once:s.once??!1,signal:s.signal??null};this[p].has(e)||this[p].set(e,[]);const n=this[p].get(e);if(0===n.length||i.priority<=n[n.length-1].priority)n.push(i);else{let e=0,t=n.length;for(;e<t;){const s=e+t>>>1;n[s].priority>=i.priority?e=s+1:t=s}n.splice(e,0,i)}this[w][e]=n.map(e=>e.handler);let o=!0;const a={id:r,signalName:e,get active(){return o},unsubscribe:()=>{o&&(this.#e(e,r),o=!1)}};return i.signal&&(i.signal.aborted?(this.#e(e,r),o=!1):i.signal.addEventListener("abort",()=>{a.unsubscribe()},{once:!0})),a}once(e,t,s={}){return this.on(e,t,{...s,once:!0})}onFast(e,t){return(this[w][e]||=[]).push(t),()=>{this[w][e]=this[w][e]?.filter(e=>e!==t)}}offFast(e,t){const s=this[w][e];if(s){const e=s.indexOf(t);-1!==e&&s.splice(e,1)}const r=this[p].get(e);if(r){const e=r.findIndex(e=>e.handler===t);-1!==e&&r.splice(e,1)}}off(e,t){if("string"!=typeof e)throw new TypeError("Signal name must be a string");const s=this[p].get(e);if(!s||0===s.length)return{success:!1,removedCount:0,remainingCount:0};let r=0;if(void 0===t)r=s.length,this[p].delete(e),delete this[w][e];else{const i=s.length,n=s.filter(e=>e.handler!==t);r=i-n.length,0===n.length?(this[p].delete(e),delete this[w][e]):(this[p].set(e,n),this[w][e]=n.map(e=>e.handler))}return{success:r>0,removedCount:r,remainingCount:this[p].get(e)?.length??0}}emitSync(e,t){const s=this[w][e];if(!s)return 0;const r=s.length;if(1===r)return s[0](t),1;if(2===r)return s[0](t),s[1](t),2;if(3===r)return s[0](t),s[1](t),s[2](t),3;if(4===r)return s[0](t),s[1](t),s[2](t),s[3](t),4;for(let e=0;e<r;e++)s[e](t);return r}async emit(e,t,s){if("string"!=typeof e)throw new TypeError("Signal name must be a string");const r=this[p].get(e),i=this[p].has("*");if(1===r?.length&&!i&&!s){const s=r[0],i={name:e,data:t,messageId:crypto.randomUUID(),timestamp:Date.now(),source:E};try{"sync"===s.mode?await s.handler(i):Promise.resolve().then(()=>s.handler(i))}catch(e){}return s.once&&this.#e(e,s.id),1}const n={name:e,data:t,messageId:crypto.randomUUID(),timestamp:Date.now(),source:s?{...E,...s}:E},o=this.#t(e),a=[];for(const{signalName:e,entry:t}of o){try{"sync"===t.mode?await t.handler(n):Promise.resolve().then(()=>t.handler(n))}catch(e){}t.once&&a.push({signalName:e,id:t.id})}for(const{signalName:e,id:t}of a)this.#e(e,t);return o.length}hasListeners(e){const t=this[p].get(e);return void 0!==t&&t.length>0}listenerCount(e){return this[p].get(e)?.length??0}getSignalNames(){return Array.from(this[p].keys())}clear(){this[p].clear();for(const e in this[w])delete this[w][e]}#t(e){const t=this[p].get(e),s=this[p].get("*");let r=null;const i=e.indexOf(":");if(i>0){const t=e.slice(0,i+1)+"*";r=this[p].get(t)}if(t&&!s&&!r)return t.map(t=>({signalName:e,entry:t}));const n=[t&&{signalName:e,entries:t},s&&{signalName:"*",entries:s},r&&{signalName:e.slice(0,i+1)+"*",entries:r}].filter(Boolean);if(0===n.length)return[];if(1===n.length)return n[0].entries.map(e=>({signalName:n[0].signalName,entry:e}));const o=[];for(const{signalName:e,entries:t}of n)for(const s of t)o.push({signalName:e,entry:s});return o.sort((e,t)=>t.entry.priority-e.entry.priority),o}#e(e,t){const s=this[p].get(e);if(!s)return;const r=s.filter(e=>e.id!==t);0===r.length?(this[p].delete(e),delete this[w][e]):(this[p].set(e,r),this[w][e]=r.map(e=>e.handler))}}const R=()=>({events:{},on(e,t){return(this.events[e]||=[]).push(t),()=>{this.events[e]=this.events[e]?.filter(e=>t!==e)}},emit(e,t){const s=this.events[e];if(!s)return;const r=s.length;if(1!==r){if(2===r)return s[0](t),void s[1](t);if(3===r)return s[0](t),s[1](t),void s[2](t);if(4===r)return s[0](t),s[1](t),s[2](t),void s[3](t);for(let e=0;e<r;e++)s[e](t)}else s[0](t)},off(e){e?delete this.events[e]:this.events={}}}),T="_cb",I=1,S=Object.freeze({SIGNAL:"sig",REQUEST:"req",RESPONSE:"res",ACK:"ack",HANDSHAKE:"hsk",HANDSHAKE_INIT:"hsk_init",HANDSHAKE_ACK:"hsk_ack",HANDSHAKE_COMPLETE:"hsk_done",PING:"png",PONG:"pog",BYE:"bye",BROADCAST:"bc"}),N=Object.freeze({INIT:"init",INIT_SENT:"init_sent",ACK:"ack",ACK_SENT:"ack_sent",DONE:"done"}),O=Object.freeze({CONNECTING:"connecting",CONNECTED:"connected",DISCONNECTED:"disconnected",RECONNECTING:"reconnecting",FAILED:"failed"}),A=Object.freeze({IFRAME:"iframe",WORKER:"worker",SERVICE_WORKER:"sw",WINDOW:"window",PORT:"port"}),_=Object.freeze({LOCAL:"local",SENT:"sent",ACKED:"acked",QUEUED:"queued",TIMEOUT:"timeout",FAILED:"failed"}),D=Object.freeze({HANDSHAKE_TIMEOUT:"ERR_HANDSHAKE_TIMEOUT",HANDSHAKE_REJECTED:"ERR_HANDSHAKE_REJECTED",ORIGIN_FORBIDDEN:"ERR_ORIGIN_FORBIDDEN",PEER_EXISTS:"ERR_PEER_EXISTS",PEER_NOT_FOUND:"ERR_PEER_NOT_FOUND",PEER_DISCONNECTED:"ERR_PEER_DISCONNECTED",RECONNECT_FAILED:"ERR_RECONNECT_FAILED",UNSUPPORTED:"ERR_UNSUPPORTED",NOT_CONNECTED:"ERR_NOT_CONNECTED",ACK_TIMEOUT:"ERR_ACK_TIMEOUT",RESPONSE_TIMEOUT:"ERR_RESPONSE_TIMEOUT",QUEUE_FULL:"ERR_QUEUE_FULL",INVALID_MESSAGE:"ERR_INVALID_MESSAGE",VERSION_MISMATCH:"ERR_VERSION_MISMATCH",CLONE_ERROR:"ERR_CLONE_ERROR",TRANSFER_ERROR:"ERR_TRANSFER_ERROR",MESSAGE_TOO_LARGE:"ERR_MESSAGE_TOO_LARGE",UNREACHABLE:"ERR_UNREACHABLE",TTL_EXCEEDED:"ERR_TTL_EXCEEDED",NO_ROUTE:"ERR_NO_ROUTE",NO_HANDLER:"ERR_NO_HANDLER",HANDLER_ERROR:"ERR_HANDLER_ERROR",HANDLER_TIMEOUT:"ERR_HANDLER_TIMEOUT",HANDLER_EXISTS:"ERR_HANDLER_EXISTS",SEND_FAILED:"ERR_SEND_FAILED",CHANNEL_FAILED:"ERR_CHANNEL_FAILED",CHANNEL_CLOSED:"ERR_CHANNEL_CLOSED",MAX_PEERS:"ERR_MAX_PEERS",MAX_PENDING:"ERR_MAX_PENDING",DESTROYED:"ERR_DESTROYED",CIRCUIT_OPEN:"ERR_CIRCUIT_OPEN",PAYLOAD_TOO_LARGE:"ERR_PAYLOAD_TOO_LARGE",RATE_LIMITED:"ERR_RATE_LIMITED",UNAUTHORIZED:"ERR_UNAUTHORIZED",INVALID_PAYLOAD:"ERR_INVALID_PAYLOAD"}),C=Object.freeze({[D.HANDSHAKE_TIMEOUT]:{message:"Handshake timed out",retryable:!0,suggestion:"Increase timeout or check if target is loaded. Use iframe.onload before connecting."},[D.HANDSHAKE_REJECTED]:{message:"Handshake rejected by peer",retryable:!1,suggestion:"Check targetOrigin matches the peer's origin. Verify peer allows your origin."},[D.ORIGIN_FORBIDDEN]:{message:"Origin not in allowed origins list",retryable:!1,suggestion:'Add your origin to allowedOrigins option or use targetOrigin: "*" for development.'},[D.PEER_EXISTS]:{message:"Peer with this ID already exists",retryable:!1,suggestion:"Use unique peerId for each context. Try: peerId: `agent-${Date.now()}`"},[D.PEER_NOT_FOUND]:{message:"Peer not found",retryable:!1,suggestion:"Check if peer is connected using bus.peers. Wait for peer connection before request."},[D.PEER_DISCONNECTED]:{message:"Peer is disconnected",retryable:!0,suggestion:'Wait for peer to reconnect. Listen for "peer:join" event before retry.'},[D.RECONNECT_FAILED]:{message:"Max reconnection attempts reached",retryable:!1,suggestion:"Check network connectivity. Consider increasing maxRetries option."},[D.UNSUPPORTED]:{message:"Operation not supported by this environment",retryable:!1,suggestion:"This feature requires a browser environment. Check for feature availability first."},[D.NOT_CONNECTED]:{message:"Transport is not connected",retryable:!0,suggestion:"Call addTransport() and wait for connection before sending messages."},[D.ACK_TIMEOUT]:{message:"ACK not received within timeout",retryable:!0,suggestion:"Increase ackTimeout option or check peer availability."},[D.RESPONSE_TIMEOUT]:{message:"Response not received within timeout",retryable:!0,suggestion:"Increase timeout in request options: { timeout: 10000 }. Check if handler exists on peer."},[D.QUEUE_FULL]:{message:"Message queue is full",retryable:!1,suggestion:"Increase maxQueueSize or wait for queue to drain. Consider using batching plugin."},[D.INVALID_MESSAGE]:{message:"Invalid message format",retryable:!1,suggestion:"Ensure message data is JSON-serializable. Avoid DOM nodes and functions."},[D.VERSION_MISMATCH]:{message:"Protocol version mismatch",retryable:!1,suggestion:"Update CrossBus to same version on both sides."},[D.CLONE_ERROR]:{message:"Data cannot be cloned (contains functions or DOM nodes)",retryable:!1,suggestion:"Remove functions, DOM nodes, and circular references from message data."},[D.TRANSFER_ERROR]:{message:"Failed to transfer object ownership",retryable:!1,suggestion:"Ensure ArrayBuffers are not detached. Each buffer can only be transferred once."},[D.MESSAGE_TOO_LARGE]:{message:"Message exceeds maximum size",retryable:!1,suggestion:"Use streaming for large payloads or increase maxMessageSize option."},[D.UNREACHABLE]:{message:"Destination peer is unreachable",retryable:!0,suggestion:"Check if peer is still connected. Use bus.peers to list available peers."},[D.TTL_EXCEEDED]:{message:"Message TTL exceeded (possible routing loop)",retryable:!1,suggestion:"Check for circular transport configurations. Increase maxTTL if needed."},[D.NO_ROUTE]:{message:"No route to destination",retryable:!1,suggestion:"Add transport connecting to target peer. Set isHub: true on orchestrator."},[D.NO_HANDLER]:{message:"No handler registered for this request",retryable:!1,suggestion:'Register handler on target: bus.handle("handlerName", fn). Check handler name spelling.'},[D.HANDLER_ERROR]:{message:"Handler threw an exception",retryable:!1,suggestion:"Check target peer logs for error. Wrap handler in try/catch."},[D.HANDLER_TIMEOUT]:{message:"Handler did not respond within timeout",retryable:!0,suggestion:"Handler is slow. Increase timeout or optimize handler performance."},[D.HANDLER_EXISTS]:{message:"Handler already registered with this name",retryable:!1,suggestion:"Use different handler name or call bus.removeHandler() first."},[D.SEND_FAILED]:{message:"Failed to send message to peer",retryable:!0,suggestion:"Check transport status. Target window may be closed or blocked."},[D.CHANNEL_FAILED]:{message:"Failed to create direct channel",retryable:!0,suggestion:"Check browser support for MessageChannel. Retry after short delay."},[D.CHANNEL_CLOSED]:{message:"Channel was closed unexpectedly",retryable:!1,suggestion:"Target context was destroyed. Check if iframe/worker still exists."},[D.MAX_PEERS]:{message:"Maximum number of peers reached",retryable:!1,suggestion:"Increase maxPeers option or disconnect unused peers first."},[D.MAX_PENDING]:{message:"Maximum pending requests reached",retryable:!1,suggestion:"Wait for pending requests to complete. Increase maxPendingRequests option."},[D.DESTROYED]:{message:"CrossBus instance has been destroyed",retryable:!1,suggestion:"Create new CrossBus instance. Do not use bus after calling destroy()."},[D.CIRCUIT_OPEN]:{message:"Circuit breaker is open",retryable:!1,suggestion:"Too many failures. Wait for circuit to reset or call circuit.reset()."},[D.PAYLOAD_TOO_LARGE]:{message:"Payload exceeds maximum allowed size",retryable:!1,suggestion:"Reduce payload size or increase maxPayloadSize option. Consider using streaming for large data."},[D.RATE_LIMITED]:{message:"Request rate limit exceeded",retryable:!0,suggestion:"Wait before retrying. Consider adding delay or using exponential backoff."},[D.UNAUTHORIZED]:{message:"Peer is not authorized to call this handler",retryable:!1,suggestion:"Add peer to handler allowedPeers list or remove peer restrictions."},[D.INVALID_PAYLOAD]:{message:"Payload validation failed",retryable:!1,suggestion:"Check payload structure against handler requirements."}});class k extends Error{code;details;retryable;cause;timestamp;constructor(e,t,s={}){const r=C[e]??{message:"Unknown error",retryable:!1};super(t??r.message),this.name="CrossBusError",this.code=e,this.details=s.details??{},this.retryable=s.retryable??r.retryable,this.cause=s.cause,this.timestamp=Date.now(),Error.captureStackTrace&&Error.captureStackTrace(this,k)}static from(e,t={}){return new k(e,void 0,{details:t})}static wrap(e,t,s={}){return new k(e,t.message,{cause:t,details:s})}toJSON(){return{name:this.name,code:this.code,message:this.message,details:this.details,retryable:this.retryable,timestamp:this.timestamp}}toString(){return`${this.name} [${this.code}]: ${this.message}`}}class M extends b{#s=new Map;#r=0;#i=new Map;#n=Object.create(null);#o=Object.create(null);#a=[];constructor(){super()}addPeer(e,t,s={}){if(this.#s.has(e))throw k.from(D.PEER_EXISTS,{peerId:e});if("function"!=typeof t)throw new TypeError("sendFn must be a function");const r={peerId:e,sendFn:t,meta:s.meta??{},origin:s.origin??"unknown",status:O.CONNECTED,connectedAt:Date.now()};this.#s.set(e,r),this.#i.set(e,0),this.#n[e]=r,this.#o[e]=t,this.#a.push(e),this.emit("peer:added",{peerId:e,meta:r.meta})}removePeer(e){const t=this.#n[e];if(!t)return!1;this.#s.delete(e),this.#i.delete(e),delete this.#n[e],delete this.#o[e];const s=this.#a.indexOf(e);return-1!==s&&this.#a.splice(s,1),this.emit("peer:removed",{peerId:e,meta:t.meta}),!0}getPeer(e){return this.#n[e]}getPeerIds(){return this.#a.slice()}get peerCount(){return this.#s.size}route(e,t={}){const{target:s,payload:r}=e;if(s)return this.#h(s,r);{const e=t.exclude,s=e?.length?new Set(e):null;return this.#c(r,s)}}broadcast(e,t={}){const s=t.exclude,r=s?.length?new Set(s):null,i=t.include,n=i?.length?new Set(i):null;let o=0;const a=[];for(const[t,s]of this.#s)if(!r?.has(t)&&(!n||n.has(t))&&s.status===O.CONNECTED)try{const r=this.#l(t,e,S.BROADCAST);s.sendFn(r),o++}catch(e){a.push(t)}return{success:0===a.length,delivered:o,failed:a}}getSequence(e){return this.#i.get(e)??0}setPeerStatus(e,t){const s=this.#n[e];s&&(s.status=t,this.emit("peer:status",{peerId:e,status:t}))}clearPeers(){const e=this.#a.slice();for(const t of e)this.removePeer(t)}#h(e,t){const s=this.#n[e];if(!s)return{success:!1,delivered:0,failed:[e],error:D.PEER_NOT_FOUND};if(s.status!==O.CONNECTED)return{success:!1,delivered:0,failed:[e],error:D.PEER_DISCONNECTED};try{const r=t&&t.i?t:this.#l(e,t,S.SIGNAL);return s.sendFn(r),{success:!0,delivered:1,failed:[]}}catch(t){return{success:!1,delivered:0,failed:[e]}}}#c(e,t){return this.broadcast(e,t?{exclude:Array.from(t)}:{})}#l(e,t,s){const r=(this.#i.get(e)??0)+1;return this.#i.set(e,r),{id:"msg_"+ ++this.#r,t:s,ts:Date.now(),seq:r,p:t}}}class v{#u=new Map;#d=Object.create(null);#f=0;#g;#p;constructor(e={}){this.#g=e.defaultTimeout??3e4,this.#p=e.maxPending??1e3}create(e,t,s={}){if(this.#p>0&&this.#u.size>=this.#p)throw k.from(D.MAX_PENDING,{current:this.#u.size,max:this.#p,targetPeer:e,handlerName:t});const r=Date.now(),i=`req_${++this.#f}_${r}`,n=s.timeout??this.#g,{promise:o,resolve:a,reject:c}=h(),u={id:i,targetPeer:e,handlerName:t,createdAt:r,timeout:n,resolve:a,reject:c,defaultValue:s.defaultValue};this.#u.set(i,u),this.#d[i]=u;const d=l(o,n).catch(r=>{if(i in this.#d){if(this.#u.delete(i),delete this.#d[i],"defaultValue"in s)return s.defaultValue;throw k.from(D.RESPONSE_TIMEOUT,{requestId:i,targetPeer:e,handlerName:t,timeout:n})}throw r});return{requestId:i,promise:d}}resolve(e,t){const s=this.#d[e];if(!s)return!1;if(this.#u.delete(e),delete this.#d[e],t.success)s.resolve(t.data);else{const r=k.from(t.error?.code??D.HANDLER_ERROR,{requestId:e,targetPeer:s.targetPeer,handlerName:s.handlerName,originalError:t.error});r.message=t.error?.message??"Handler error",s.reject(r)}return!0}reject(e,t){const s=this.#d[e];if(!s)return!1;this.#u.delete(e),delete this.#d[e];const r=t instanceof Error?t:new Error(t);return s.reject(r),!0}cancel(e){const t=this.#d[e];return!!t&&(this.#u.delete(e),delete this.#d[e],t.reject(new Error("Request cancelled")),!0)}cancelForPeer(e){let t=0;for(const[s,r]of this.#u)r.targetPeer===e&&(this.#u.delete(s),delete this.#d[s],r.reject(k.from(D.PEER_DISCONNECTED,{peerId:e,requestId:s})),t++);return t}cancelAll(){const e=this.#u.size;for(const[e,t]of this.#u)t.reject(new Error("All requests cancelled"));this.#u.clear();for(const e in this.#d)delete this.#d[e];return e}has(e){return e in this.#d}get(e){return this.#d[e]}get size(){return this.#u.size}getRequestIds(){return Array.from(this.#u.keys())}getForPeer(e){const t=[];for(const s of this.#u.values())s.targetPeer===e&&t.push(s);return t}}class P{#m;#y;#w;#E;#b=new Map;constructor(e={}){this.#m=e.peerId??o(),this.#y=e.meta??{},this.#w=e.capabilities??[],this.#E=e.timeout??1e4}get peerId(){return this.#m}createInitMessage(){return{type:S.HANDSHAKE_INIT,handshakeId:o(),peerId:this.#m,meta:this.#y,capabilities:this.#w,timestamp:Date.now()}}createAckMessage(e,t,s){return{type:S.HANDSHAKE_ACK,handshakeId:e.handshakeId,peerId:this.#m,meta:this.#y,capabilities:this.#w,accept:t,reason:t?void 0:s,timestamp:Date.now()}}createCompleteMessage(e){return{type:S.HANDSHAKE_COMPLETE,handshakeId:e,confirmed:!0,timestamp:Date.now()}}async initiate(e){const t=this.createInitMessage(),{promise:s,resolve:r,reject:i}=h();this.#b.set(t.handshakeId,{phase:N.INIT_SENT,resolve:r,reject:i,initMsg:t,startTime:Date.now()}),e(t);try{return await l(s,this.#E)}catch(e){return this.#b.delete(t.handshakeId),e.code===D.HANDSHAKE_TIMEOUT?{success:!1,error:D.HANDSHAKE_TIMEOUT,reason:`Handshake timeout after ${this.#E}ms`}:{success:!1,error:D.HANDSHAKE_REJECTED,reason:e.message}}}handleMessage(e,t,s,r){switch(e.type){case S.HANDSHAKE_INIT:return this.#R(e,t,s,r);case S.HANDSHAKE_ACK:return this.#T(e,t,s);case S.HANDSHAKE_COMPLETE:return this.#I(e,t);default:return null}}hasPending(e){return this.#b.has(e)}cancel(e){const t=this.#b.get(e);t&&(t.reject(new Error("Handshake cancelled")),this.#b.delete(e))}cancelAll(){for(const[e,t]of this.#b)t.reject(new Error("All handshakes cancelled"));this.#b.clear()}#R(e,t,s,r){return r&&!r(e,t)?(s(this.createAckMessage(e,!1,"Validation failed")),null):(s(this.createAckMessage(e,!0)),this.#b.set(e.handshakeId,{phase:N.ACK_SENT,remotePeer:{peerId:e.peerId,origin:t,meta:e.meta,capabilities:e.capabilities}}),null)}#T(e,t,s){const r=this.#b.get(e.handshakeId);if(!r)return null;if(!e.accept)return r.reject(new Error(e.reason||"Connection rejected")),this.#b.delete(e.handshakeId),null;s(this.createCompleteMessage(e.handshakeId));const i={peerId:e.peerId,origin:t,meta:e.meta,capabilities:e.capabilities,type:"unknown",connectedAt:Date.now()};return r.resolve({success:!0,peer:i}),this.#b.delete(e.handshakeId),i}#I(e,t){const s=this.#b.get(e.handshakeId);if(!s||s.phase!==N.ACK_SENT)return null;if(!e.confirmed)return this.#b.delete(e.handshakeId),null;const r={...s.remotePeer,connectedAt:Date.now()};return this.#b.delete(e.handshakeId),r}}class x{#S=new Set;#N=[];#O=!1;#A;constructor(e={}){if(this.#O=e.allowAll??!1,this.#A=globalThis.location?.origin,e.allowed)for(const t of e.allowed)this.#_(t)}isAllowed(e){if(this.#O)return!0;if("null"===e||null===e)return this.#S.has("null");if(0===this.#S.size&&0===this.#N.length)return e===this.#A;if(this.#S.has(e))return!0;for(const t of this.#N)if(t.test(e))return!0;return!1}allow(e){return this.#_(e),this}disallow(e){return!!this.#S.has(e)&&(this.#S.delete(e),!0)}getAllowed(){return Array.from(this.#S)}clear(){this.#S.clear(),this.#N=[]}get selfOrigin(){return this.#A}#_(e){if("string"!=typeof e)throw new TypeError("Origin must be a string");if("*"!==e)if(e.includes("*")){const t=this.#D(e);this.#N.push(t)}else this.#S.add(e);else this.#O=!0}#D(e){const t=e.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*/g,"[a-zA-Z0-9.-]{0,253}");return new RegExp(`^${t}$`)}}const H={sameOrigin:()=>new x,allowAll:()=>new x({allowAll:!0}),fromList:e=>new x({allowed:e})};class L extends b{#C;#k;#M;#v;#P;#x;#H;#L=new Map;#U=[];#q=[];#y;#w;#j;#W;#B;#F;#$=new Map;#z=new Map;#G=!1;#K="[CrossBus]";#J;#V=!1;constructor(e={}){super(),this.#C=e.peerId??o(),this.#k=e.isHub??!1,this.#y=e.meta??{},this.#w=e.capabilities??[],this.#j=e.requestTimeout??3e4,this.#M=new M,this.#v=new v({defaultTimeout:this.#j}),this.#P=new P({peerId:this.#C,meta:this.#y,capabilities:this.#w,timeout:e.handshakeTimeout??1e4}),this.#x=new x({allowed:e.allowedOrigins??[]}),this.#H=e.contentType??"application/json",this.#W=e.maxPayloadSize??1048576,this.#B=e.maxPendingRequests??100,this.#F=e.strictMode??!1,this.#G=e.debug??!1,this.#K=e.debugPrefix??"[CrossBus]",this.#J=Date.now(),this.#Q(e),this.#w.push(`serializer:${this.#H}`),this.#M.on("peer:added",e=>{this.emit("peer:connected",e.data)}),this.#M.on("peer:removed",e=>{this.emit("peer:disconnected",e.data)}),this.#M.on("peer:status",e=>{this.emit("peer:status",e.data)}),this.#G&&this.#X("info",`Initialized (isHub: ${this.#k})`)}get peerId(){return this.#C}get isHub(){return this.#k}get peerCount(){return this.#M.peerCount}get peers(){return this.#M.getPeerIds()}getPeer(e){return this.#M.getPeer(e)}async signal(e,t,r={}){this.#Y();const i=((e,t,r,i=null)=>s(S.SIGNAL,{name:e,data:t,source:r,dest:i}))(e,await this.#Z(this.#q,t,{type:"signal",direction:"outbound"}),this.#C),n=await this.#M.broadcast(i,r);return this.#X("out",`SIGNAL "${e}" to ${n.delivered} peers`),n}async request(e,t,r,i={}){if(this.#Y(),this.#X("out",`REQUEST "${t}" to ${e}`),!this.#M.getPeer(e))throw k.from(D.PEER_NOT_FOUND,{peerId:e});const{requestId:n,promise:o}=this.#v.create(e,t,{timeout:i.timeout??this.#j}),a=((e,t,r,i,n=null)=>s(S.REQUEST,{name:e,data:t,source:r,dest:i},{},n))(t,await this.#Z(this.#q,r,{type:"request",peerId:e,handlerName:t,direction:"outbound"}),this.#C,e,n);if(!this.#M.route({target:e,payload:a}).success)throw this.#v.cancel(n),k.from(D.SEND_FAILED,{peerId:e});return o}async broadcastRequest(e,t,s={}){this.#Y();const r=s.timeout??this.#j,i=s.ignoreErrors??!0,n=new Set(s.exclude??[]),o=new Map,a=[];for(const s of this.#M.getPeerIds()){if(n.has(s))continue;const h=this.request(s,e,t,{timeout:r}).then(e=>{o.set(s,{success:!0,data:e})}).catch(e=>{if(!i)throw e;o.set(s,{success:!1,error:e.message})});a.push(h)}return await Promise.all(a),o}handle(e,t,s={}){if(this.#L.has(e))throw k.from(D.HANDLER_EXISTS,{handlerName:e});return(s.allowedPeers||s.rateLimit||s.validatePayload)&&this.#z.set(e,s),this.#L.set(e,t),()=>{this.#L.delete(e),this.#z.delete(e)}}unhandle(e){return this.#L.delete(e)}hasHandler(e){return this.#L.has(e)}addInboundHook(e,t=10){if("function"!=typeof e)throw new TypeError("hookFn must be a function");return this.#U.push({fn:e,priority:t}),this.#U.sort((e,t)=>e.priority-t.priority),()=>this.removeInboundHook(e)}addOutboundHook(e,t=10){if("function"!=typeof e)throw new TypeError("hookFn must be a function");return this.#q.push({fn:e,priority:t}),this.#q.sort((e,t)=>e.priority-t.priority),()=>this.removeOutboundHook(e)}removeInboundHook(e){const t=this.#U.findIndex(t=>t.fn===e);return-1!==t&&(this.#U.splice(t,1),!0)}removeOutboundHook(e){const t=this.#q.findIndex(t=>t.fn===e);return-1!==t&&(this.#q.splice(t,1),!0)}addPeer(e,t,s={}){this.#Y(),this.#M.addPeer(e,t,s)}removePeer(e){return this.#v.cancelForPeer(e),this.#M.removePeer(e)}addTransport(e,t={}){if(this.#Y(),!e||"function"!=typeof e.send)throw new TypeError("Transport must have a send() method");const s=t.peerId||e.peerId||`transport-${o()}`,r=t.origin||"*";return"function"==typeof e.onMessage&&e.onMessage(e=>{this.handleMessage(e,r,s)}),this.addPeer(s,t=>{e.send(t)},t),()=>{this.removePeer(s),"function"==typeof e.destroy&&e.destroy()}}async handleMessage(e,t,s,r){if(this.#V)return;if(!this.#x.isAllowed(t))return;const i=e.type??e.t;let n=e.handler??e.name,o=e.payload??e.data??e.p;if(e.payload&&"object"==typeof e.payload&&!e.p)i===S.SIGNAL||i===S.BROADCAST||i===S.REQUEST?(n=e.payload.name,o=e.payload.data):i===S.RESPONSE&&(o=e.payload.data);else if(e.t&&!e.type&&e.p&&"object"==typeof e.p&&e.p.payload){const t=e.p;n=t.payload.name??t.name,o=t.payload.data??t.data}if(void 0!==o){const e={type:i===S.SIGNAL?"signal":i===S.REQUEST?"request":"response",peerId:s,handlerName:n,direction:"inbound"};o=await this.#Z(this.#U,o,e)}switch(i){case S.BROADCAST:case S.SIGNAL:if("string"!=typeof n)return;await this.#ee(n,o,s);break;case S.REQUEST:if("string"!=typeof n)return;await this.#te(e.id,n,o,s,r);break;case S.RESPONSE:{let t=e.success,s=e.error;e.payload&&void 0!==e.payload.success&&(t=e.payload.success,s=e.payload.error),this.#se(e.payload?.requestId??e.id,t,o,s);break}case S.HANDSHAKE_INIT:case S.HANDSHAKE_ACK:case S.HANDSHAKE_COMPLETE:this.#P.handleMessage(e,t,r)}}destroy(){this.#V||(this.#V=!0,this.#v.cancelAll(),this.#L.clear(),this.#M.clearPeers(),this.clear(),this.emit("destroyed",{}))}get isDestroyed(){return this.#V}async#ee(e,t,s){await this.emit(e,{payload:t,source:s})}async#te(e,t,s,i,n){const o=this.#L.get(t);let a;if(o){const n=this.#re(t,i,s);if(n.allowed)try{const n=await o(s,{peerId:i,requestId:e,handlerName:t});a=r(e,await this.#Z(this.#q,n,{type:"response",peerId:i,handlerName:t,direction:"outbound"}),this.#C,!0)}catch(t){a=r(e,null,this.#C,!1,{code:t.code??D.HANDLER_ERROR,message:t.message})}else a=r(e,null,this.#C,!1,{code:n.error?.code??D.UNAUTHORIZED,message:n.error?.message??"Security check failed"})}else a=r(e,null,this.#C,!1,{code:D.NO_HANDLER,message:"Handler not found"});n?n(a):i&&this.#M.route({target:i,payload:a})}#se(e,t,s,r){this.#v.resolve(e,{requestId:e,success:t,data:s,error:r})}#Y(){if(this.#V)throw k.from(D.DESTROYED,{context:"CrossBus operation"})}async#Z(e,t,s){let r=t;for(const{fn:t}of e)try{r=await t(r,s)}catch(e){}return r}#Q(e){if(("undefined"!=typeof process?"production"!==process.env?.NODE_ENV:"undefined"!=typeof window&&"localhost"===window.location?.hostname)&&e.allowedOrigins?.includes("*")&&this.#F)throw new Error('strictMode: allowedOrigins: ["*"] is not allowed. Use specific origins for security.')}#re(e,t,s){const r=this.#z.get(e);if(!r)return{allowed:!0};if(r.allowedPeers&&!r.allowedPeers.includes(t))return{allowed:!1,error:k.from(D.UNAUTHORIZED,{handler:e,peer:t,allowedPeers:r.allowedPeers})};if(r.rateLimit&&!this.#ie(`${e}:${t}`,r.rateLimit))return{allowed:!1,error:k.from(D.RATE_LIMITED,{handler:e,peer:t,limit:r.rateLimit})};if(r.validatePayload)try{if(!r.validatePayload(s))return{allowed:!1,error:k.from(D.INVALID_PAYLOAD,{handler:e})}}catch(t){return{allowed:!1,error:k.from(D.INVALID_PAYLOAD,{handler:e,reason:t?.message??"Validation error"})}}return{allowed:!0}}#ie(e,t){const s=Date.now(),r=this.#$.get(e);return!r||s>=r.resetAt?(this.#$.set(e,{count:1,resetAt:s+1e3}),!0):!(r.count>=t||(r.count++,0))}get maxPayloadSize(){return this.#W}get strictMode(){return this.#F}get debug(){return this.#G}get uptime(){return Date.now()-this.#J}#X(e,t){this.#G}healthCheck(){const e=this.#M.getPeerIds(),t=e.length;let s,r="healthy";if(this.#V?r="unhealthy":0===t&&this.#k&&(r="degraded"),"undefined"!=typeof process&&process.memoryUsage)try{const e=process.memoryUsage();s={heapUsed:e.heapUsed,heapTotal:e.heapTotal,rss:e.rss}}catch{}return{status:r,peerId:this.#C,isHub:this.#k,uptime:this.uptime,peers:{total:t,ids:e},handlers:Array.from(this.#L.keys()),pendingRequests:this.#v.size??0,destroyed:this.#V,...s&&{memory:s}}}static createSecure(e={}){if(!e.allowedOrigins||0===e.allowedOrigins.length)throw new Error('createSecure() requires allowedOrigins to be specified. For development, use: new CrossBus({ allowedOrigins: ["*"] })');if(e.allowedOrigins.includes("*"))throw new Error('createSecure() does not allow wildcard origins. Specify exact origins: allowedOrigins: ["https://example.com"]');return new L({strictMode:!0,maxPayloadSize:1048576,maxPendingRequests:100,requestTimeout:3e4,...e})}diagnose(){const e=[],t=[],s=[];if(this.#V)return e.push("Instance is destroyed"),t.push("Create a new CrossBus instance"),{status:"error",issues:e,suggestions:t,warnings:s};const r=this.#M.getPeerIds().length;0===r&&(this.#k?(s.push("Hub has no connected peers"),t.push("Add transports with addTransport() or wait for agents to connect")):(e.push("Agent has no connected peers"),t.push('Add a transport to connect to hub: bus.addTransport(transport, {peerId: "hub"})')));const i=this.#L.size;this.#k&&0===i&&(s.push("Hub has no registered handlers"),t.push('Register handlers with bus.handle("name", fn)'));const n=this.#v.size??0;n>.8*this.#B&&(s.push(`High pending request count: ${n}/${this.#B}`),t.push("Consider increasing maxPendingRequests or check for slow handlers")),this.#F||(s.push("strictMode is disabled"),t.push("For production, use CrossBus.createSecure() or set strictMode: true"));let o="healthy";return e.length>0?o="error":s.length>0&&(o="warning"),{status:o,peerId:this.#C,isHub:this.#k,peerCount:r,handlerCount:i,pendingRequests:n,uptime:this.uptime,issues:e,warnings:s,suggestions:t}}}class U{#ne;#oe;#ae;#he;#ce=0;#le=!1;#ue=!1;#y;constructor(e,t,s={}){this.#ne=o(),this.#oe=t,this.#ae=e,this.#he=s.chunkSize??64e3,this.#y=s.meta??{}}get streamId(){return this.#ne}get name(){return this.#oe}async open(e){this.#ue||(this.#ue=!0,await this.#de({st:"open",name:this.#oe,meta:{...this.#y,...e}}))}async write(e){if(this.#le)throw new Error("Stream already ended");let t;this.#ue||await this.open();let s=!1;if(e instanceof ArrayBuffer)t=this.#fe(new Uint8Array(e)),s=!0;else if(e instanceof Uint8Array)t=this.#fe(e),s=!0;else{if("string"==typeof e){const t=this.#ge(e,this.#he);for(const e of t)await this.#de({st:"data",seq:this.#ce++,d:e,b64:!1});return}t=JSON.stringify(e)}if(s){const e=this.#ge(t,this.#he);for(const t of e)await this.#de({st:"data",seq:this.#ce++,d:t,b64:!0})}else await this.#de({st:"data",seq:this.#ce++,d:t,b64:!1})}async end(e){this.#le||(this.#le=!0,await this.#de({st:"end",seq:this.#ce,meta:e}))}async abort(e){this.#le||(this.#le=!0,await this.#de({st:"error",reason:e??"Stream aborted"}))}async#de(e){const t={[T]:1,t:"stream",sid:this.#ne,...e};await this.#ae(t)}#ge(e,t){const s=[];for(let r=0;r<e.length;r+=t)s.push(e.slice(r,r+t));return s}#fe(e){let t="";for(let s=0;s<e.length;s++)t+=String.fromCharCode(e[s]);return btoa(t)}}class q{#ne;#oe;#y;#pe=[];#me=null;#le=!1;#ye=null;constructor(e,t,s={}){this.#ne=e,this.#oe=t,this.#y=s}get streamId(){return this.#ne}get name(){return this.#oe}get meta(){return this.#y}get ended(){return this.#le}push(e){if(this.#le)return;let t=e.d;if(e.b64&&(t=this.#we(t)),this.#pe.push(t),this.#me){const e=this.#me;this.#me=null,e()}}end(e){if(this.#le=!0,e&&(this.#y={...this.#y,...e}),this.#me){const e=this.#me;this.#me=null,e()}}error(e){if(this.#le=!0,this.#ye=new Error(e),this.#me){const e=this.#me;this.#me=null,e()}}async*[Symbol.asyncIterator](){for(;;){for(;this.#pe.length>0;)yield this.#pe.shift();if(this.#le){if(this.#ye)throw this.#ye;return}await new Promise(e=>{this.#me=e})}}async collect(){const e=[];let t=!1;for await(const s of this)e.push(s),s instanceof Uint8Array&&(t=!0);if(t){const t=e.reduce((e,t)=>e+t.length,0),s=new Uint8Array(t);let r=0;for(const t of e)s.set(t,r),r+=t.length;return s}return e.join("")}#we(e){const t=atob(e),s=new Uint8Array(t.length);for(let e=0;e<t.length;e++)s[e]=t.charCodeAt(e);return s}}class j{#Ee=new Map;#be=new Map;#ae;constructor(e){this.#ae=e}createStream(e,t,s={}){return new U(async e=>{await this.#ae(t,e)},e,s)}onStream(e,t){return this.#be.set(e,t),()=>this.#be.delete(e)}handleMessage(e,t){if("stream"!==e.t)return;const s=e.sid;switch(e.st){case"open":this.#Re(s,e,t);break;case"data":this.#Te(s,e);break;case"end":this.#Ie(s,e);break;case"error":this.#Se(s,e)}}#Re(e,t,s){const r=this.#be.get(t.name);if(!r)return;const i=new q(e,t.name,t.meta);this.#Ee.set(e,i),r(i).catch(()=>{})}#Te(e,t){const s=this.#Ee.get(e);s&&s.push(t)}#Ie(e,t){const s=this.#Ee.get(e);s&&(s.end(t.meta),this.#Ee.delete(e))}#Se(e,t){const s=this.#Ee.get(e);s&&(s.error(t.reason),this.#Ee.delete(e))}get activeStreamCount(){return this.#Ee.size}}class W extends b{#C;#ae;#s=new Map;#Ne;#E;#Oe=null;#Ae=null;#V=!1;#_e="online";#y={};constructor(e,t){if(super(),!t.peerId)throw new Error("peerId is required");this.#C=t.peerId,this.#ae=e,this.#Ne=t.heartbeatInterval??15e3,this.#E=t.timeout??45e3,!1!==t.autoStart&&this.start()}get peerId(){return this.#C}get status(){return this.#_e}get onlineCount(){let e=0;for(const t of this.#s.values())"offline"!==t.status&&e++;return e}start(){this.#Oe||(this.#De("join"),this.#Oe=setInterval(()=>{this.#De("heartbeat")},this.#Ne),this.#Ae=setInterval(()=>{this.#Ce()},this.#Ne))}stop(){this.#Oe&&(clearInterval(this.#Oe),this.#Oe=null),this.#Ae&&(clearInterval(this.#Ae),this.#Ae=null),this.#De("leave")}setStatus(e,t){this.#_e=e,t&&(this.#y={...this.#y,...t}),this.#De("update")}setMeta(e){this.#y={...this.#y,...e},this.#De("update")}getOnlinePeers(){const e=[];for(const[t,s]of this.#s)"offline"!==s.status&&e.push(t);return e}getAllPeers(){return Array.from(this.#s.values())}getPeer(e){return this.#s.get(e)}isOnline(e){const t=this.#s.get(e);return!!t&&"offline"!==t.status}handleMessage(e,t){if("presence"!==e.t)return;if(t===this.#C)return;const{pt:s,status:r,meta:i}=e,n=Date.now();switch(s){case"join":this.#ke(t,r,i,n),this.#De("heartbeat");break;case"leave":this.#Me(t);break;case"heartbeat":case"update":this.#ve(t,r,i,n)}}#ke(e,t,s,r){const i=!this.#s.has(e);this.#s.set(e,{peerId:e,status:t??"online",lastSeen:r,meta:s??{}}),i&&this.emitSync("join",{peerId:e,meta:s})}#Me(e){const t=this.#s.get(e);t&&(t.status="offline",this.#s.delete(e),this.emitSync("leave",{peerId:e}))}#ve(e,t,s,r){let i=this.#s.get(e);const n=!i||"offline"===i.status;i?(i.lastSeen=r,t&&(i.status=t),s&&(i.meta={...i.meta,...s})):(i={peerId:e,status:t??"online",lastSeen:r,meta:s??{}},this.#s.set(e,i)),n&&"offline"!==i.status?this.emitSync("join",{peerId:e,meta:i.meta}):this.emitSync("update",{peerId:e,peer:i})}#Ce(){const e=Date.now()-this.#E;for(const[t,s]of this.#s)s.lastSeen<e&&"offline"!==s.status&&(s.status="offline",this.#s.delete(t),this.emitSync("leave",{peerId:t}))}async#De(e){if(this.#V)return;const t={[T]:1,t:"presence",pt:e,peerId:this.#C,status:this.#_e,meta:this.#y,ts:Date.now()};try{await this.#ae(t)}catch(e){}}destroy(){this.#V||(this.#V=!0,this.stop(),this.#s.clear())}get isDestroyed(){return this.#V}}const B={contentType:"application/json",serialize(e){return JSON.stringify(e)},deserialize(e){return JSON.parse(e)}},F=new Map;F.set(B.contentType,B);class ${#Pe=null;#xe;#He;#Le;#Ue;#H;#qe=null;#je=null;#V=!1;static isSupported(){return"function"==typeof globalThis.postMessage||"undefined"!=typeof Window}constructor(e,t={}){if(!this.#We(e))throw new TypeError("Target must support postMessage");this.#Pe=e,this.#xe=t.targetOrigin??"*",this.#He=new Set(t.allowedOrigins??[]),this.#Le=t.autoTransfer??!1,this.#H=t.contentType??"application/json",this.#Ue=g(this.#H),("undefined"!=typeof process?"production"!==process.env?.NODE_ENV:"undefined"!=typeof window&&"localhost"===window.location?.hostname)&&this.#xe,this.#je=this.#Be.bind(this),this.#Fe().addEventListener("message",this.#je)}send(e,s){if(this.#V)throw k.from(D.DESTROYED,{context:"PostMessageTransport.send"});if(this.#$e())throw k.from(D.PEER_DISCONNECTED,{reason:"Target window is closed"});const r={[T]:1,...e};let i=r;"application/json"!==this.#H&&(i=this.#Ue.serialize(r));let n=s;this.#Le&&!s&&(n=t(e),0===n.length&&(n=void 0)),this.#ze()?this.#Pe.postMessage(i,n):this.#Pe.postMessage(r,this.#xe,n)}onMessage(e){if("function"!=typeof e)throw new TypeError("Handler must be a function");this.#qe=e}offMessage(){this.#qe=null}destroy(){this.#V||(this.#V=!0,this.#qe=null,this.#je&&(this.#Fe().removeEventListener("message",this.#je),this.#je=null))}get isDestroyed(){return this.#V}get targetOrigin(){return this.#xe}#Be(t){if(!this.#qe)return;let s=t.data;if(e(s)&&(!t.origin||this.#Ge(t.origin))&&(!this.#Pe||!("postMessage"in this.#Pe)||this.#ze()||t.source===this.#Pe))try{this.#qe(s,{origin:t.origin??"worker",source:t.source??t.currentTarget})}catch(e){}}#Ge(e){if(0===this.#He.size)return e===globalThis.location?.origin;if(this.#He.has("*"))return!0;if(this.#He.has(e))return!0;for(const t of this.#He)if(t.includes("*")&&new RegExp("^"+t.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\\\*/g,"[a-zA-Z0-9.-]{0,253}")+"$").test(e))return!0;return!1}#We(e){return!!e&&"function"==typeof e.postMessage}#ze(){return"undefined"!=typeof Worker&&this.#Pe instanceof Worker||"undefined"!=typeof ServiceWorker&&this.#Pe instanceof ServiceWorker||"undefined"!=typeof MessagePort&&this.#Pe instanceof MessagePort}#$e(){return!this.#ze()&&!0===this.#Pe.closed}#Fe(){return"undefined"!=typeof DedicatedWorkerGlobalScope&&globalThis instanceof DedicatedWorkerGlobalScope?globalThis:this.#ze()?this.#Pe:"undefined"!=typeof window?window:globalThis}}class z{#Ke;#Je;#Ue;#H;#qe=null;#V=!1;static isSupported(){return"undefined"!=typeof BroadcastChannel}constructor(e={}){if(!z.isSupported())throw k.from(D.UNSUPPORTED,{api:"BroadcastChannel"});this.#Je=e.channelName??"crossbus:default",this.#Ke=new BroadcastChannel(this.#Je),this.#H=e.contentType??"application/json",this.#Ue=g(this.#H),this.#Ke.onmessage=this.#Be.bind(this),this.#Ke.onmessageerror=this.#Se.bind(this)}send(e){if(this.#V)throw k.from(D.DESTROYED,{context:"BroadcastChannelTransport.send"});const t={[T]:1,...e};let s=t;"application/json"!==this.#H&&(s=this.#Ue.serialize(t)),this.#Ke.postMessage(s)}onMessage(e){if("function"!=typeof e)throw new TypeError("Handler must be a function");this.#qe=e}offMessage(){this.#qe=null}destroy(){this.#V||(this.#V=!0,this.#qe=null,this.#Ke&&(this.#Ke.close(),this.#Ke=null))}get channelName(){return this.#Je}get isDestroyed(){return this.#V}#Be(t){if(!this.#qe)return;let s=t.data;if(s instanceof ArrayBuffer||s instanceof Uint8Array)try{const e=(new TextDecoder).decode(s instanceof ArrayBuffer?new Uint8Array(s):s);s=B.deserialize(e)}catch(e){return}if(e(s))try{this.#qe(s,{origin:"broadcast"})}catch(e){}}#Se(e){}}class G{#Ve;#Qe;#Le;#Ue;#H;#qe=null;#V=!1;#Xe;static isSupported(){return"undefined"!=typeof MessageChannel}static fromPort(e,t={}){if(!(e instanceof MessagePort))throw new TypeError("Port must be a MessagePort");const s=Object.create(G.prototype);return s.#Ve=e,s.#Qe=null,s.#Le=t.autoTransfer??!1,s.#H=t.contentType??"application/json",s.#Ue=g(s.#H),s.#V=!1,s.#Xe=!1,s.#qe=null,s.#Ve.onmessage=s.#Be.bind(s),s.#Ve.onmessageerror=s.#Se.bind(s),s}constructor(e={}){if(!G.isSupported())throw k.from(D.UNSUPPORTED,{api:"MessageChannel"});const t=new MessageChannel;this.#Ve=t.port1,this.#Qe=t.port2,this.#Le=e.autoTransfer??!1,this.#H=e.contentType??"application/json",this.#Ue=g(this.#H),this.#Xe=!0,this.#Ve.onmessage=this.#Be.bind(this),this.#Ve.onmessageerror=this.#Se.bind(this)}get remotePort(){return this.#Qe}markRemoteTransferred(){this.#Qe=null}get isInitiator(){return this.#Xe}send(e,s){if(this.#V)throw k.from(D.DESTROYED,{context:"MessageChannelTransport.send"});const r={[T]:1,...e};let i=r;"application/json"!==this.#H&&(i=this.#Ue.serialize(r));let n=s;this.#Le&&!s&&(n=t(e),0===n.length&&(n=void 0)),this.#Ve.postMessage(i,n)}onMessage(e){if("function"!=typeof e)throw new TypeError("Handler must be a function");this.#qe=e}offMessage(){this.#qe=null}destroy(){this.#V||(this.#V=!0,this.#qe=null,this.#Ve&&(this.#Ve.close(),this.#Ve=null),this.#Qe&&(this.#Qe.close(),this.#Qe=null))}get isDestroyed(){return this.#V}#Be(t){if(!this.#qe)return;let s=t.data;if(e(s))try{this.#qe(s,{origin:"channel"})}catch(e){}}#Se(e){}}class K{#Ye=null;#Ze=null;#et;#qe=null;#V=!1;static isSupported(){return"undefined"!=typeof SharedWorker}constructor(e={}){if(!K.isSupported())throw k.from(D.UNSUPPORTED,{api:"SharedWorker"});this.#et=e.workerUrl??"/crossbus-shared-worker.js",this.#Ye=new SharedWorker(this.#et,e.name),this.#Ze=this.#Ye.port,this.#Ze.onmessage=this.#Be.bind(this),this.#Ze.onmessageerror=this.#Se.bind(this),this.#Ye.onerror=this.#tt.bind(this),this.#Ze.start()}send(e,t){if(this.#V)throw k.from(D.DESTROYED,{context:"SharedWorkerTransport.send"});const s={[T]:1,...e};this.#Ze&&(t&&t.length>0?this.#Ze.postMessage(s,t):this.#Ze.postMessage(s))}onMessage(e){if("function"!=typeof e)throw new TypeError("Handler must be a function");this.#qe=e}offMessage(){this.#qe=null}destroy(){this.#V||(this.#V=!0,this.#qe=null,this.#Ze&&(this.#Ze.close(),this.#Ze=null),this.#Ye=null)}get workerUrl(){return this.#et}get isDestroyed(){return this.#V}#Be(t){if(this.#qe&&e(t.data))try{this.#qe(t.data,{origin:"sharedworker"})}catch(e){}}#Se(e){}#tt(e){}}class J{#st=null;#qe=null;#V=!1;#rt;#it=null;static isSupported(){return"undefined"!=typeof navigator&&"serviceWorker"in navigator}constructor(e={}){if(!J.isSupported())throw k.from(D.UNSUPPORTED,{api:"ServiceWorker"});this.#rt=this.#nt()}get ready(){return this.#rt}async#nt(){const e=await navigator.serviceWorker.ready;this.#st=e.active||navigator.serviceWorker.controller,this.#it=this.#Be.bind(this),navigator.serviceWorker.addEventListener("message",this.#it)}send(e,t){if(this.#V)throw k.from(D.DESTROYED,{context:"ServiceWorkerTransport.send"});if(!this.#st)throw k.from(D.NOT_CONNECTED,{context:"ServiceWorkerTransport.send",reason:"No active ServiceWorker"});const s={[T]:1,...e};t&&t.length>0?this.#st.postMessage(s,t):this.#st.postMessage(s)}onMessage(e){if("function"!=typeof e)throw new TypeError("Handler must be a function");this.#qe=e}offMessage(){this.#qe=null}destroy(){this.#V||(this.#V=!0,this.#qe=null,this.#it&&(navigator.serviceWorker.removeEventListener("message",this.#it),this.#it=null),this.#st=null)}get isDestroyed(){return this.#V}#Be(t){if(this.#qe&&e(t.data))try{this.#qe(t.data,{origin:"serviceworker"})}catch(e){}}}class V{#ot="none";#at;#ht;#qe=null;#V=!1;#ct=!1;#lt=[];#ut;#Oe=null;#Ne;#rt;#dt;static detectBridge(){return globalThis.CrossBus&&"function"==typeof globalThis.CrossBus.postMessage||globalThis.AndroidBridge&&"function"==typeof globalThis.AndroidBridge.postMessage?"android":globalThis.webkit?.messageHandlers?.crossbus?"ios":"none"}static isSupported(){return"none"!==V.detectBridge()}constructor(e={}){this.#at=e.androidInterface??"CrossBus",this.#ht=e.iosHandler??"crossbus",this.#ut=e.queueWhileInit??!0,this.#Ne=e.heartbeatInterval??3e4,this.#rt=new Promise(e=>{this.#dt=e}),this.#ft(e.initTimeout??5e3)}async#ft(e){const t=Date.now(),s=()=>{this.#ot=V.detectBridge(),"none"===this.#ot?Date.now()-t<e?setTimeout(s,50):(this.#ct=!0,this.#dt?.()):this.#gt()};s(),this.#pt()}#gt(){this.#ct=!0,this.#dt?.(),this.#mt(),this.#Ne>0&&this.#yt()}#pt(){globalThis.__crossbus_receive__=t=>{if(!this.#V&&this.#qe)try{const s="string"==typeof t?JSON.parse(t):t;if(!e(s))return;this.#qe(s,{bridgeType:this.#ot})}catch(e){}}}send(e){if(this.#V)throw k.from(D.DESTROYED,{context:"NativeBridgeTransport.send"});const t={[T]:1,...e};this.#ct||!this.#ut?this.#wt(t):this.#lt.push(t)}#wt(e){const t=JSON.stringify(e);try{if("android"===this.#ot){const e=globalThis[this.#at]||globalThis.AndroidBridge;e?.postMessage&&e.postMessage(t)}else if("ios"===this.#ot){const t=globalThis.webkit?.messageHandlers?.[this.#ht];t?.postMessage&&t.postMessage(e)}}catch(e){}}#mt(){for(;this.#lt.length>0;){const e=this.#lt.shift();this.#wt(e)}}#yt(){this.#Oe=setInterval(()=>{this.#V||this.#wt({[T]:1,t:"hb",ts:Date.now()})},this.#Ne)}onMessage(e){if("function"!=typeof e)throw new TypeError("Handler must be a function");this.#qe=e}offMessage(){this.#qe=null}destroy(){this.#V||(this.#V=!0,this.#qe=null,this.#lt=[],this.#Oe&&(clearInterval(this.#Oe),this.#Oe=null),delete globalThis.__crossbus_receive__)}get isDestroyed(){return this.#V}get bridgeType(){return this.#ot}get isReady(){return this.#ct}get ready(){return this.#rt}}class Q{#Et;#C;#bt=null;#Rt;#Tt;#It;#St;#Nt;#Oe=null;#Ot=null;#qe=null;#At=null;#_t="disconnected";#lt=[];#Dt=!1;constructor(e){this.#Et=e.url,this.#C=e.peerId??o(),this.#Rt=e.autoReconnect??!0,this.#Tt=e.reconnectDelayMs??1e3,this.#It=e.maxReconnectDelayMs??3e4,this.#St=this.#Tt,this.#Nt=e.heartbeatIntervalMs??3e4}get peerId(){return this.#C}get state(){return this.#_t}get isConnected(){return"connected"===this.#_t&&this.#bt?.readyState===WebSocket.OPEN}async connect(){if(!this.#bt||this.#bt.readyState!==WebSocket.OPEN)return this.#Dt=!1,this.#Ct("connecting"),new Promise((e,t)=>{try{this.#bt=new WebSocket(this.#Et),this.#bt.onopen=()=>{this.#Ct("connected"),this.#St=this.#Tt,this.#mt(),this.#yt(),e()},this.#bt.onmessage=e=>{this.#Be(e)},this.#bt.onclose=()=>{this.#kt(),this.#Ct("disconnected"),!this.#Dt&&this.#Rt&&this.#Mt()},this.#bt.onerror=()=>{this.#Ct("error"),"connecting"===this.#_t&&t(new Error("WebSocket connection failed"))}}catch(e){this.#Ct("error"),t(e)}})}disconnect(){this.#Dt=!0,this.#kt(),this.#Ot&&(clearTimeout(this.#Ot),this.#Ot=null),this.#bt&&(this.#bt.close(1e3,"Client disconnect"),this.#bt=null),this.#Ct("disconnected")}send(e){const t={i:1,o:T,id:o(),from:this.#C,timestamp:Date.now(),...e};return this.isConnected&&this.#bt?(this.#bt.send(JSON.stringify(t)),!0):(this.#lt.push(t),!1)}onMessage(e){this.#qe=e}onStateChange(e){this.#At=e}#Be(e){try{const t=JSON.parse(e.data);if("pong"===t.type)return;this.#qe&&this.#qe(t)}catch(e){}}#mt(){for(;this.#lt.length>0&&this.isConnected&&this.#bt;){const e=this.#lt.shift();e&&this.#bt.send(JSON.stringify(e))}}#Ct(e){this.#_t!==e&&(this.#_t=e,this.#At&&this.#At(e))}#yt(){this.#Nt<=0||(this.#Oe=setInterval(()=>{this.isConnected&&this.#bt&&this.#bt.send(JSON.stringify({type:"ping",from:this.#C}))},this.#Nt))}#kt(){this.#Oe&&(clearInterval(this.#Oe),this.#Oe=null)}#Mt(){this.#Ot||(this.#Ot=setTimeout(async()=>{this.#Ot=null;try{await this.connect()}catch{this.#St=Math.min(2*this.#St,this.#It),this.#Rt&&!this.#Dt&&this.#Mt()}},this.#St))}destroy(){this.disconnect(),this.#qe=null,this.#At=null,this.#lt=[]}}class X{#vt;#Pt;constructor(e,t={}){this.#vt=e,this.#Pt=new Map(Object.entries(t)),this.#Pt.has(e)||this.#Pt.set(e,0)}get ownId(){return this.#vt}get(e){return this.#Pt.get(e)??0}tick(){const e=this.get(this.#vt)+1;return this.#Pt.set(this.#vt,e),e}update(e){for(const[t,s]of e.#Pt)s>this.get(t)&&this.#Pt.set(t,s)}happenedBefore(e){let t=!1;const s=new Set([...this.#Pt.keys(),...e.#Pt.keys()]);for(const r of s){const s=this.get(r),i=e.get(r);if(s>i)return!1;s<i&&(t=!0)}return t}isConcurrentWith(e){return!this.happenedBefore(e)&&!e.happenedBefore(this)&&!this.equals(e)}equals(e){const t=new Set([...this.#Pt.keys(),...e.#Pt.keys()]);for(const s of t)if(this.get(s)!==e.get(s))return!1;return!0}canDeliver(e,t){if(e.get(t)!==this.get(t)+1)return!1;for(const[s,r]of e.#Pt)if(s!==t&&r>this.get(s))return!1;return!0}clone(){const e=Object.fromEntries(this.#Pt);return new X(this.#vt,e)}toJSON(){return{ownId:this.#vt,counters:Object.fromEntries(this.#Pt)}}static fromJSON(e){return new X(e.ownId,e.counters)}toString(){const e=[...this.#Pt.entries()].map(([e,t])=>`${e}:${t}`).join(", ");return`VectorClock(${this.#vt}){${e}}`}}class Y{#vt;#xt;#pe;#Ht;#Lt;#Ut;constructor(e,t={}){this.#vt=e,this.#xt=new X(e),this.#pe=[],this.#Ht=t.onDeliver||(()=>{}),this.#Lt=t.maxBufferSize??1e3,this.#Ut=t.onBufferOverflow||null}get ownId(){return this.#vt}get bufferSize(){return this.#pe.length}receive(e,t){const s=X.fromJSON(t.clock);this.#xt.canDeliver(s,e)?(this.#qt(e,t,s),this.#jt()):this.#Wt(e,t,s)}#qt(e,t,s){this.#xt.update(s),this.#Ht(t)}#Wt(e,t,s){this.#pe.length>=this.#Lt?this.#Ut&&this.#Ut({senderId:e,message:t,bufferSize:this.#pe.length}):this.#pe.push({senderId:e,message:t,clock:s})}#jt(){let e=!0;for(;e;){e=!1;for(let t=this.#pe.length-1;t>=0;t--){const{senderId:s,message:r,clock:i}=this.#pe[t];this.#xt.canDeliver(i,s)&&(this.#pe.splice(t,1),this.#qt(s,r,i),e=!0)}}}tick(){return this.#xt.tick(),this.#xt.clone()}getVectorClock(){return this.#xt.clone()}clear(){this.#pe=[]}}export{z as BroadcastChannelTransport,Y as CausalOrderer,L as CrossBus,k as CrossBusError,_ as DeliveryStatus,D as ErrorCode,b as EventEmitter,P as Handshake,N as HandshakePhase,G as MessageChannelTransport,M as MessageRouter,S as MessageType,V as NativeBridgeTransport,x as OriginValidator,H as OriginValidatorPresets,T as PROTOCOL_MARKER,I as PROTOCOL_VERSION,O as PeerStatus,A as PeerType,v as PendingRequests,$ as PostMessageTransport,W as PresenceManager,q as ReadableSignalStream,J as ServiceWorkerTransport,K as SharedWorkerTransport,j as StreamManager,X as VectorClock,Q as WebSocketTransport,U as WritableSignalStream,R as createFastEmitter,f as createPresence,h as deferred,u as detectPeerType,a as isCloneable,i as isCrossBusError,n as isRetryable,c as sleep,d as timestamp,o as uuid,l as withTimeout};
//# sourceMappingURL=crossbus.min.js.map
